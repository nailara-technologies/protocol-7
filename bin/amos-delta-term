#!/usr/bin/perl
use warnings;
use v5.24;
use strict;
use English;
use Term::Size;
use Digest::BMW;
use Math::BigFloat;
use Term::ANSIColor;
use Encode qw| decode |;
use Crypt::PRNG::Fortuna;
use Digest::Elf qw| elf |;
use Time::HiRes qw| time sleep |;
use YAML::XS qw| DumpFile LoadFile |;
use Crypt::Misc qw| encode_b32r decode_b32r |;
no warnings 'experimental';

use Data::Dumper qw| Dumper |;

$YAML::XS::LoadBlessed = 0;
$YAML::XS::UseCode     = 0;
$YAML::XS::DumpCode    = 0;
$YAML::XS::LoadCode    = 0;

###############################
( my $x, my $y ) = Term::Size::chars;
my $screen_bytes = $x * $y * 6;
my $screen_chars = $x * $y;
###############################

### to implement ###

# -Sprng <seed> -Szul <seed>

## [ TEST SEED ]
#
my $restore_seed_prng  = '30879790939393258094788';
my $restore_seed_zulum = '4085077156245892212221638888445691017'
    . '681238712064386070392685102677';

#:: prng  :: 30880122085761213302612
#:: zulum :: 23780279151375710331653524331270981996832420990025717152182839049192

###

our @process_command;

my $set_up = {
    'prompt-hidden'      => 1,
    'prompt-delay'       => 0.377,
    'encode-base32'      => 1,
    'decode-base32'      => 1,
    'substitute-escapes' => 0,                         ##  <-- replace
    'reseed-on-end'      => 0,                         ##  <-- replace
    'state-file'         => 'atom-delta-term.state',
};

our $state = {
    'debug_pages'   => 0,
    'network-time'  => network_time(),
    'last-cmd'      => '',
    'count'         => { 'zulum' => 0 },
    'seed'          => { 'prng'  => undef, 'zulum' => undef, 'num' => undef },
    'set-up'        => $set_up,
    'init'          => 1,
    'init-delay'    => 0.7,
    'screen-buffer' => '',
    'result-13'     => undef,
    'page-legend'   => undef,
    'loop-count'    => 0,
    'iteration'     => 0,
    'zulum-offset'  => 0,
    'speed-div'     => 2,         ## [ 1 .. 7 ] ##
    'screen'        =>
        { 'x' => $x, 'y' => $y, 'chars' => $screen_chars, 'tab-width' => 4 }
};

our $math = {
    'zulum'   => undef,
    'fortuna' => undef
};

sub reset_state {

    $state->{'network-time'} = network_time();

    $state->{'init'}       = 1;
    $state->{'init-delay'} = 0.7;

    map { $math->{$ARG} = undef } qw|  zulum fortuna |;

    map { $state->{'count'}->{$ARG} = 0 } qw| zulum |;
    map { $state->{$ARG} = 0 } qw| loop-count iteration |;

    map { $state->{$ARG} = '' } qw| screen-buffer last-cmd |;
    map { $state->{$ARG} = undef } qw| result-13 |;

}

###
# $state->{'seed'}->{'zulum'} = $restore_seed_zulum;
# $state->{'seed'}->{'prng'}  = $restore_seed_prng;
###

my $color_table = {
    'bg' => { 1 => 0, 2 => 9, 3 => 9, 5 => 4, 6 => 9, 7 => 9 },
    'fg' => { 3 => 4, 6 => 4, 7 => 4, 5 => 4, 1 => 4 }
};

$SIG{__WARN__} = sub {
    die join( ' ',
        "\n < $state->{'iteration'} >",
        @_, "\n [ '", $state->{'result-13'}, "' ]\n\n" );
};

my $freq = qx| /usr/bin/xrandr | =~ m|(\d+(\.\d+)?)(*pla:\*)| ? $MATCH : 30;

my $SIG_INT  = 1;
my $SIG_QUIT = 0;

process_arguments();

my $frame_delay = sprintf( "%.5f", 1 / ( $freq / $state->{'speed-div'} ) );

$| = 1;

$SIG{'TERM'} = $SIG{'QUIT'} = sub { $SIG_QUIT = 1 };
$SIG{'INT'}  = $SIG{'HUP'}  = sub { $SIG_INT  = 1 };

$SIG{'TRAP'} = sub { system 'reset'; dump_state(); sleep 42 };

my $template = "%s%s%s";    ## <bg><fg><char>

binmode( STDOUT, ':encoding(UTF-8)' );    ## converting UTF-7 to UTF-8 ##

#binmode( STDOUT, ':encoding(UTF-32)' );    ## converting UTF-7 to UTF-8 ##

RESTART:

cmd_reset();                              ## clear screen \ ansi reset ##

Math::BigFloat->round_mode('trunc');
Math::BigFloat->accuracy( $screen_bytes + 13 );

my $start_seed = $state->{'seed'}->{'zulum'};

RESEED:

$state->{'count'}->{'zulum'}++;

( $state->{'seed'}->{'num'}
        = sprintf( "%.13f", ( time * 4200 ) / 13 / 13 / 13 ) ) =~ s|\.||;

if ( not defined $start_seed or $state->{'count'}->{'zulum'} == 1 ) {
    $state->{'seed'}->{'prng'} //= $state->{'seed'}->{'zulum'}
        // $state->{'seed'}->{'num'};
} else {
    $state->{'seed'}->{'prng'}
        //= join( '', $start_seed, $state->{'seed'}->{'num'} );
}
## [ [RE]SEEDING THE PRNG .., ] ###
$math->{'fortuna'} //= Crypt::PRNG::Fortuna->new( $state->{'seed'}->{'prng'} );
##

######################## ## use '3' as test intialization [error] seed ##
$state->{'seed'}->{'zulum'}
    //= join( '', map { $math->{'fortuna'}->irand } ( 1 .. 7 ) )
    ;    # <-- plain init
$state->{'seed'}->{'zulum'}
    = join( '', map { $math->{'fortuna'}->irand } ( 1 .. 7 ) )
    if $state->{'count'}->{'zulum'} > 1;
######################## ## ########################

$math->{'zulum'} //= Math::BigFloat->new( $state->{'seed'}->{'zulum'} );

# my $state->{'init-delay'} = 1.42;

# say ' < seed > ' . scalar $math->{'zulum'}->bdiv(13) and sleep 4;

my ( $LAST_BG, $LAST_FG_COL );
while (13) { ## end with CRTL+C or SIGTERM \ SIGQUIT ##

    $state->{'screen-buffer'} = '';
    my $chars_left  = $screen_chars;
    my $last_result = $state->{'result-13'} // '';

    ## pause signal handler ###
    my $signal_handler = $SIG{'INT'};
    $SIG{'INT'} = 'IGNORE';

    $state->{'page-legend'} = '';

    $state->{'result-13'}
        = scalar $math->{'zulum'}->copy()->bdiv( 13, $screen_bytes );

    ## shift for zulum prefix ##
    my $zulum_offset = 0;
    $zulum_offset = $state->{'zulum-offset'}
        = match_zulum( \$state->{'result-13'} );
    ##

    my $dot_offset = $zulum_offset || index( $state->{'result-13'}, '.' );

    if ( $dot_offset >= 0 ) {
        my $result_len  = $screen_bytes - $dot_offset - 1;
        my $page_offset = $state->{'page-offset'} = $dot_offset % 2;

        $state->{'page-legend'}
            = substr( $state->{'result-13'}, 0, $dot_offset - 1 )
            if !$zulum_offset;

        $state->{'result-13'} = substr(
            scalar $math->{'zulum'}
                ->bdiv( 13, $screen_bytes + $dot_offset + $page_offset ),
            $dot_offset + 1 + $page_offset,    ## <-- ..,
            $screen_bytes + $screen_bytes % 2
        );
    } else {
        $state->{'page-offset'} = 0;
    }

    ### remove .., ## [LLL]
    my $result_len = length( $state->{'result-13'} );
    die sprintf "\n  << result length %d != %d >>\n\n", $result_len,
        $screen_bytes
        if $result_len != $screen_bytes;

    $state->{'iteration'} = 0;

    ## resume signal handling ###
    $SIG{'INT'} = $signal_handler;

    if ( !length( $state->{'result-13'} ) ) {
        say '';
        $SIG_INT = 1;
    }

    while ( length( $state->{'result-13'} and $chars_left ) ) {
        $state->{'iteration'}++;

        my $columns = $state->{'screen'}->{'x'};
        my $rows    = $state->{'screen'}->{'y'};

        decode_row( \$state->{'result-13'}, \$state->{'screen-buffer'}, $rows );
    }

    if ( $set_up->{'encode-base32'} ) {
        my $_len = length( $state->{'screen-buffer'} );
        if ( $state->{'screen-buffer'} =~ m|[^A-Z2-7\s]+| ) {
            my $B32 = encode_b32r($MATCH);
            if ( defined $B32 and length($B32) ) {
                $state->{'screen-buffer'} =~ s{\s*\Q$MATCH\E\s*}{$B32};
            }
        }
    }

    if ( $set_up->{'decode-base32'} ) {
        my $_len    = length( $state->{'screen-buffer'} );
        my $success = 1;
        while ( $state->{'screen-buffer'} =~ m|[A-Z2-7]+| and $success ) {
            my $B32D = decode_b32r($MATCH);
            if ( defined $B32D and length $B32D ) {
                $state->{'screen-buffer'} =~ s{$MATCH}{$B32D};
                my $rest_len = $_len - length( $state->{'screen-buffer'} );
                $state->{'screen-buffer'} .= ' ' x $rest_len if $rest_len > 1;
                $success = 1;
            } else {
                $success = 0;
            }
        }
    }

# die $screen_chars . ' \\ ' .$chars_left .' \\ ', length($state->{'screen-buffer'}) - $col_len;

    cmd_quit()        if $SIG_QUIT;
    sig_int_handler() if $SIG_INT;

    my $buffer_len = length( $state->{'screen-buffer'} );

    print clear() . $state->{'screen-buffer'}
        and sleep( 1 / 300 );

    # and sleep( $frame_delay + $state->{'init-delay'} );

    ## "\e[H[$zulum_offset|$buffer_len]\r"

    $state->{'init'} = $state->{'init-delay'} = 0 if $state->{'init'};

    $state->{'loop-count'}++;
}

sub match_zulum {
    my $buffer = $_[0];

    return 0 if index( $$buffer, '.', 1 ) == -1;
    return 0 if index( $$buffer, '0', 0 ) != 0;

    my $zulum_pos = length($$buffer);
    foreach my $num ( 1 .. 9 ) {
        my $match = index( $$buffer, $num, 2 );
        $zulum_pos = $match if $match >= 0 and $match < $zulum_pos;
    }

    return $zulum_pos;
}

sub decode_row {

    ( my $input, my $output, my $chars_left ) = ( $_[0], $_[1], $_[2] // 80 );
    die "['$$input']" if !length($$input);

    my $line_width = $chars_left;

    ##  $$output .= ' ' x $line_width;

ADD_CHARACTERS:

    my $bg_color     = '';
    my $fg_color     = '';
    my $characters_7 = '';

    my $col_len = 0;

    ## background color ##
    $bg_color .= color( sprintf( 'on_r%dg%db%d', 0, 0, $1 ) )
        if $$input =~ m|^.(\d{2})|
        and $1 <= 255;

    ## foreground color ##
    $fg_color .= color( sprintf( 'r%dg%db%d', $3, $2, $1 ) )
        if $$input =~ m|^(\d{3})(\d{3})(\d{3})|
        and $1 <= 255
        and $2 <= 255
        and $3 <= 255;

    $characters_7 .= substr( $$input, 0, 3, '' );    # _dec

    my $characters_8 = '';

    while ( $characters_7 =~ s|\d{2}|| ) {
        $characters_8 .= chr($MATCH);                # _7
    }

    my $decoded_chars = decode( "UTF-7", $characters_8 );

    $LAST_BG     = $bg_color;
    $LAST_FG_COL = $fg_color;

    $col_len += length( $bg_color . $fg_color );

    if ( $set_up->{'substitute-escapes'} ) {
        $decoded_chars =~ s|[\r\v\t\n\f\a\e]| |g;

        # needs own buffer line .., [ overwrite[\type] ]

        ### [ \r ] ###
        my $cr_pos = index( $decoded_chars, "\r" );
        if ( $cr_pos > -1 ) {
            substr( $decoded_chars, $cr_pos, $chars_left ) = ' ' x $chars_left;
            $chars_left = $line_width;
        }

        ### [ \t ] ###
        my $tab_pos = index( $decoded_chars, "\t" );
        if ( $tab_pos > -1 ) {
            my $tab_width = $set_up->{'screen'}->{'tab-width'}
                // 4;    ## <-- check!!!
            substr( $decoded_chars, $tab_pos, $tab_width ) = ' ' x $tab_width;
            $chars_left -= $tab_width;
        }

    }

    ### [ \n ] ###
    my $endline_pos = index( $decoded_chars, "\n" );
    if ( $endline_pos > -1 ) {

        substr( $decoded_chars, $endline_pos, $chars_left ) = ' ' x $chars_left;
        $chars_left = 0;
    }

    $$output .= join( '', $bg_color, $fg_color, $decoded_chars );

    my $dec_len = length($decoded_chars);
    $chars_left -= $dec_len;

    goto ADD_CHARACTERS if $chars_left > $dec_len and length($$input);

    return length($decoded_chars);
}

sub process_arguments {

    while (@ARGV) {

## '-s <speed>' [ 1 .. 7 ] ##
        if (    @ARGV > 1
            and $ARGV[0] eq '-s'
            and $ARGV[1] =~ m|^[1-7]$| ) {
            shift(@ARGV);
            $state->{'speed-div'} = 8 - shift(@ARGV);
        }

## restart run with new seed after message complete ##
        elsif ( @ARGV > 0
            and $ARGV[0] eq '-r' ) {
            $set_up->{'reseed-on-end'} = 1;
            shift(@ARGV);
        }
## '-S <SEQUENCE-SEED>' ##
        elsif ( @ARGV > 1
            and $ARGV[0] eq '-S' ) {
            shift(@ARGV);
            $state->{'seed'}->{'zulum'} = join( ' ', @ARGV );
            $state->{'seed'}->{'zulum'} = join '',
                map { sprintf "%03d", $ARG } unpack 'U*',
                $state->{'seed'}->{'zulum'}
                if $state->{'seed'}->{'zulum'} !~ m|^\d+(\.\d+)?$|;
            @ARGV = ();
        } elsif ( index( $ARGV[0], '-', 0 ) == 0 ) {
            say sprintf "\n  << unknown option '%s' >>\n\n", shift(@ARGV);
            exit(1);
        } else {    ## a list of commands given as arguments ##
            push( @process_command, shift(@ARGV) );
            $SIG_INT = 1;    ##  <--  enter command processing loop .., ##
        }
    }
}

sub elf_BASE32 {
    my $data_ref = shift;
    return encode_b32r( pack( 'V*', elf($$data_ref) ) );
}

sub bmw_BASE32 {
    my $data_ref = shift;
    my $bmw_bits = shift // 512;
    my $bmw      = Digest::BMW->new($bmw_bits);
    $bmw->add($$data_ref);
    return encode_b32r( $bmw->digest );
}

sub network_time { return encode_b32r( pack( 'w*', calc_ntime() ) ) }

sub calc_ntime {    # [ network time : secs from 2002-06-05 * 4200 ]
    my $precision   = 3;
    my $ntime_start = 1023228000;

    my $retries_left    = 24;               ## <-- configure [ retries-max ]
    my $collision_delay = 0;
    my $last_time       = 0;
    my $unix_precision  = $precision + 2;

    my $unix_time = sprintf( "%.0${unix_precision}f", time() );

    my $ntime = sprintf( "%.0${precision}f",
        ( ( $unix_time - $ntime_start ) * 4200 ) );

    return $ntime;
}

sub dump_seed_state {
    say ":: seeds :.\n:\n::: prng :: $state->{'seed'}->{'prng'}\n"
        . ":\n:: zulum :: $state->{'seed'}->{'zulum'}\n:\n";
}

sub checksum_state {
    my $state_ref = shift // \$state;
    delete $$state_ref->{'checksum'};
    my $state_dump = YAML::XS::Dump($$state_ref);
    my $checksums  = {
        'elf' => elf_BASE32( \$state_dump ),
        'bmw' => bmw_BASE32( \$state_dump )
    };
    $$state_ref->{'checksum'}
        = join( '-', $checksums->{'elf'}, substr( $checksums->{'bmw'}, 0, 4 ) );

    return $checksums;    ## B32-elf + B32-bmw-512 ##
}

sub dump_state { checksum_state(); say YAML::XS::Dump($state) }

sub clear     { return "\e[H\e[2J\e[3J" }
sub cmd_clear { say clear() . "# >:]\n" }
sub cmd_reset { system qw| reset |; cmd_clear() }
sub cmd_quit  { cmd_reset();        exit(0) }

sub save_state {
    checksum_state();
    my $chk_sum   = $state->{'checksum'};
    my $file_name = join( '.', $set_up->{'state-file'}, $state->{'checksum'} );
    DumpFile( $file_name, $state );
    unlink( $set_up->{'state-file'} ) if -e $set_up->{'state-file'};
    symlink( $file_name, $set_up->{'state-file'} );
}

sub update_state_files {
    opendir( DIR, '.' ) or return ':: opendir error : ' . lc($OS_ERROR) . ' ::';
    my @state_files = grep {m|^atom-delta-term\.state\.|} readdir(DIR);
    closedir(DIR);
    my $file_count = 0;
    say ':';
    foreach my $file (@state_files) {
        next if !-r $file;
        $file_count++;
        say ":: $file\n:";
        eval {
            my $update = LoadFile($file) or warn ":: $file : $OS_ERROR ::";
            delete $update->{'fortuna'};
            delete $update->{'zulum'};
            checksum_state( \$update );
            DumpFile( $file, $update ) or warn ":: $file : $OS_ERROR ::";
        };
        $file_count-- if $EVAL_ERROR;
    }
    my $err_str = $EVAL_ERROR ? "[ $EVAL_ERROR ]" : '::';
    return ":\n:: $file_count files updated $err_str\n:\n";
}

sub load_state {
    $state = LoadFile( $set_up->{'state-file'} );
}

sub sig_int_handler {
    $SIG_INT = 0;

    my @commands = (
        'exit \\ quit', 'resume \\ continue', qw|
            clear reset checksum show-seed completed load save
            last loop-count buffer result-13 zulum state rewind
            [re]start run commands
            |
    );

    my $int_loop = 1 if !@process_command;

    while ( $int_loop or @process_command ) {
        my $cmd;
        if (@process_command) {
            $cmd = shift @process_command;
        } else {
            if ( !$set_up->{'prompt-hidden'} ) {
                sleep $set_up->{'prompt-delay'};
                print "\eH\e[0m\e[40m\e[34m\r\n< awaiting command > ";
            }
            chomp( $cmd = <STDIN> // '' );
            $cmd =~ s|^\d+||; ## clean-up [ garbled by ansi ] ## [inversitgate.]
        }
        $state->{'last-cmd'} = $cmd
            if $cmd !~ m,^(clear|last|(save|load)-state|resume|continue)$,;
    PROCESS_CMD:
        given ($cmd) {
            when ('last') {
                $cmd = $state->{'last-cmd'} // '';
                goto PROCESS_CMD
            }
            when (m{^(help|commands)$}) {
                say "\n::: available commands :.\n:\n"
                    . join( '',
                    map  {":: $ARG\n"}
                    sort { length $a <=> length $b }
                    sort @commands )
                    . ':'
            }
            when ('loop-count') { say $state->{'loop-count'} }
            when ('legend') {
                say "\n\e[H\e[2J\e[3J$state->{'page-legend'}\r";
            }
            when ('buffer') {
                say "\n\e[H\e[2J\e[3J$state->{'screen-buffer'}";
                sleep 2.42;
            }
            when ('result-13') {
                say "\n\e[3J\n '$state->{'result-13'}'\r";
            }
            when ('zulum') {
                say "\n\e[3J\n '" . scalar( $math->{'zulum'} ) . "'\r"
            }
            when ('clear')          { cmd_clear() }    ## clear screen ##
            when ('reset')          { cmd_reset() }    ## restore screen ##
            when (m{^(exit|quit)$}) { cmd_quit() }
            when (m{^(resume|continue)$}) {            ##  continue., ##
                printf( "%s%s", $LAST_BG, $LAST_FG_COL );
                $SIG_INT = 0 if $SIG_INT > 0;
                goto RESTART if not defined $state->{'result-13'};
                last;
            }
            when ('network-time') { say ":\n:: $state->{'network-time'}\n:" }
            when ('checksum') {
                checksum_state();
                say "\n:\n:: state-checksum :: $state->{checksum}\n:"
            }

            when ('show') { $set_up->{'prompt-hidden'} = 0 }
            when ('hide') { $set_up->{'prompt-hidden'} = 1 }

            when ('update') { say update_state_files() }

            when ('restart') { reset_state(); goto RESTART }
            when (m{^(start|run)$}) {
                if ( $state->{'init'} ) { goto RESTART }
                else {
                    say ":\n:: already initialized\n"
                        . ":: [ 'restart' or 'continue' ]";
                }
            }
            when ('rewind') { reset_state() }
            when (m{^(n(ext)?)?$}) {    ## [n]ext or <ENTER> loops once ###
                $SIG_INT         = -1;
                @process_command = qw| resume |
            }
            when ('show-seed') { dump_seed_state() }

            when (m{set( +([\w\-\.]+)( +(\S+))?)?$}) {
                my $settings = $state->{'set-up'};
                if ( defined $2 and not exists $settings->{$2} ) {
                    say "<< no such key ['$2'] >>";
                } elsif ( not defined $1 ) {
                    say '<< expected key \\ value >>';
                } elsif ( not defined $3 ) {
                    say '<< expected value >>';
                } else {
                    $settings->{$2} = $4 if exists $settings->{$2};
                    say "\n< '$2' = '$4' >";
                }
            }
            when (m{unset +([\w\-\.]+)$}) {
                if ( exists $set_up->{'set-up'}->{$1} ) {
                    say '<< no such key >>';
                } else {
                    $set_up->{$1} = undef if exists $set_up->{$1};
                    say "< key '$1' undefined >";
                }
            }

            when ('state') { dump_state() }
            when ('save')  { save_state() }
            when ('load')  { load_state() }
            when ('completed') {    ## message mode ## [ implement other., ]
                my $len_0000 = length( scalar $math->{'zulum'} );
                my $len_0110
                    = scalar( $math->{'zulum'} ) =~ m|^(0\.0+)|
                    ? length($LAST_PAREN_MATCH)
                    : 0;
                say sprintf(
                    "\r:\n:: $len_0110 \\ $len_0000 ::"
                        . " %.4f percent decoded =) ::\n:\n",
                    $len_0110 * 100 / $len_0000
                );
            }
            default {
                if ( length($cmd) ) {
                    say ":\n:[ command '$cmd' unknown ]\n:";
                } else {
                    print "\r< awaiting command > ";
                }
            }
        }
    }
}

# ______________________________________________________________________________
#\\P6SWGVCP3G4YT3UEZ5TFPDFH5KCHMZ5HOQFSI26XZPMSFVFNKQEIP3S2GO5AK3LEKTJSWQN7YZGS6
# \\ UCIUOLEUEJD5RS5WS6X6W5FXK24YTS27URLO5EPMC7ME2EQQWWFB \\// C25519-BASE-32 //
#  \\// TLJ74C7WX6STVRGGQ5QE3P66PZILW7BI6HRLVYBYFIQ2HCX7ICQ \\ CODE SIGNATURE \\
#   ````````````````````````````````````````````````````````````````````````````
