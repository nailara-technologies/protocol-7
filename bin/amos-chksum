#!/usr/bin/perl
use v5.24;
use strict;
use English;
use warnings;
use Getopt::Std;
use Math::BigFloat;
use Digest::Elf qw| elf |;
use Digest::BMW qw| bmw_512 |;
use Crypt::Misc qw| encode_b32r |;
Math::BigFloat->round_mode('trunc');

##[ RUNTIME OPTIONS ]#########################################################

## -q ## quiet output \ value only \
## -h ## follow harmony [ string | numeric ]
## -n ## return checksum as numerical value
## -v ## visualize additional checksum data

##[ PREPARING ]###############################################################

$SIG{'__WARN__'} = \&error_exit;
use warnings FATAL => 'all';

getopts( 'vhnq', \my %option );
warn "expected input string for AMOS-checksum calculation\n" if not @ARGV;

my $string = join( ' ', @ARGV );

##[ CHECKSUM CALCULATION ]####################################################

my $elf_bits = sprintf( '%032b', join( '', reverse split '', elf($string) ) );
my $bmw_512b = unpack( 'B512', bmw_512($string) );
my $bmw_512R = join( '', reverse split '', $bmw_512b );
my $bmw_b_L  = substr( $bmw_512b, 0, 32 );
my $bmw_b_R  = substr( $bmw_512R, 0, 32 );

my $bmw_mod_step = 0;
my $bmw_mod_bits = scalar( '0' x 32 ) . $bmw_512b . scalar( '0' x 32 );

( my $checksum_bits = $elf_bits ) =~ s|^0+|
                                        substr $bmw_b_L, 0, length($MATCH) |e;
$checksum_bits =~ s|0+$|
                    substr $bmw_b_R, 0, length($MATCH) |e;

## ######### ##   ##    ##     ##      ##
my $checksum = eval "0b$checksum_bits";    ## numerical ##
## ######### ##   ##    ##     ##      ##

my @mod_bits;

INVERT_TRUTH_STATE:

if ($bmw_mod_step) {    ## enforce required \ requested truth state ##
    my $cur_mod_bits = substr( $bmw_mod_bits, 0, 32 );
    if ( $cur_mod_bits eq '0' x 32 ) {    ## skip '0' prefixes ##8
        ++$bmw_mod_step and substr( $bmw_mod_bits, 0, 1, '' );
        goto INVERT_TRUTH_STATE;
    }
    $checksum ^= eval join( '', '0b', $cur_mod_bits );
    push( @mod_bits, $cur_mod_bits ) if $option{'v'};
}

#   ################ #        ###          #
my $checksum_encoded = encode_b32r( pack( 'V', $checksum ) );
##  ################ ##       ###          #

if ( length($bmw_mod_bits) > 32 ) {
    if ( not $option{'h'} ) {    ## ENCODED + VALUE AND STRING HARMONY ##

        if (   not is_true($checksum)
            or not is_true($checksum_encoded) ) {

            ++$bmw_mod_step and substr( $bmw_mod_bits, 0, 1, '' );
            goto INVERT_TRUTH_STATE;
        }

    } else {                     ## ENCODED + FOLLOW TRUTH ##

        if (   is_true($string) != is_true($checksum)
            or is_true($string) != is_true($checksum_encoded) ) {

            ++$bmw_mod_step and substr( $bmw_mod_bits, 0, 1, '' );
            goto INVERT_TRUTH_STATE;
        }
    }
} else {
    warn "bit modification entropy depleted [ cannot enforce truth state ]\n";
}

##[ VERBOSE RESULT VALUES ]###################################################

my $rst = "\e[0m";
my $bg  = "\e[48;2;9;5;42m";
my $fg  = "\e[38;2;68;39;172m";
my $ng  = "\e[38;2;71;195;6m";
my $no  = "\e[38;2;197;141;7m";

if ( $option{'v'} ) {
    my $offset_str
        = $bmw_mod_step
        ? " [ bmw-mod-step : $bmw_mod_step ]"
        : '';

    my @mod_bits_str
        = @mod_bits
        ? (
        '',
        '  bmw-mod-bits  :  ' . shift @mod_bits,
        ( map { scalar( ' ' x 14 ) . '  :  ' . $ARG } @mod_bits ),
        '',
        sprintf( "    C-SUM-bits  : $bg $no%032b$fg $rst", $checksum ),
        )
        : ();

    map {say} (
        $fg,
        '  input-string  :  '
            . "$bg $ng$string $rst$fg "
            . true_false($string),
        $fg,
        '   reverse-elf  :  ' . $elf_bits,
        '    bmw-R-bits  :  ' . $bmw_b_R,
        '    bmw-L-bits  :  ' . $bmw_b_L,
        '',
        '     AMOS-bits  : ' . "$bg $ng" . $checksum_bits . "$fg $rst$fg",
        @mod_bits_str,
        '',
        join( ' ',
            "   VAX-encoded  : $bg",
            "$no$checksum_encoded$fg $rst$fg :",
            sprintf( "%010d", $checksum ),
            true_false($checksum) ),
        '', $rst
    );
} elsif ( $option{'n'} ) {

    my $num_str = sprintf( "%010d", $checksum );
    say $num_str and exit if $option{'q'};
    say "$fg:\n:$bg $ng$num_str$fg $rst\n$fg:$rst";

} else {

    say $checksum_encoded and exit if $option{'q'};
    say "$fg:\n:$bg $ng$checksum_encoded$fg $rst\n$fg:$rst";
}

##[ ERROR HANDLER ]###########################################################

sub error_exit {
    my $rst = "\e[0m";
    my $ec  = "\e[38;2;197;141;7m";
    chomp( my $e = lcfirst(shift) );
    say ":\n: $ec$e$rst\n:";
    exit(110);
}

##[ TRUTH STATE ]#############################################################

sub true_false {
    my $C = shift;
    return '' if not length $C or $C =~ m|^\e|;
    is_true($C) ? '< TRUE >' : '< FALSE >';
}

##[ HARMONIC TRUTH ASSERT ]###################################################

sub is_true {

    my $input_string = shift // '';
    my $calc_str;
    my $accuracy = 13;

    state $cache //= {};
    return $cache->{$input_string} if exists $cache->{$input_string};

    if ( $input_string =~ m|^\d+$| ) {    ## check as mumber ##

        $calc_str = Math::BigFloat->new($input_string)
            ->bdiv( 13, 13 + length($input_string) );

    } else {                              ## check as string ##

        my $elf_checksum = elf($input_string);
        $calc_str = Math::BigFloat->new($elf_checksum)
            ->bdiv( 13, 13 + length($elf_checksum) );
    }

    ## FALSE ### 230769 ####
    return $cache->{$input_string} = 0
        if index( scalar $calc_str, qw| 230769 | ) >= 0;

    ### TRUE ### 384615 | 00000000 ####
    return $cache->{$input_string} = 1;
}

#.............................................................................
#UJIFIFKQZEKIXRREOKYD6MDW66VAJS7VH6I2ZXDSXZNESPBC3CCYDCOX3EGHLOGW272KW76Z57YNG
#::: NSFOMZ3TPZUKYSHJORLZJKK5AM73IBI6PSKHFH3M4ZKOYX6JNIC :::: NAILARA AMOS :::
# :: RYKEJH2KPJHHGNGPMQXHOQDMQAOQGFBUOZWLUVYXGWUQSKF5MGDY :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
