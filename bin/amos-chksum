#!/usr/bin/perl

use v5.24;
use strict;
use English;
use warnings;
use Getopt::Std;

####           ####
##  amos-chksum  ##
###            ####

##[ LOCAL PM LIB PATH ]#######################################################

BEGIN {
    use English;
    use File::Spec;
    use Cwd qw| abs_path |;
    use FindBin qw| $RealBin |;
    my $up_dir         = File::Spec->updir;
    my $data_pm_path   = qw| data/lib-path/pm |;
    my $root_path      = abs_path( r2_abs( c_dir( $RealBin, $up_dir ) ) );
    my $local_lib_path = abs_path( c_dir( $root_path, $data_pm_path ) );
    $local_lib_path //= $data_pm_path;
    die "\n:\n:: not found : $local_lib_path\n:\n" if !-d $local_lib_path;
    unshift( @INC, $local_lib_path )               if -d $local_lib_path;
    sub c_dir  { File::Spec->catdir(@ARG) }
    sub r2_abs { File::Spec->rel2abs(@ARG) }
}

##[ AMOS MODULE ]#############################################################

use AMOS7;
use AMOS7::CHKSUM;
use AMOS7::CHKSUM::ELF;
use AMOS7::Assert::Truth;

## version chksum calculation ##
use AMOS7::INLINE::src::AMOS_13_ELF;  ## implement other versions too ## [LLL]

my $chksum_elf_mode = $AMOS7::CHKSUM::algorithm_set_up{'chksum_elf_mode'}; ##7
my $elf_shift_bits = $AMOS7::CHKSUM::algorithm_set_up{'elf_shift_bits'}; ## 13

my @modes = @{ $AMOS7::CHKSUM::algorithm_set_up{'elf_truth_modes'} };    ## 7

##[ RUNTIME OPTIONS ]#########################################################

## -q ## quiet output \ value only \

## -s ## STDIN data input mode [ single ]
## -S ## STDIN data input mode [ combined ]
## -n ## return checksum as numerical value
## -v ## visualize additional checksum data

## -T ## sprintf template for truth verification

## -elf-mode[s]=<elf-mode[s]> ##  comma seperated elf modes list  ##

##  -VA   ## show AMOS checksum algorithm version and exit    ##
##  -VL   ## calculate inline elf output checksum and exit    ##
##  -VLS  ## calculate inline elf sourcecode version and exit ##

##[ INITIALIZATION \ OPTIONS ]################################################

my $data_str;

##   AMOS7.pm error handler   ##
$SIG{'__WARN__'} = \&error_exit;
use warnings FATAL => qw| all |;

getopts( qw| vSnsqe:V:T: |, \my %option );

if ( defined $option{'e'} ) {
    my @elf_modes_override;
    error_exit( "elf modes syntax$C{0}: $C{b}$C{o}-elf-modes$C{R}"
            . "$C{0}\[=$C{T}$C{b}<n>$C{R}$C{0}\[,$C{T}$C{b}<n>$C{R}$C{0}..,]]"
        )
        if $option{'e'}  !~ m|^lf-mode=\d{1,2}$|
        and $option{'e'} !~ m|^lf-modes(=\d{1,2}(,\d{1,2})*)?$|;
    @elf_modes_override = split( ',', $+{m0} // $+{M} )
        if $option{'e'}
        =~ m{^lf-mode(=(?<m0>\d{1,2})|s=(?<M>\d{1,2}(,\d{1,2})*))$};

    if ( !@elf_modes_override ) {
        say sprintf(
            "$C{0}:\n::$C{T}  elf modes  $C{0}\:. %s$C{0}\ .:\n$C{0}:$C{R}",
            join( '', map {" $C{b}$C{T}$C{B}$ARG$C{R}$C{0} "} sort @modes ) )
            and exit;
    } else {
        @modes = @elf_modes_override;
    }
}

##  substring template parameters for -T option  ##
##
my $sstr_start = 0;
my $str_length = 7;

if ( defined $option{'T'} ) {
    my $template        = $option{'T'};
    my $substring_templ = ${^CAPTURE}[0]
        if $template =~ s|(*plb:(*nlb:\%)%s)(*nlb:\\):((\d+,)?\d+)||sg;
    if ( defined $substring_templ ) {
        if ( index( $substring_templ, ',', 1 ) == 1 ) {
            ( $sstr_start, $str_length ) = split( ',', $substring_templ );
        } else {
            $str_length = $substring_templ;
        }
    }

    error_exit('substring template out of range [ 1..7 ] <{NC}>')
        if $str_length < 1
        or $str_length + $sstr_start > 7;

    if ( $str_length < 7 ) {    ##  setting substring template params  ##
        $AMOS7::CHKSUM::sstr_start = $sstr_start;
        $AMOS7::CHKSUM::str_length = $str_length;
    }

    my @match_count = $template =~ m|(*nlb:\%)%s|sg;
    error_exit(
        "sprintf template '%s' not valid [ expecting single %%s ] <{NC}>",
        $template )
        if @match_count != 1;
}

### move version calculation to AMOS7::CHKSUM module ### [LLL]

## display source versions ## [ calculated ]
if ( defined $option{'V'} ) {

    my $version_template = qw| .%s:AMOS-13-CHKSUM-VERSION:%s. |;
    my $data_str         = sprintf( $version_template, chr(255), chr(0) );

    if ( $option{'V'} eq qw| CS | ) {    ##  AMOS-CHKSUM OUTPUT VERSION  ##
        my $version_string = gen_version( qw| AMOS-CHKSUM-V-%s |, $data_str );
        say $version_string if not $option{'v'};
    } elsif ( $option{'V'} =~ m,^(L7|S)$, )
    {                                    ## elf_sum() source code version ##
        my $elf_sum
            = elf_chksum( $data_str, 0, $chksum_elf_mode, $elf_shift_bits );

        my $elf_out_ver = gen_version( qw| AMOS-13-ELF-7-%s |, $elf_sum );

        if ( $option{'V'} eq qw| L7 | ) { ## elf_sum() output test checksun ##

            say $elf_out_ver if not $option{'v'};

        } else {    ## version of elf_sum() source code ## [ -VS ] ##

            $data_str = "  /* .: $elf_out_ver :. */\n\n"
                . AMOS7::INLINE::src::AMOS_13_ELF::inline_elf();
            my $elf_inline_ver
                = gen_version( qw| AMOS-13-ELF-7-SRC-VER-%s |, $data_str );
            say $elf_inline_ver if not $option{'v'};
        }
    } else {
        die ":\n: version option not recognized : [ CS | L7 | S ]\n:\n";
    }
    exit if not $option{'v'};
}

sub gen_version {
    my $template = shift;
    my $data_str = shift;
    my $version_chksum;
    my $version_string = '';
    while ( not defined $version_chksum or not is_true($version_string) ) {
        $version_chksum = amos_chksum( $version_chksum // $data_str );
        $version_string = sprintf( $template, $version_chksum );
    }
    return $version_string;
}

##[ DATA INPUT MODES ]########################################################

error_exit('expected input string for AMOS-checksum calculation <{NC}>')
    if not defined $data_str
    and not $option{'S'}
    and not $option{'s'}
    and not @ARGV;

$AMOS7::CHKSUM::algorithm_set_up{'return_modbits'} = 1 if $option{'v'};

if ( not defined $data_str and not $option{'s'} and not $option{'S'} ) {
    $data_str = join( ' ', @ARGV );    ## COMMAND LINE INPUT ##

} elsif ( not defined $data_str and not $option{'s'} or $option{'S'} ) {
    $data_str = join( '', <STDIN> ); ## STDIN COMBINED ## [  amos-chksum -S  ]
} else {
    while ( my $line = <STDIN> ) {
        next if not defined $line or not length $line;
        chomp($line);
        my $checksum = AMOS7::CHKSUM::amos_chksum( \$line, @modes );

        $checksum = sprintf( qw| %010d |, $AMOS7::CHKSUM::num_amos_csum )
            if $option{'n'};

        if ( $option{'q'} ) {
            say $checksum;
        } else {
            say "$C{0}:\n:$C{b} $C{T}$checksum$C{0} $C{R}\n$C{0}:$C{R}";
        }
    }
    exit(00000);
}

##[ CHECKSUM CALCULATION ]####################################################

my $checksum_encoded;

if ( defined $option{'T'} ) {    ## using template for truth verification ##
    my $template = $option{'T'};

    $checksum_encoded
        = AMOS7::CHKSUM::amos_template_chksum( $template, \$data_str,
        @modes );

} else {
    $checksum_encoded = AMOS7::CHKSUM::amos_chksum( \$data_str, @modes );
}

##[ VERBOSE RESULT VALUES ]###################################################

if ( $option{'v'} ) {
    my $offset_str
        = $AMOS7::CHKSUM::bmw_mod_step
        ? " [ bmw-mod-step : ${AMOS7::CHKSUM::bmw_mod_step} ]"
        : '';

    my @mod_bits = @AMOS7::CHKSUM::mod_bits;
    my @mod_bits_str
        = @mod_bits
        ? (
        '',
        '  bmw-mod-bits  :  ' . shift @mod_bits,
        ( map { scalar( ' ' x 14 ) . '  :  ' . $ARG } @mod_bits ),
        '',
        sprintf( "     AMOS-bits  : $C{b}$C{T} %032b $C{0}$C{R}",
            $AMOS7::CHKSUM::num_amos_csum ),
        )
        : ();

    my $len_delta         = 11 - length($AMOS7::CHKSUM::num_amos_csum);
    my $num_amos_csum_str = sprintf( ":$C{T} %d $C{0}%s",
        $AMOS7::CHKSUM::num_amos_csum, ':' x $len_delta );

    my %COLOR = (
        'input' => is_true( $data_str, 1, 1, @modes ) ? $C{T} : $C{g},
        'bits'  => is_true( $AMOS7::CHKSUM::checksum_bits, 0, 1, @modes )
        ? $C{T}
        : $C{g}
    );

    my $header_string
        = ( $data_str =~ m|\n| )
        ? sprintf(
        "$C{b}$C{T}\::$C{R}\n\n%s\n$C{b}$C{T}\::$C{R} %s",
        join( '',
            map {"   $C{b}$COLOR{'input'}$ARG$C{R}\n"} split "\n",
            $data_str ),
        TRUE_FALSE($data_str)
        )
        : sprintf( "$C{0}    input data  : %s",
        TRUE_FALSE($data_str)
            . " $C{b}$COLOR{'input'} $data_str $C{R}$C{0} " );

    map {say} (
        '',
        $header_string,
        '',
        "$C{0}   reverse-elf  :  " . true_bits($AMOS7::CHKSUM::elf_bits),
        "$C{0}    bmw-R-bits  :  " . true_bits($AMOS7::CHKSUM::bmw_b_R),
        "$C{0}    bmw-L-bits  :  " . true_bits($AMOS7::CHKSUM::bmw_b_L),
        "$C{0}    bmw-C-bits  :  " . true_bits($AMOS7::CHKSUM::bmw_b_C),
        '',
        "$C{0}   chksum-bits  :  " . true_bits($AMOS7::CHKSUM::checksum_bits),
        @mod_bits_str,
        '',
        sprintf(
            "%s  assert truth  :  $C{T}elf-modes$C{0} %s",
            $C{0}, join( '', map {"$C{b}$C{T} $ARG $C{R}$C{0} "} sort @modes )
        ),
        sprintf(
            "%s  elf overflow  :  $C{T}bit-shift$C{0} %s",
            $C{0}, "$C{b}$C{T} $elf_shift_bits $C{R}$C{0} "
        ),
        '',
        join(
            ' ', "$C{0}   VAX-encoded  : " . TRUE_FALSE($checksum_encoded)
            )
            . " $C{b}$C{T}$C{B}$checksum_encoded$C{R}"
            . "$C{0} $num_amos_csum_str",
        '',
        $C{R}
    );
} elsif ( $option{'n'} ) {

    say $AMOS7::CHKSUM::num_amos_csum and exit if $option{'q'};
    say "$C{0}:\n:$C{b} $C{T}${AMOS7::CHKSUM::num_amos_csum}$C{0}"
        . " $C{R}\n$C{0}:$C{R}";

} else {
    say $checksum_encoded and exit if $option{'q'};
    say "$C{0}:\n:$C{b} $C{T}$checksum_encoded$C{0} $C{R}\n$C{0}:$C{R}";
}

##[ VISUALIZE TRUTH ASSERTION ]###############################################

sub TRUE_FALSE {
    my $check_data = shift;
    return '' if not defined $check_data;
    is_true( $check_data, 1, 1, @modes )
        ? "$C{0}\:: $C{T}TRUE$C{0} ::$C{R}"
        : "$C{0}\:: $C{g}FALSE$C{0} ::$C{R}";
}

sub true_bits {    ## not numerical ##
    my $visualize_data = shift;
    return '' if not defined $visualize_data;
    is_true( $visualize_data, 0, 1, @modes )
        ? "$C{T}$visualize_data$C{R}"
        : "$C{0}$visualize_data$C{R}";
}

#,,,,,,,.,,,.,.,,,,,.,,.,,...,.,.,.,,,..,,.,.,..,,...,...,,,,,,,,,,.,,,.,,,,,,
#FU2OTEI5VVDSGKWP3FNUPXFOFT4URDL7QOCD6SMOZC2ZC2ZRFM3BPMXCCMZSTDLBM4D57ULOTUCLC
#\\\|F3TPVC4C25CCVUKJKOFDRYPJRFR6HTHTUCSXQDYZG4MKQ5JNRH2 \ / AMOS7 \ YOURUM ::
#\[7]UFG6MOSZQJEYEQRDLUTTWZ2J3N3I2VQ3CDQNBNU63WYUBOQFEGDY 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
