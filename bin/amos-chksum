#!/usr/bin/perl
use v5.24;
use strict;
use English;
use warnings;
use Getopt::Std;
use Digest::BMW;
use List::Util qw| uniqint |;

####           ####
##  amos-chksum  ##
###            ####

##[ LOCAL PM LIB PATH ]#######################################################

BEGIN {
    use English;
    use Cwd 'abs_path';
    my $script_path = abs_path($PROGRAM_NAME);
    ( my $local_lib_path = $script_path )
        =~ s|/[^/]+/[^/]+$|/data/lib-path/pm|;
    unshift( @INC, $local_lib_path ) if -d $local_lib_path;
}

##[ AMOS MODULE ]#############################################################

use AMOS::CHKSUM;
use AMOS::CHKSUM::ELF;
use AMOS::Assert::Truth;
use AMOS::CHKSUM::ELF::Inline;

my @modes = @{ $AMOS::CHKSUM::algorithm_set_up{'elf_truth_modes'} };

##[ RUNTIME OPTIONS ]#########################################################

## -q ## quiet output \ value only \
## -n ## return checksum as numerical value
## -v ## visualize additional checksum data
#
## -elf-modes=<elf-modes> ## comma seperated elf modes list ##

##  -VA   ## show AMOS checksum algorithm version and exit    ##
##  -VL   ## calculate inline elf output checksum and exit    ##
##  -VLS  ## calculate inline elf sourcecode version and exit ##

##[ COLORS ]##################################################################

my $rst = "\e[0m";
my $bl  = "\e[1m";
my $bg  = "\e[48;2;9;5;42m";
my $fg  = "\e[38;2;68;39;172m";
my $ng  = "\e[38;2;71;195;6m";
my $no  = "\e[38;2;197;141;7m";
my $TC  = "\e[38;2;6;71;195m";

##[ INITIALIZATION \ OPTIONS ]################################################

$SIG{'__WARN__'} = \&error_exit;
use warnings FATAL => qw| all |;

getopts( 'vnqV:e:', \my %option );

if ( defined $option{'e'} ) {
    my @elf_modes_override;
    error_exit( "elf modes syntax$fg: $bg$no-elf-modes$rst"
            . "${fg}[=$TC$bg<n>$rst${fg}[,$TC$bg<n>$rst$fg..,]]" )
        if $option{'e'}  !~ m|^lf-mode=\d{1,2}$|
        and $option{'e'} !~ m|^lf-modes(=\d{1,2}(,\d{1,2})*)?$|;
    @elf_modes_override = uniqint split( ',', $+{m0} // $+{M} )
        if $option{'e'}
        =~ m{^lf-mode(=(?<m0>\d{1,2})|s=(?<M>\d{1,2}(,\d{1,2})*))$};

    if ( !@elf_modes_override ) {
        say sprintf( "$fg:\n::$TC  elf modes  ${fg}:. %s${fg} .:\n$fg:$rst",
            join( '', map {" $bg$TC$bl$ARG$rst$fg "} sort @modes ) )
            and exit;
    } else {

        @modes = @elf_modes_override;
    }
}

### move version calculation to AMOS::CHKSUM module ### [LLL]

## display source versions ## [ calculated ]
if ( defined $option{'V'} ) {
    if ( $option{'V'} eq 'A' ) {    ## AMOS checksum ouput test version ##
        say sprintf(
            "AMOS-%s",   ## --> harmony -Ty  ## 2V0 RмѕU *4L4 \ Жй5ЛB:лЖэН! ##
            amos_chksum( sprintf( '%sAMOS-CHKSUM%s', chr(255), chr(0) ) )
        );

    } elsif ( $option{'V'} =~ m|^LS?$| ) { ## elf_sum() source code version ##

        my $calc_input = sprintf( '%sELF-INLINE-CHKSUM%s', chr(255), chr(0) );

        my $elf_output  = elf_chksum($calc_input);    ## я80л <>З Сдєм D0 ##
        my $elf_out_ver = sprintf( qw| ELF-%s |, amos_chksum($elf_output) );

        if ( $option{'V'} eq 'L' ) {    ## elf_sum() output test checksun ##

            say $elf_out_ver;

        } else {                        ## version of elf_sum() source code ##
            say sprintf(
                qw| ELF-%s-L |,         ## *ЙА VГH:Й \ кЌ;`йQкIM3N K9mАд ##
                amos_chksum( "$elf_out_ver\n" . inl_elf_src() )
            );
        }
    } else {
        die ":\n: version option not recognized : [ A | L | LS ]\n:\n";
    }
    exit;
}

warn "expected input string for AMOS-checksum calculation\n" if not @ARGV;

$AMOS::CHKSUM::algorithm_set_up{'return_modbits'} = 1 if $option{'v'};

my $data_str = join( ' ', @ARGV );

##[ CHECKSUM CALCULATION ]####################################################

my $checksum_encoded = AMOS::CHKSUM::amos_chksum( \$data_str, @modes );

##[ VERBOSE RESULT VALUES ]###################################################

if ( $option{'v'} ) {
    my $offset_str
        = $AMOS::CHKSUM::bmw_mod_step
        ? " [ bmw-mod-step : ${AMOS::CHKSUM::bmw_mod_step} ]"
        : '';

    my @mod_bits = @AMOS::CHKSUM::mod_bits;
    my @mod_bits_str
        = @mod_bits
        ? (
        '',
        '  bmw-mod-bits  :  ' . shift @mod_bits,
        ( map { scalar( ' ' x 14 ) . '  :  ' . $ARG } @mod_bits ),
        '',
        sprintf( "    C-SUM-bits  : $bg$TC %032b $fg$rst",
            $AMOS::CHKSUM::checksum_num ),
        )
        : ();

    my $len_delta        = 11 - length($AMOS::CHKSUM::checksum_num);
    my $checksum_num_str = sprintf( ":$TC %d $fg%s",
        $AMOS::CHKSUM::checksum_num, ':' x $len_delta );

    my %COLOR = (
        'input' => is_true( $data_str, 1, 1, @modes ) ? $TC : $ng,
        'bits'  => is_true( $AMOS::CHKSUM::checksum_bits, 0, 1, @modes )
        ? $TC
        : $ng
    );

    map {say} (
        '',
        "$fg  input-string  : "
            . TRUE_FALSE($data_str)
            . " $bg$COLOR{'input'} $data_str $rst$fg ",
        '',
        "$fg   reverse-elf  :  ${AMOS::CHKSUM::elf_bits}",
        "$fg    bmw-R-bits  :  ${AMOS::CHKSUM::bmw_b_R}",
        "$fg    bmw-L-bits  :  ${AMOS::CHKSUM::bmw_b_L}",
        "$fg    bmw-C-bits  :  ${AMOS::CHKSUM::bmw_b_C}",
        '',
        "$fg     AMOS-bits  :  $bg$COLOR{'bits'}"
            . "${AMOS::CHKSUM::checksum_bits}$fg$rst$fg ",
        @mod_bits_str,
        '',
        sprintf(
            '%s   truth-modes  :  elf-mode %s',
            $fg, join( '', map {" $bg$TC $ARG $rst$fg "} sort @modes )
        ),
        '',
        join( ' ', "$fg   VAX-encoded  : " . TRUE_FALSE($checksum_encoded) )
            . " $bg$TC$bl$checksum_encoded$rst$fg $checksum_num_str",
        '', $rst
    );
} elsif ( $option{'n'} ) {

    say $AMOS::CHKSUM::checksum_num and exit if $option{'q'};
    say "$fg:\n:$bg $TC${AMOS::CHKSUM::checksum_num}$fg $rst\n$fg:$rst";

} else {
    say $checksum_encoded and exit if $option{'q'};
    say "$fg:\n:$bg $TC$checksum_encoded$fg $rst\n$fg:$rst";
}

##[ ERROR HANDLER ]###########################################################

sub error_exit {
    chomp( my $emsg = shift );

    my $bl  = "\e[38;2;68;39;172m";
    my $no  = "\e[38;2;197;141;7m";
    my $rst = "\e[0m";

    $emsg =~ s|^[A-Z](*nla:[A-Z])|\l$MATCH|;
    $emsg =~ s|(*plb:\w): (\S+)|$bl : $no$LAST_PAREN_MATCH|;

    say "$bl:\n: $no$emsg$bl\n:$rst";
    exit(110);
}

##[ VISUALIZE TRUTH ]#########################################################

sub TRUE_FALSE {
    my $C = shift;
    return '' if not length $C or $C =~ m|^\e|;
    is_true( $C, 1, 1, @modes )
        ? "${fg}:: ${TC}TRUE$fg ::"
        : ":: ${ng}FALSE$fg ::";
}

#.............................................................................
#XWMJRSORRRZFR72XBHEH5VG7BRHD53Y4DIPODOQ4HAG4FI33MHHDTPMLKQI3OIGODSCHIIRZJ5ZQ2
#::: HD47GVJI2TLRGEV2D7ZBX32WA77I4NKBVWNMCAQJMUCQSF6OOD4 :::: NAILARA AMOS :::
# :: GVOQWGBHAHAREHJ2UXDK5T2FW7V5W4ZXSUCP5264PP2Y77DUMKCA :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
