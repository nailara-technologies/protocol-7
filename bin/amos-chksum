#!/usr/bin/perl
use v5.24;
use strict;
use English;
use warnings;
use Getopt::Std;
use Digest::BMW;

####           ####
##  amos-chksum  ##
###            ####

##[ LOCAL PM LIB PATH ]#######################################################

BEGIN {
    use English;
    use Cwd 'abs_path';
    my $script_path = abs_path($PROGRAM_NAME);
    ( my $local_lib_path = $script_path )
        =~ s|/[^/]+/[^/]+$|/data/lib-path/pm|;
    unshift( @INC, $local_lib_path ) if -d $local_lib_path;
}

##[ AMOS MODULE ]#############################################################

use AMOS::CHKSUM;
use AMOS::CHKSUM::ELF;
use AMOS::Assert::Truth;
use AMOS::CHKSUM::ELF::Inline;

my @modes = @{ $AMOS::CHKSUM::algorithm_set_up{'elf_truth_modes'} // [] };

##[ RUNTIME OPTIONS ]#########################################################

## -q ## quiet output \ value only \
## -s ## STDIN data input mode
## -n ## return checksum as numerical value
## -v ## visualize additional checksum data
#
## -elf-modes=<elf-modes> ## comma seperated elf modes list ##

##  -VA   ## show AMOS checksum algorithm version and exit    ##
##  -VL   ## calculate inline elf output checksum and exit    ##
##  -VLS  ## calculate inline elf sourcecode version and exit ##

##[ COLORS ]##################################################################

my $rst = "\e[0m";
my $bl  = "\e[1m";
my $bg  = "\e[48;2;9;5;42m";
my $fg  = "\e[38;2;68;39;172m";
my $ng  = "\e[38;2;71;195;6m";
my $no  = "\e[38;2;197;141;7m";
my $CT  = "\e[38;2;6;71;195m";

##[ INITIALIZATION \ OPTIONS ]################################################

my $data_str;

$SIG{'__WARN__'} = \&error_exit;
use warnings FATAL => qw| all |;

binmode( STDOUT, ':encoding(UTF-8)' );

getopts( 'vsnqV:e:', \my %option );

if ( defined $option{'e'} ) {
    my @elf_modes_override;
    error_exit( "elf modes syntax$fg: $bg$no-elf-modes$rst"
            . "${fg}[=$CT$bg<n>$rst${fg}[,$CT$bg<n>$rst$fg..,]]" )
        if $option{'e'}  !~ m|^lf-mode=\d{1,2}$|
        and $option{'e'} !~ m|^lf-modes(=\d{1,2}(,\d{1,2})*)?$|;
    @elf_modes_override = split( ',', $+{m0} // $+{M} )
        if $option{'e'}
        =~ m{^lf-mode(=(?<m0>\d{1,2})|s=(?<M>\d{1,2}(,\d{1,2})*))$};

    if ( !@elf_modes_override ) {
        say sprintf( "$fg:\n::$CT  elf modes  ${fg}:. %s${fg} .:\n$fg:$rst",
            join( '', map {" $bg$CT$bl$ARG$rst$fg "} sort @modes ) )
            and exit;
    } else {

        @modes = @elf_modes_override;
    }
}

### move version calculation to AMOS::CHKSUM module ### [LLL]

## display source versions ## [ calculated ]
if ( defined $option{'V'} ) {

    my $version_template = '.%s:AMOS::CHKSUM:%s.';

    if ( $option{'V'} eq 'A' ) {    ## AMOS checksum ouput test version ##

        $data_str = sprintf( $version_template, chr(255), chr(0) );
        say sprintf( "AMOS-%s", amos_chksum($data_str) ) if not $option{'v'};

    } elsif ( $option{'V'} =~ m|^LS?$| ) { ## elf_sum() source code version ##

        $data_str
            = elf_chksum( sprintf( $version_template, chr(255), chr(0) ), 7 );

        my $elf_out_ver
            = sprintf( qw| AMOS-INLINE-ELF-V-%s |, amos_chksum($data_str) );

        if ( $option{'V'} eq 'L' ) {    ## elf_sum() output test checksun ##

            say $elf_out_ver if not $option{'v'};

        } else {                        ## version of elf_sum() source code ##

            $data_str = "  /* $elf_out_ver */\n\n" . inl_elf_src();

            say sprintf( qw| ELF-%s-LS |, amos_chksum($data_str) )
                if not $option{'v'};
        }
    } else {
        die ":\n: version option not recognized : [ A | L | LS ]\n:\n";
    }
    exit if not $option{'v'};
}

warn "expected input string for AMOS-checksum calculation\n"
    if not defined $data_str
    and not $option{'s'}
    and not @ARGV;

$AMOS::CHKSUM::algorithm_set_up{'return_modbits'} = 1 if $option{'v'};

if ( not defined $data_str and not $option{'s'} ) {   ## COMMAND LINE INPUT ##
    $data_str = join( ' ', @ARGV );

} elsif ( not defined $data_str ) {    ## STDIN INPUT ## [ amos-chksum -s ]
    $data_str = join( '', <STDIN> );
}

##[ CHECKSUM CALCULATION ]####################################################

my $checksum_encoded = AMOS::CHKSUM::amos_chksum( \$data_str, @modes );

##[ VERBOSE RESULT VALUES ]###################################################

if ( $option{'v'} ) {
    my $offset_str
        = $AMOS::CHKSUM::bmw_mod_step
        ? " [ bmw-mod-step : ${AMOS::CHKSUM::bmw_mod_step} ]"
        : '';

    my @mod_bits = @AMOS::CHKSUM::mod_bits;
    my @mod_bits_str
        = @mod_bits
        ? (
        '',
        '  bmw-mod-bits  :  ' . shift @mod_bits,
        ( map { scalar( ' ' x 14 ) . '  :  ' . $ARG } @mod_bits ),
        '',
        sprintf( "    C-SUM-bits  : $bg$CT %032b $fg$rst",
            $AMOS::CHKSUM::num_amos_csum ),
        )
        : ();

    my $len_delta         = 11 - length($AMOS::CHKSUM::num_amos_csum);
    my $num_amos_csum_str = sprintf( ":$CT %d $fg%s",
        $AMOS::CHKSUM::num_amos_csum, ':' x $len_delta );

    my %COLOR = (
        'input' => is_true( $data_str, 1, 1, @modes ) ? $CT : $ng,
        'bits'  => is_true( $AMOS::CHKSUM::checksum_bits, 0, 1, @modes )
        ? $CT
        : $ng
    );

    my $header_string
        = ( $data_str =~ m|\n| )
        ? sprintf(
        "$bg${CT}::$rst\n\n%s\n$bg${CT}::$rst %s",
        join( '',
            map {"   $bg$COLOR{'input'}$ARG$rst\n"} split "\n", $data_str ),
        TRUE_FALSE($data_str)
        )
        : sprintf( "$fg  input-string  : %s",
        TRUE_FALSE($data_str) . " $bg$COLOR{'input'} $data_str $rst$fg " );

    map {say} (
        '',
        $header_string,
        '',
        "$fg   reverse-elf  :  ${AMOS::CHKSUM::elf_bits}",
        "$fg    bmw-R-bits  :  ${AMOS::CHKSUM::bmw_b_R}",
        "$fg    bmw-L-bits  :  ${AMOS::CHKSUM::bmw_b_L}",
        "$fg    bmw-C-bits  :  ${AMOS::CHKSUM::bmw_b_C}",
        '',
        "$fg     AMOS-bits  :  $bg$COLOR{'bits'}"
            . "${AMOS::CHKSUM::checksum_bits}$fg$rst$fg ",
        @mod_bits_str,
        '',
        sprintf(
            '%s   truth-modes  :  elf-mode %s',
            $fg, join( '', map {" $bg$CT $ARG $rst$fg "} sort @modes )
        ),
        '',
        join( ' ', "$fg   VAX-encoded  : " . TRUE_FALSE($checksum_encoded) )
            . " $bg$CT$bl$checksum_encoded$rst$fg $num_amos_csum_str",
        '', $rst
    );
} elsif ( $option{'n'} ) {

    say $AMOS::CHKSUM::num_amos_csum and exit if $option{'q'};
    say "$fg:\n:$bg $CT${AMOS::CHKSUM::num_amos_csum}$fg $rst\n$fg:$rst";

} else {
    say $checksum_encoded and exit if $option{'q'};
    say "$fg:\n:$bg $CT$checksum_encoded$fg $rst\n$fg:$rst";
}

##[ ERROR HANDLER ]###########################################################

sub error_exit {
    chomp( my $emsg = shift );

    my $bl  = "\e[38;2;68;39;172m";
    my $no  = "\e[38;2;197;141;7m";
    my $rst = "\e[0m";

    $emsg =~ s|^[A-Z](*nla:[A-Z])|\l$MATCH|;
    $emsg =~ s|(*plb:\w): (\S+)|$bl : $no$LAST_PAREN_MATCH|;

    say "$rst$bl:\n: $no$emsg$bl\n:$rst";

    exit(110);
}

##[ VISUALIZE TRUTH ASSERTION ]###############################################

sub TRUE_FALSE {
    my $C = shift;
    return '' if not length $C or $C =~ m|^\e|;
    is_true( $C, 1, 1, @modes )
        ? "${fg}:: ${CT}TRUE$fg ::$rst"
        : "${fg}:: ${ng}FALSE$fg ::$rst";
}

#.............................................................................
#U66ZH6FYJYP4EA5JASPDFVNPBZOBP6BCI3XXOAA4MCGBOFGL3GIODJBE3ODGFW2XBFACPPUCRALFI
#::: ALT2KOLKNMFRAMBDPXWHBRLBC53PZNJLXZYYMMQZUHREICDLOP2 :::: NAILARA AMOS :::
# :: GW5TYQC6D7AV4NDEN2BZKGC4LQEMKSMAFPPMT74FZRZB5KIS3ADI :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
