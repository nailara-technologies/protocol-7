#!/usr/bin/perl
use v5.24;
use strict;
use English;
use warnings;
use Getopt::Std;
use Crypt::Misc;    ## <-- encode_b32r ##
use Digest::Elf;
use Digest::BMW;

## algorithm configuration ##
my $check_truth = {
    'chksum_numerical' => 1,
    'chksum_bits'      => 1,
    'chksum_B32'       => 1
};

BEGIN {
    use English;
    use Cwd 'abs_path';
    my $script_path = abs_path($PROGRAM_NAME);
    ( my $local_lib_path = $script_path )
        =~ s|/[^/]+/[^/]+$|/data/lib-path/pm|;
    unshift( @INC, $local_lib_path ) if -d $local_lib_path;
}

use AMOS::Assert::Truth qw| is_true |;    ## <-- expand \ extract routines ..,

##[ RUNTIME OPTIONS ]#########################################################

## -q ## quiet output \ value only \
## -h ## follow harmony [ string | numeric ]
## -n ## return checksum as numerical value
## -v ## visualize additional checksum data

##[ PREPARING ]###############################################################

$SIG{'__WARN__'} = \&error_exit;
use warnings FATAL => 'all';

getopts( 'vhnq', \my %option );
warn "expected input string for AMOS-checksum calculation\n" if not @ARGV;

my $data_str = join( ' ', @ARGV );

##[ CHECKSUM CALCULATION ]####################################################

my $elf_bits = sprintf( '%032b',
    join( '', reverse split '', Digest::Elf::elf($data_str) ) );
my $bmw_512b = unpack( 'B512', Digest::BMW::bmw_512($data_str) );
my $bmw_512R = join( '', reverse split '', $bmw_512b );
my $bmw_b_L  = substr( $bmw_512b, 0, 32 );
my $bmw_b_R  = substr( $bmw_512R, 0, 32 );

my $bmw_mod_step = 0;
my $bmw_mod_bits = scalar( '0' x 32 ) . $bmw_512b . scalar( '0' x 32 );

( my $checksum_bits = $elf_bits ) =~ s|^0+|
                                        substr $bmw_b_L, 0, length($MATCH) |e;
$checksum_bits =~ s|0+$|
                    substr $bmw_b_R, 0, length($MATCH) |e;

## ######### ##   ##    ##     ##      ##
my $checksum = eval "0b$checksum_bits";    ## numerical ##
## ######### ##   ##    ##     ##      ##

my @mod_bits;

INVERT_TRUTH_STATE:

if ($bmw_mod_step) {    ## enforce required \ requested truth state ##
    my $cur_mod_bits = substr( $bmw_mod_bits, 0, 32 );
    if ( $cur_mod_bits eq '0' x 32 ) {    ## skip '0' prefixes ##8
        ++$bmw_mod_step and substr( $bmw_mod_bits, 0, 1, '' );
        goto INVERT_TRUTH_STATE;
    }
    $checksum ^= eval join( '', '0b', $cur_mod_bits );
    push( @mod_bits, $cur_mod_bits ) if $option{'v'};
}

#   ################ #        ###         #
my $checksum_encoded = Crypt::Misc::encode_b32r( pack( 'V', $checksum ) );
##  ################ ##       ###         #

if ( length($bmw_mod_bits) > 32 ) {

    if ( not $option{'h'} ) {    ## ENCODED + VALUE AND STRING HARMONY ##

        if ($check_truth->{'chksum_numerical'}
            and not is_true( $checksum, 1, 0 )

            or $check_truth->{'chksum_bits'}
            and not is_true( sprintf( "%032b", $checksum ), 0, 1 )

            or $check_truth->{'chksum_B32'} and not is_true($checksum_encoded)
        ) {

            ++$bmw_mod_step and substr( $bmw_mod_bits, 0, 1, '' );
            goto INVERT_TRUTH_STATE;
        }

    } else {    ## ENCODED + FOLLOW TRUTH ##

        my $input_true = is_true( $data_str, 1, 1 );

        if (    $check_truth->{'chksum_numerical'}
            and $input_true != is_true( $checksum, 1, 1 )

            or $check_truth->{'chksum_bits'}
            and $input_true != is_true( sprintf( "%032b", $checksum ), 0, 1 )

            or $check_truth->{'chksum_B32'}
            and $input_true != is_true( $checksum_encoded, 0, 1 )
        ) {

            ++$bmw_mod_step and substr( $bmw_mod_bits, 0, 1, '' );
            goto INVERT_TRUTH_STATE;
        }
    }
} else {
    warn "bit modification entropy depleted [ cannot enforce truth state ]\n";
}

##[ VERBOSE RESULT VALUES ]###################################################

my $rst = "\e[0m";
my $bl  = "\e[1m";
my $bg  = "\e[48;2;9;5;42m";
my $fg  = "\e[38;2;68;39;172m";
my $ng  = "\e[38;2;71;195;6m";
my $no  = "\e[38;2;197;141;7m";

if ( $option{'v'} ) {
    my $offset_str
        = $bmw_mod_step
        ? " [ bmw-mod-step : $bmw_mod_step ]"
        : '';

    my @mod_bits_str
        = @mod_bits
        ? (
        '',
        '  bmw-mod-bits  :  ' . shift @mod_bits,
        ( map { scalar( ' ' x 14 ) . '  :  ' . $ARG } @mod_bits ),
        '',
        sprintf( "    C-SUM-bits  : $bg $ng$bl%032b$fg $rst", $checksum ),
        )
        : ();

    map {say} (
        $fg,
        '  input-string  : '
            . true_false($data_str)
            . " $bg $ng$data_str $rst$fg ",
        $fg,
        '   reverse-elf  :  ' . $elf_bits,
        '    bmw-R-bits  :  ' . $bmw_b_R,
        '    bmw-L-bits  :  ' . $bmw_b_L,
        '',
        '     AMOS-bits  : ' . "$bg $ng" . $checksum_bits . "$fg $rst$fg",
        @mod_bits_str,
        '',
        join( ' ', "$fg   VAX-encoded  : " . true_false($checksum_encoded) )
            . " $bg$ng$checksum_encoded$fg $rst$fg"
            . sprintf( "[ %010d ]", $checksum ),
        '',
        $rst
    );
} elsif ( $option{'n'} ) {

    my $num_str = sprintf( "%010d", $checksum );
    say $num_str and exit if $option{'q'};
    say "$fg:\n:$bg $ng$num_str$fg $rst\n$fg:$rst";

} else {

    say $checksum_encoded and exit if $option{'q'};
    say "$fg:\n:$bg $ng$checksum_encoded$fg $rst\n$fg:$rst";
}

##[ ERROR HANDLER ]###########################################################

sub error_exit {
    my $rst = "\e[0m";
    my $fg  = "\e[38;2;68;39;172m";
    my $ec  = "\e[38;2;197;141;7m";
    chomp( my $e = shift );
    $e =~ s|^[A-Z](*nla:[A-Z])|\l$MATCH|;
    $e =~ s|(*plb:\w): (\S+)|$fg : $ec$LAST_PAREN_MATCH|;
    say "$fg:\n: $ec$e$fg\n:$rst";
    exit(110);
}

##[ TRUTH STATE ]#############################################################

sub true_false {
    my $C = shift;
    return '' if not length $C or $C =~ m|^\e|;
    is_true($C) ? ':: TRUE ::' : ':: FALSE ::';
}

#.............................................................................
#NMACOKGMLCCAEM3U75QY4KCHQUBKH5HN3SNKBMLZEK6BPBRKNAO37DYQTVMOEZT6IT33ZFPHW55MK
#::: C5RQYK5EM266K74GLZA2NZUY4T665DDJWAEAGMVTQW3AZ7HTNX4 :::: NAILARA AMOS :::
# :: QQC6RUGY7QSR7Z7HP2TEWY2QLNBTYGZ332DX3FYT7SD2EUPT2YCY :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
