#!/usr/bin/perl
use v5.24;
use strict;
use English;
use warnings;
use Getopt::Std;
use Math::BigFloat;
use Digest::Elf qw| elf |;
use Digest::BMW qw| bmw_512 |;
use Crypt::Misc qw| encode_b32r |;
Math::BigFloat->round_mode('trunc');

##[ RUNTIME OPTIONS ]#########################################################

## -q ## quiet output \ value only \
## -h ## follow harmony [ string | numeric ]
## -n ## return checksum as numerical value
## -v ## visualize additional checksum data

##############################################################################

$SIG{'__WARN__'} = \&error_exit;
use warnings FATAL => 'all';

getopts( 'vhnq', \my %option );
warn "expected input string for AMOS-checksum calculation\n" if not @ARGV;

my $string = join( ' ', @ARGV );

##[ CHECKSUM CALCULATION ]####################################################

my $elf_bits = sprintf( '%032b', join( '', reverse split '', elf($string) ) );
my $bmw_512b = unpack( 'B512', bmw_512($string) );
my $bmw_512R = join( '', reverse split '', $bmw_512b );

my $harmony_mode = { 'n' => 1, 's' => 1 };    ## numeric + string ##
my $bmw_offset   = 0;                         ## <-- not used yet ..,
my $bmw_R_offset = 0;                         ## <-- not used yet ..,
my $bmw_L_offset = 0;                         ## <-- in use ..,

INVERT_TRUTH:
my $bmw_b_L = substr( $bmw_512b, $bmw_L_offset, 32 );
my $bmw_b_R = substr( $bmw_512R, $bmw_R_offset, 32 );

( my $checksum_bits = $elf_bits ) =~ s|^0+|
                                        substr $bmw_b_L, 0, length($MATCH) |e;
$checksum_bits =~ s|0+$|
                    substr $bmw_b_R, 0, length($MATCH) |e;

my $checksum = eval "0b$checksum_bits";       ## numerical ##

my $checksum_encoded = encode_b32r( pack( 'V', $checksum ) );

if ( not $option{'h'} ) {    ## ENCODED + VALUE AND STRING HARMONY ##

    if (   $harmony_mode->{'n'} and not is_true($checksum)
        or $harmony_mode->{'s'} and not is_true($checksum_encoded) ) {
        ###############
        $bmw_L_offset++;
        ###############

        if ( $bmw_L_offset == 512 ) {
            if ( $option{'n'} and $harmony_mode->{'s'} ) {
                $harmony_mode->{'s'} = 0;
                $bmw_L_offset = 1;
            } elsif ( not $option{'n'} and $harmony_mode->{'n'} ) {
                $harmony_mode->{'n'} = 0;
                $bmw_L_offset = 1;
            } else {
                $harmony_mode = '';    ## <-- giving up .,
                $bmw_L_offset = 0;
            }
        }

        goto INVERT_TRUTH;
    }

} else {    ## ENCODED + FOLLOW TRUTH ##

    if (   $harmony_mode->{'n'} and is_true($string) != is_true($checksum)
        or $harmony_mode->{'s'}
        and is_true($string) != is_true($checksum_encoded) ) {
        ###############
        $bmw_L_offset++;
        ###############

        if ( $bmw_L_offset == 512 ) {
            if ( $option{'n'} and $harmony_mode->{'s'} ) {
                $harmony_mode->{'s'} = 0;
                $bmw_L_offset = 1;
            } elsif ( not $option{'n'} and $harmony_mode->{'n'} ) {
                $harmony_mode->{'n'} = 0;
                $bmw_L_offset = 1;
            } else {
                $harmony_mode = '';    ## <-- giving up .,
                $bmw_L_offset = 0;
            }
        }

        goto INVERT_TRUTH;
    }
}

##[ DISPLAY VALUE ]###########################################################

my $rst = "\e[0m";
my $bg  = "\e[48;2;9;5;42m";
my $fg  = "\e[38;2;68;39;172m";
my $ng  = "\e[38;2;71;195;6m";

if ( $option{'v'} ) {
    my $offset_str
        = $bmw_L_offset
        ? " [ mode "
        . join( ' + ',
        reverse sort grep { $harmony_mode->{$ARG} } keys %{$harmony_mode} )
        . " : offset $bmw_L_offset ]"
        : '';
    map {say} (
        $fg,
        ' input-string  :  ' . "$bg $ng$string $rst " . true_false($string),
        $fg,
        '  reverse-elf  :  ' . $elf_bits,
        '   bmw-R-bits  :  ' . $bmw_b_R,
        '   bmw-L-bits  :  ' . $bmw_b_L . $offset_str,
        '',
        '    AMOS-bits  : ' . "$bg $ng" . $checksum_bits . "$fg $rst$fg",
        '',
        '    numerical  :  '
            . sprintf( "%010d", $checksum ) . ' '
            . true_false($checksum),
        '',
        '  VAX-encoded  : '
            . "$bg $ng"
            . $checksum_encoded
            . "$fg $rst "
            . true_false($checksum_encoded),
        '',
        $rst
    );
} elsif ( $option{'n'} ) {

    my $num_str = sprintf( "%010d", $checksum );
    say $num_str and exit if $option{'q'};
    say "$fg:\n:$bg $ng$num_str$fg $rst\n$fg:$rst";

} else {

    say $checksum_encoded and exit if $option{'q'};
    say "$fg:\n:$bg $ng$checksum_encoded$fg $rst\n$fg:$rst";
}

##[ CUSTOM ERROR HANDLING ]###################################################

sub error_exit {
    my $rst = "\e[0m";
    my $ec  = "\e[38;2;197;141;7m";
    chomp( my $e = lcfirst(shift) );
    say ":\n: $ec$e$rst\n:";
    exit(110);
}

##[ HARMONIC TRUTH ]##########################################################

sub true_false {
    my $C = shift;
    return '' if not length $C or $C =~ m|^\e|;
    is_true($C) ? '< TRUE >' : '< FALSE >';
}

##############################################################################

sub is_true {

    my $input_string = shift // '';
    my $calc_str;
    my $accuracy = 13;

    state $cache //= {};
    return $cache->{$input_string} if exists $cache->{$input_string};

    if ( $input_string =~ m|^\d+$| ) {    ## check as mumber ##

        $calc_str = Math::BigFloat->new($input_string)
            ->bdiv( 13, 13 + length($input_string) );

    } else {                              ## check as string ##

        my $elf_checksum = elf($input_string);
        $calc_str = Math::BigFloat->new($elf_checksum)
            ->bdiv( 13, 13 + length($elf_checksum) );
    }

    ## FALSE ##
    return $cache->{$input_string} = 0
        if index( scalar $calc_str, '230769' ) >= 0;

    ## TRUE ## assertion complete : harmony detected ## [ not 230769 ]
    return $cache->{$input_string} = 1;
}

##############################################################################

#.............................................................................
#XTU6BVPLDNX6JW7WXMOW5PMMBR4ZXZQVO3EDMTCUSA5XW6J57GYWN53N4SWUQ4B5W3UNIAGNO2BTY
#::: QULM5K4FM7DM3FDFYZEOLUFNGNSMQXRNJ2IHFNBIKNUOOJ5M7PV :::: NAILARA AMOS :::
# :: NKEQEXYNUA6HSWH4LGQ4FEOJZEBSZWY6V4VDM2IU4PF2FQDXG6BY :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
