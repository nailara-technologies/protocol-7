#!/usr/bin/perl
use v5.24;
use strict;
use English;
use warnings;
use Term::ReadKey;
use List::MoreUtils qw| minmax uniq |;
use File::Which qw| which |;
use Time::HiRes qw| sleep |;

$OUTPUT_AUTOFLUSH = 1;

my @ptd_args = qw| -pbp -utf8 -l=78 -bar -sot -ce -nst -b -bext='/backup' |;

my $reset             = "\e[0m";
my $nailara_bg        = "\e[48;2;9;5;42m";
my $blacklight        = "\e[38;2;68;39;172m";
my $nailara_fg        = "\e[38;2;38;46;153m";
my $TRUE_color        = "\e[38;2;6;71;195m";
my $NEON_orange       = "\e[38;2;197;141;7m";
my $NEON_green_yellow = "\e[38;2;71;195;6m";

$SIG{'INT'} = \&sig_int;

my $ptd_bin = which qw| perltidy |;
die ":\n:: < ptd > : 'perltidy' executable not found in current path .,\n\n"
    if not length($ptd_bin)
    or not -x $ptd_bin;

## filter filenames for protocol-7 \ perl code ##
my @files = grep { is_perl_code($ARG) }
    uniq sort { length $a <=> length $b } reverse sort @ARGV;

die ":\n:: < ${NEON_green_yellow}ptd$reset > $reset:$NEON_orange "
    . "expected ${NEON_green_yellow}[${NEON_orange}perl"
    . "${NEON_green_yellow}]${NEON_orange} file name${NEON_green_yellow}"
    . "[${NEON_orange}s${NEON_green_yellow}]${NEON_orange}.,$reset\n:\n"
    if not @files;

map {
    die ":\n:: < ${NEON_green_yellow}ptd$reset > $reset:$NEON_orange "
        . "not found $reset : '$NEON_green_yellow$ARG$reset' $reset\n:\n"
        if not -f $ARG
} @files;

my $file_count = scalar @files;

( undef, my $file_maxlen ) = minmax map {length} @files;

say $blacklight. ':';

while ( my $file_path = shift @files ) {
    show_progress( $file_path, $file_count - scalar @files, $file_count );

    ReadMode 5;
    no warnings;
    my $return_code = eval { system( $ptd_bin, @ptd_args, $file_path ) };
    use warnings;
    ReadMode 0;

    sleep 0.13;

    if ( not defined $return_code or $return_code != 0 ) {
        my $err_msg = lcfirst( $OS_ERROR // $EVAL_ERROR );
        die "\n$blacklight:\n::[$NEON_orange $err_msg $blacklight] "
            . ".: $NEON_orange$file_path$blacklight ::\n:$reset\n";
    }
}

say "\n$blacklight:$reset";
exit(0);

sub sort_files {
    return () if not @ARG;
    return sort { length $a <=> length $b } reverse sort @ARG;
}

sub is_perl_code {
    my $file = shift;
    return 0 if not -f $file or -z $file;
    my $is_code = 0;
    open( my $fh, qw| < |, $file ) or die ":\n:: \l$OS_ERROR :: $file\n:\n";
    my $first_line = '';
    while (
        $first_line ne '## >:] ##'    ## <- protocol-7 source code header ##
        and $first_line =~ m{^\s*($|(use|my|our)\s.+;|#(*nla:!))}
    ) {
        chomp( $first_line = <$fh> );
    }

    $is_code = 1
        if $first_line eq '## >:] ##'
        or $first_line =~ m|^#!.*perl|
        or $first_line =~ m|^package .+;(\s*#.*)?$|;
    close($fh) or die ":\n:: \l$OS_ERROR :: $file\n:\n";
    return $is_code;
}

sub sig_int {
    print "\b\b::\b\b\r$blacklight\:::\n:\n:: [ ${NEON_orange}SIG"
        . "INT$blacklight ] $NEON_green_yellow perltidy run "
        . "aborted$blacklight ..,\n:$reset\n";
    exit('000113');
}

sub show_progress {
    my $filename    = shift;
    my $file_num    = shift;
    my $files_total = shift;
    my $chars_max   = 13;
    my $character   = ':';
    my $char_count  = int( $chars_max * $file_num / $files_total );
    my $perc_chars  = $character x $char_count;

    printf( "\r${blacklight}:::[$nailara_bg$TRUE_color%-${chars_max}s"
            . "$reset$blacklight]:"
            . "::[$nailara_bg$TRUE_color %-${file_maxlen}s"
            . " $reset$blacklight]:.$reset\r",
        $perc_chars, $filename );
}

#,,..,,,,,..,,...,,.,,..,,.,,,.,,,,,.,,.,,...,..,,...,...,.,.,..,,.,.,.,.,..,,
#VNGGTWYCHXF5WIWN7JZMX6JLP6WAGD65QGHGW2P623HMESY2LTA7J7TS7JZ4P7POZVKJWSEVYWDOA
#\\\|P75SA5UUECJVRD7F2NJWEMJEYN4U4R2RXBGQBBOF27M3UUKZE5D \ / AMOS7 \ YOURUM ::
#\[7]ONMR244UW3TJT4BCUWXSR4EM3GQVHKLH24RHBMOXTAKO7DY6QUCQ 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
