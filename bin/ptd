#!/usr/bin/perl
use v5.24;
use strict;
use English;
use warnings;
use Term::ReadKey;
use List::Util qw| max |;
use File::Which qw| which |;
use Time::HiRes qw| sleep |;

$OUTPUT_AUTOFLUSH = 1;

my @ptd_args = qw| -pbp -utf8 -l=78 -bar -sot -ce -nst -b -bext='/backup' |;

my $reset       = "\e[0m";
my $nailara_bg  = "\e[48;2;9;5;41m";
my $blacklight  = "\e[38;2;68;39;172m";
my $nailara_fg  = "\e[38;2;38;46;153m";
my $error_color = "\e[38;2;197;141;7m";
my $neon_green  = "\e[38;2;71;195;6m";

$SIG{'INT'} = \&sig_int;

my $ptd_bin = which qw| perltidy |;
die ":\n:: < ptd > : 'perltidy' executable not found in current path .,\n\n"
    if not length($ptd_bin)
    or not -x $ptd_bin;

## filter filenames for protocol-7 \ perl code ##
my @files = grep { is_perl_code($ARG) } @ARGV;

die ":\n:: < ${neon_green}ptd$reset > $reset:$error_color "
    . "expected ${neon_green}[${error_color}perl"
    . "${neon_green}]${error_color} file name${neon_green}"
    . "[${error_color}s${neon_green}]${error_color}.,$reset\n:\n"
    if not @files;

map {
    die ":\n:: < ${neon_green}ptd$reset > $reset:$error_color "
        . "not found $reset : '$neon_green$ARG$reset' $reset\n:\n"
        if not -f $ARG
} @files;

my $file_count = scalar @files;

my $file_maxlen = max map {length} @files;

say $blacklight. ':';

while ( my $file_path = shift @files ) {
    show_progress( $file_path, $file_count - scalar @files, $file_count );

    ReadMode 5;
    no warnings;
    my $return_code = eval { system( $ptd_bin, @ptd_args, $file_path ) };
    use warnings;
    ReadMode 0;

    sleep 0.13;

    if ( not defined $return_code or $return_code != 0 ) {
        my $err_msg = lcfirst( $OS_ERROR // $EVAL_ERROR );
        die "\n$blacklight:\n::[$error_color $err_msg $blacklight] "
            . ".: $error_color$file_path$blacklight ::\n:$reset\n";
    }
}

say "\n$blacklight:$reset";
exit(0);

sub sort_files {
    return () if not @ARG;
    return sort { length $a <=> length $b } reverse sort @ARG;
}

sub is_perl_code {
    my $file = shift;
    return 0 if not -f $file or -z $file;
    my $is_code = 0;
    open( my $fh, '<', $file ) or die ":\n:: \l$OS_ERROR :: $file\n:\n";
    my $first_line = '';
    while ( $first_line =~ m{^\s*($|(use|my|our) .+;|#(*nla:!))} ) {
        chomp( $first_line = <$fh> );
    }
    $is_code = 1
        if $first_line eq '# >:]'
        or $first_line =~ m|^#!.*perl|
        or $first_line =~ m|^package .+;$|;
    close($fh) or die ":\n:: \l$OS_ERROR :: $file\n:\n";
    return $is_code;
}

sub sig_int {
    print "\b\b::\b\b\r$blacklight\:::\n:\n:: [ ${error_color}SIG"
        . "INT$blacklight ] $neon_green perltidy run "
        . "aborted$blacklight ..,\n:$reset\n";
    exit(0110);
}

sub show_progress {
    my $filename    = shift;
    my $file_num    = shift;
    my $files_total = shift;
    my $chars_max   = 13;
    my $character   = ':';
    my $char_count  = int( $chars_max * $file_num / $files_total );
    my $perc_chars  = $character x $char_count;

    printf( "\r${blacklight}:::[$nailara_bg$neon_green%-${chars_max}s"
            . "$reset$blacklight]:"
            . "::[$nailara_bg$neon_green %-${file_maxlen}s"
            . " $reset$blacklight]:.$reset\r",
        $perc_chars, $filename );
}

#.............................................................................
#RZVJBSWYMJAODRO4Y7MVGVUIHESUUHBKQQV5CJLMF5ZAM57BCQL6WJVUB6P3FPXQCATUJ3TFWDM52
#::: IQUWIX76ZO6Z5CLXIJSXGJKRKSG3VBGUB64DURGR3GCBFGQCNRC :::: NAILARA AMOS :::
# :: JOVIPBTYURIBB6ELJAFKRE5HI2R5QLG7SBDK6RE36RPXYC6RSKBA :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
