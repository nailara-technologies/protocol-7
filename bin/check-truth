#!/usr/bin/perl
use v5.24;
use strict;
use English;
use warnings;

my @modes           = qw| 7 |;   ## <-- base setting truth [ elf ] mode : 7 ##
my $silent          = 0;
my $force_numerical = 0;
my $no_num_chk      = 0;

$silent = 1 if @ARGV > 1 and $ARGV[0] eq qw| -silent |       and shift(@ARGV);
$force_numerical = 1 if @ARGV > 1 and $ARGV[0] eq qw| -num | and shift(@ARGV);
$no_num_chk = 1 if @ARGV > 1 and $ARGV[0] eq qw| -nonum |    and shift(@ARGV);

if ( @ARGV > 1 and $ARGV[0] eq qw| -mode | ) {
    die ":\n: mode parameter not valid [ <n>[,<n>..,] ]\n:\n"
        if $ARGV[1] !~ m|^\d{1,2}(,\d{1,2})*$|;
    shift(@ARGV) and @modes = split( ',', shift(@ARGV) );
}

BEGIN {
    use File::Spec;
    use Cwd qw| abs_path |;
    use FindBin qw| $RealBin |;
    our $up_dir = File::Spec->updir;
    our $Bin    = $RealBin;
    my $root_path      = abs_path( r2_abs( c_dir( $Bin, $up_dir ) ) );
    my $local_lib_path = abs_path( c_dir( $root_path, 'data/lib-path/pm' ) );
    die "\n:\n:: not found : $local_lib_path\n:\n" if !-d $local_lib_path;
    unshift( @INC, $local_lib_path )               if -d $local_lib_path;
    sub c_dir  { File::Spec->catdir(@_) }
    sub r2_abs { File::Spec->rel2abs(@_) }
}

my $FXI = 202;    ## program return code for asserted FALSE ##

use AMOS::Assert qw| numerical numerical_no_prefix |;
use AMOS::Assert::Truth qw| is_true |;

my $stdin_mode = 0;
my $single_line_input;

if (@ARGV) {
    $single_line_input = join( ' ', @ARGV );
} else {
    $stdin_mode = 1;
}

my $rst = "\e[0m";
my $bl  = "\e[1m";
my $bg  = "\e[48;2;9;5;42m";
my $fT  = "\e[38;2;6;71;195m";
my $fg  = "\e[38;2;68;39;172m";
my $no  = "\e[38;2;197;141;7m";
my $ng  = "\e[38;2;71;195;6m";

##############################################################################

my $check_elf = $force_numerical ? 0 : 1;
my $numerical = $no_num_chk ? 0 : $check_elf ? 2 : 1;

## COMMAND LINE INPUT ##
exit( process_input($single_line_input) ) if not $stdin_mode;

## STDIN \ PIPE MODE ##
my $success_code = 0;

while (<STDIN>) {
    $success_code = $FXI if not process_input($ARG);
}

exit($success_code);

##############################################################################

sub process_input {
    my ( $true, @r_modes )
        = is_true( $ARG[0], $numerical, $check_elf, @modes );
    my $mode_str = @r_modes ? sprintf( " : %s", join( ' ', @r_modes ) ) : '';

    if ($true) {
        say "$fg:\n:: $bl${fT}TRUE$rst$fg$mode_str :: "
            . "$bg'$fT$ARG[0]$fg'$rst$fg .:\n:$rst"
            if not $silent;
        return 0;
    } else {
        say "$fg:\n:: $bl${ng}FALSE$rst$fg$mode_str : "
            . "$bg'$ng$ARG[0]$fg'$rst$fg :.\n:$rst"
            if not $silent;
        return $FXI;
    }
}

#.............................................................................
#QWF3ZBZIY2GGKELSAND6ZIP5BK4A2ITYCHKZWYWD5UXDTWF7KTCNDZJ6SGDPVL2YEL52ZNRRHYJTC
#::: 66QII7XJPZZPG3DRZHBHDVY46Q3SHA7M63WQA5NJKRBJILHNUPG :::: NAILARA AMOS :::
# :: YWYKIPFXARWAWPBGN6DNYBKC5YUVQ3635QSIJT5XTOL2DC3OV2DA :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
