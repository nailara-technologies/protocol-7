#!/usr/bin/env -S perl -C31
use utf8;
use strict;
use v5.10.0;
use IO::AIO;
use English;
use warnings;
use File::Spec;
use IO::Socket;
use IO::Socket::IP;
use IO::Socket::UNIX;
use Cwd qw| abs_path |;
use Term::ReadPassword;
use SigAction::SetCallBack;
use Time::HiRes qw| sleep |;
use POSIX qw| sys_wait_h WNOHANG |;

##[ global constants ]##
use constant TRUE    => 5;    ##  TRUE.  ##
use constant FALSE   => 0;    ##  false  ##
use constant UNKNOWN => 2;    ##  unknown  ##

##[ LOCAL PM LIB PATH ]#######################################################

BEGIN {
    use English;
    use File::Spec;
    use Cwd qw| abs_path |;
    use FindBin qw| $RealBin |;
    my $data_pm_path   = qw| data/lib-path/pm |;
    my $root_path      = abs_path( r2_abs( c_dir( $RealBin, up_dir() ) ) );
    my $local_lib_path = abs_path( c_dir( $root_path, $data_pm_path ) );
    $local_lib_path //= $data_pm_path;
    die "\n:\n:: not found : $local_lib_path\n:\n" if !-d $local_lib_path;
    unshift( @INC, $local_lib_path )               if -d $local_lib_path;
    sub c_dir  { File::Spec->catdir(@ARG) }
    sub r2_abs { File::Spec->rel2abs(@ARG) }
    sub up_dir { return File::Spec->updir }
}

my $root_path = abs_path( r2_abs( c_dir( $RealBin, up_dir() ) ) );

##[ AMOS MODULE ]#############################################################

use AMOS7;    ##  error handler and colors  ##

use AMOS7::Protocol::P7 qw| calc_port calc_unix_path |;

###                                                                      ###
#   calculated port : /usr/local/protocol-7 : ext = 13, internal = 42      #
#                 /data/projects/protocol-7 : ext = 44, internal = 171     #
###                                                                      ###

##[ PROGRAM INIT ]############################################################

my $lnk_path = File::Spec->rel2abs( File::Spec->canonpath($PROGRAM_NAME) );
my $bin_path = $lnk_path;

while ( my $readlink_path = readlink($bin_path) // $bin_path ne $bin_path ) {
    $bin_path = $readlink_path;
    last if $bin_path =~ m|/nshell$|;  # skip resolving last stage., [improve]
}

my $protocol_7_port = calc_port(qw|internal|);  # calc based on install path #

( my $hostname = qx| /bin/hostname | ) =~ s,(\..+|\n)$,,g;

$SIG{'PIPE'} = qw| IGNORE |;

$PROGRAM_NAME = qw| nshell |;

# see override_signals ##
map { $SIG{$ARG} = \&parent_exit } qw| INT TERM HUP |;

my $stdout_pid;
my $parent_pid = $PID;

$SIG{'CHLD'} = sub {
    $PROGRAM_NAME .= "[disconnected]"
        if waitpid( -1, WNOHANG() ) == $stdout_pid;
};

my $cube_user;
my $cube_pass;
my $stored_cmd;
my $lines_up  = 3;
my $term_loop = FALSE;
my $remember  = FALSE;
my $arg_index = FALSE;

my $user_unix = $ENV{'PROTOCOL_7_UNIX_PATH'};  ##  unix domain socket path  ##

my $link_type = qw| ip.tcp |;

my @args = @ARGV;

if (@args) {

    if ( @args and $args[0] =~ m,^\-u(ser)?$, and shift @args ) {
        die ":\n:: expected name after -u[ser]\n:\n" if not @args;
        $cube_user = shift @args;
        $link_type = qw| unix |;
    }

    if ( @args and $args[0] =~ m,^\-(U|unix)?$, and shift @args ) {
        die ":\n:: expected socket name after -unix\n:\n" if not @args;
        $user_unix = shift @args;
        $link_type = qw| unix |;
    }

    if ( @args and $args[0] =~ m,^\-r(emember)?$, and shift @args ) {
        $remember = TRUE;
    }

}

my $cube_addr = shift(@args) || qw| 127.0.0.1 |;
my $cube_port = shift(@args) || $protocol_7_port;
my $sckargcnt = scalar @args;
my $usock_dir = qw| /var/run/.7/UNIX |;

my $prompt = sprintf '\ %s \:[?]:, ', $hostname;

my $connect = TRUE;
my $WARNED  = FALSE;

$OUTPUT_AUTOFLUSH = TRUE;

# clear();

my $term = new Term::ReadLine('protocol-7.shell');
$term->ornaments('mh,me,md,me');
$term->enableUTF8();
$term->MinLine(undef);

no warnings 'once';
$readline::rl_completion_function = "main::rl_filename_list_lcl";
use warnings 'once';

my $shell_sock;
while ($connect) {
    $shell_sock = shell_connect( $cube_addr, $cube_port );
    if ( $link_type eq qw| unix | and $lnk_path =~ m|\.([^/\.]+)$| ) {
        my $cube_user = $LAST_PAREN_MATCH;
        $shell_sock = unix_auth( $shell_sock, $cube_user );
    } elsif ( $link_type eq qw| unix | and defined $cube_user ) {
        $shell_sock = unix_auth( $shell_sock, $cube_user );
    } else {
        $shell_sock = shell_auth( $shell_sock, login_prompt() );
    }
    if ( -S $shell_sock ) {
        $PROGRAM_NAME = "nshell [ $cube_addr : $cube_port ]";
        if ( not defined $stored_cmd ) {
            clear();
            print "\e[1m\e[5m$C{0}\e-$C{R}\n";
        } else {
            if ( !s_write( $shell_sock, "$stored_cmd\n" ) ) {
                sleep(0.13);
                close($shell_sock);

                exit(2);    # aborting connection, failed to send.
            } else {
                printf "\033[${lines_up}A\r\e[5m$C{0}.$C{R}"
                    . "  $C{0}< \e[32m%-79s\n\n",
                    "reconnected $C{0}>$C{R}";
                my $l_cmd = length($stored_cmd);
                $l_cmd = 33 if $l_cmd < 33;
                printf "\r\e[2m$prompt\e[1m\e[32m%-"
                    . $l_cmd
                    . "s\e[37m\n\033[1A\n$C{R}",
                    $stored_cmd;
            }
        }
        $lines_up = 3;
        shell_loop( $shell_sock, $prompt );
    }
}

sub login_prompt {
    if (    $remember
        and defined $cube_user
        and defined $cube_pass ) {
        return ( $cube_user, $cube_pass );
    }
    my ( $user, $pass );
    print "\n :: user :. ";
    chop( $user = <STDIN> );
    $pass = read_password(" :: pass :. ");
    print "\n";
    ( $cube_user, $cube_pass ) = ( $user, $pass ) if $remember;
    return ( $user, $pass );
}

sub shell_connect {
    my $sock;
    if ( not $sckargcnt ) {

        my $sock_path;

        if ( defined $user_unix ) {    ##[  specified or ENV  ]##

            if ( index( $user_unix, qw| / | ) == -1 ) {
                $sock_path = sprintf qw| %s/%s |, $usock_dir, $user_unix;
            } else {
                $sock_path = $user_unix;
            }

        } else {                       ##[ auto-calc ]##

            $sock_path = sprintf qw| %s/%s |, $usock_dir,
                calc_unix_path( $cube_addr, $cube_port );
        }

        if ( -e $sock_path ) {
            $sock = IO::Socket::UNIX->new(
                Type => SOCK_STREAM(),
                Peer => $sock_path,
                )
                or
                warn_err( ' << connection error : unix:%s [ %s ] >> <{NC}>',
                -1, $sock_path, scalar format_error( $OS_ERROR, -1 ) );
        }
    }
    if ( not defined $sock ) {
        $sock = new IO::Socket::IP(
            PeerAddr => $cube_addr,
            PeerPort => $cube_port,
            Proto    => qw| tcp |
            )
            or error_exit( '<< connection error : %s:%d [ %s ] >> <{NC}>',
            $cube_addr, $cube_port, scalar format_error( $OS_ERROR, -1 ) );
    } else {
        $link_type = qw| unix |;
    }

    my $banner_message = readline($sock);

    error_exit('<< connection to peer has been lost >> <{NC}>')
        if not defined $banner_message;
    chomp($banner_message);
    error_exit( '<< protocol mismatch [ $banner_message ] >> <{NC}>',
        $banner_message )
        if $banner_message ne '>:] ::-.7\\\\';

    binmode( $sock, ':encoding(UTF-8)' );

    return $sock;
}

sub shell_auth {
    my ( $fh, $user, $pwd ) = @ARG;

    s_write( $fh, "select pwd\n" );
    my $answer = <$fh>;
    error_exit('<< connection was prematurely terminated >> <{NC}>')
        if not defined $answer;
    if ( $answer !~ m|^TRUE continue| ) {
        error_exit(":: 'pwd' auth method not available :: <{NC}>");
    }

    s_write( $fh, sprintf( "auth %s %s\n", $user, $pwd ) );
    $answer = <$fh>;
    error_exit('<< connection was terminated prematurely >> <{NC}>')
        if not defined $answer;
    if ( $answer =~ m|^AUTH_TRUE| ) {
        print " :: authentication successful ::\n";
        return $fh;
    } elsif ( $answer =~ m,^AUTH_ERROR, ) {
        error_exit(':: authentication not successful :: <{NC}>');
    } elsif ( $answer =~ m,>:|, ) {
        print " :: authentication timeout ::\n";
        return FALSE;
    } else {
        error_exit(':: protocol mismatch >:[ <{NC}>');
    }
}

sub unix_auth {
    my ( $fh, $user ) = @ARG;
    s_write( $fh, "select unix\n" );
    my $answer = <$fh>;
    error_exit('<< connection was prematurely terminated >> <{NC}>')
        if not defined $answer;
    if ( $answer !~ m|^TRUE continue| ) {
        error_exit(':: unix auth not available :: <{NC}>');
    }
    s_write( $fh, sprintf( "auth %s\n", $user ) );
    $answer = <$fh>;
    print "\n";
    if ( $answer =~ m|^AUTH_TRUE| ) {
        print " :: authentication successful ::\n";
        return $fh;
    } elsif ( $answer =~ m,^AUTH_ERROR, ) {
        error_exit(':: authentication not successful :: <{NC}>');
    } elsif ( $answer =~ m,^>:|, ) {
        print " :: authentication timeout ::\n";
        return FALSE;
    } else {
        error_exit(':: protocol mismatch >:[ <{NC}>');
    }
}

sub s_write {
    my $b_written;
    my $write_fh  = shift;
    my $write_str = shift;
    utf8::encode($write_str);
    IO::AIO::aio_write( $write_fh, undef, length($write_str),
        $write_str, 0, sub { $b_written = $ARG[0] } );
    IO::AIO::flush();
    undef $b_written if $b_written < 0; # <-- emulates syswrite() behaviour .,
    return $b_written;
}

sub clear { print "\e[37m\e[H\e[2J" }

sub shell_loop {
    my $sock   = $ARG[0];
    my $prompt = $ARG[1];

    if ( not $stdout_pid = fork() ) {
        $SIG{'TERM'} = $SIG{'INT'} = $SIG{'HUP'} = qw| IGNORE |;
        $SIG{'PIPE'} = sub { kill( 9, $parent_pid ); exit(2) };
        stdout_fork();
        exit;
    }
    if ( defined $stored_cmd ) {
        sleep(0.2);
        undef $stored_cmd;
    }

    map {
        $SIG{$ARG} = sub { parent_exit( shift, $stdout_pid ) }
    } qw| TERM INT HUP |;

    $term->add_history('');

    $connect = FALSE;
    my $last_line = '';
    while ( -S $sock
        and override_signals()
        and defined( my $line = $term->readline($prompt) ) ) {
        $WARNED  = FALSE;
        $connect = TRUE;
        print $C{'T'};    ##  reset to 'true' color  ##
        if ( $line ne '' ) {

            $term->add_history($line) if $line ne $last_line;
            $last_line = $line;

            if ( $line =~ m|^\. cd (.+)| ) {
                my $cd_path = $LAST_PAREN_MATCH;
                if ( not chdir($cd_path) ) {
                    warn_err( 'cd [ %s ] %s <{NC}>',
                        -1, $cd_path, scalar format_error( $OS_ERROR, -1 ) );
                }
            } elsif ( $line =~ m|^\. (.+)$| ) {
                $lines_up = 1;
                no warnings;
                if ( my $err = system($LAST_PAREN_MATCH) ) {
                    my $error   = '';
                    my $err_msg = "exit code : $err";
                    if ( $err == -1 ) {
                        $err_msg = format_error( $OS_ERROR, -1 );
                        $error   = ' << error >>';
                    }
                    warn_err( '- ! -%s [ %s ] <{NC}>', -1, $error, $err_msg );
                }
                use warnings;
            } else {
                if ( $line eq qw| [reset] | ) {
                    system(qw| reset |);
                    $line = '';
                    say '';
                }
                if (    length($line)
                    and $line ne '[quit]'
                    and !s_write( $sock, sprintf( "%s\n", $line ) ) ) {
                    sleep(0.1);
                    $stored_cmd = $line;
                }
                sleep(0.2);
                if (   $line eq '[quit]'
                    or defined $stored_cmd and $stored_cmd eq 'exit'
                    or $line =~ "TRUE session closed\n" ) {
                    print {$sock} "exit user quit shell session\n"
                        if $line eq '[quit]';
                    close($sock);
                    exit;
                } elsif ( defined $stored_cmd
                    or !-S $sock
                    or !$sock->connected ) {
                    my $r_msg = ' :: reconnecting..,';
                    if ( not defined $stored_cmd ) {
                        print "\e[2H\e[2J$r_msg\n";
                    } else {
                        my $l_cmd = length($stored_cmd);
                        printf "\033[1A\r%-" . $l_cmd . "s\n\033[2A\r",
                            $r_msg;
                    }
                    last;
                }

            }
        } elsif ( !-S $sock or !s_write( $sock, "\n" ) or !$sock->connected )
        {
            print "\e[2H\e[2J :: reconnecting..,\n";
            last;
        }
    }
    if ( not $connect ) {
        if ( -S $shell_sock ) {
            s_write( $shell_sock, "\nexit ==\\ lost terminal \\==\n" );
            close($shell_sock);
        }
        kill( 9, $parent_pid );
        exit(qw| 0110 |);
    }
}

sub stdout_fork {
    close(STDIN);
    $PROGRAM_NAME = "nshell [ stdout ]";
    while ( my $out = <$shell_sock> ) {
        $out =~ s|\n$||;
        print "$out\n";
    }
    close($shell_sock);
    print "$C{0}.\n      \e[5m.      .     .     "
        . "$C{R}$C{0}.:$C{T}\[$C{b}$C{T} connection"
        . " terminated $C{R}$C{T}\]$C{0}:.\e[5m  "
        . "   .     .      .$C{R}\n$C{0}.$C{R}\n";
}

sub rl_filename_list_lcl
{    #<- currently not working since Term::ReadLine switch
    my ( $text, $line, $pos ) = @ARG;

    if ( !$pos or $line !~ m|^\. | ) {
        no warnings 'once';
        $readline::rl_completer_terminator_character = '';
        use warnings 'once';
        if ( !$WARNED and $line !~ m|^\. | ) {
            print "\n<< prefix '. ' can be used for local shell commands"
                . ", check 'commands' for network >>\n";
            $WARNED = TRUE;
        }
        return '';
    }

    my @files = (<$text*>);
    foreach (@files) {
        if ( -d $ARG ) {
            next if $pos == 0 and !-x $ARG;
            $ARG .= qw| / |;
        }
    }
    no warnings 'once';
    $readline::rl_completer_terminator_character = '';
    use warnings 'once';
    return @files;
}

sub terminal_size {

    my $handle = shift // *STDIN;    ## use *STDOUT for pipe detection ##

    return undef if not -t $handle;
    state $size       = "\0" x 8;
    state $TIOCGWINSZ = 21523;

    ioctl( $handle, $TIOCGWINSZ, $size ) or return undef;
    my $size_aref = [ unpack qw| S!S!S!S! |, $size ];

    return ( $size_aref->[1], $size_aref->[0] );
}

sub override_signals {
    map { SigAction::SetCallBack->sig_registry( $ARG, \&readline_signals ) }
        qw| INT TERM HUP |;

    return $term_loop = TRUE;
}

sub restore_signals {
    map { $SIG{$ARG} = \&parent_exit } qw| INT TERM HUP |;
}

sub readline_signals {
    my $sig_name = shift;

    my $line_width = [ terminal_size() ]->[1];
    my $line_space = ' ' x abs( $line_width - length $prompt );
    print sprintf "\r%s%s%s%s%s%s\r", $C{b}, $C{0}, $prompt, $C{R},
        $line_space, $C{'R'};

    $term->free_line_state;
    $term->cleanup_after_signal;
    parent_exit();
}

sub parent_exit {    #   [ globals : $term_loop, $shell_sock, $stdout_pid ]
    print $term_loop
        ? "\n$C{0}\e[5m.\n.\n.\n$C{R}\n"
        : "\n ::\n :\n\n";
    if ( -S $shell_sock ) {
        $shell_sock->shutdown(2);
        $shell_sock->close();
        sleep(0.13);
    }
    kill( 9, $stdout_pid ) if defined $stdout_pid;
    exit;
}

#,,..,..,,.,.,,.,,,..,...,,,,,.,,,,..,.,.,.,.,..,,...,...,...,...,..,,..,,...,
#HAMNHOXOYJM65MXR2GVL5D5XAJ33KVJWEPM4TZDFCP2E4SAKIXWSPIHHDEZU5FUVCRZNBDBGVQOIU
#\\\|N4U32MC2H2SINEYJ72FP6S4NQLYFP6BH5DIVLBCPRZ3JPXXHCID \ / AMOS7 \ YOURUM ::
#\[7]HUH6E62EIVTXSOA6FBM4RQWF5I5MGCO5JJDSWB7BAZGLLWQFGOBQ 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
