#!/usr/bin/perl

$0 = 'nshell ';

use utf8;
use strict;
use warnings;
use IO::Socket;
use IO::Socket::INET;
use Term::ReadLine;
use Term::ReadPassword;
use POSIX ":sys_wait_h";

binmode STDOUT, ":utf8";

$SIG{'CHLD'} = sub {
    waitpid( -1, WNOHANG );
    $0 .= "[disconnected] ";
};

my @args;
my $remember  = 0;
my $arg_index = 0;
foreach my $param (@ARGV) {
    if ( $param =~ /^(-r|--remember)$/ ) {
        $remember = 1;
    } else {
        push( @args, $param );
    }
}

my $core_user;
my $core_pass;
my $core_addr = shift(@args) || '127.0.0.1';
my $core_port = shift(@args) || 242;

my $color  = "\e[37m\e[40m";
my $prompt = $color . ':. ';

my $connect = 1;

$| = 0;

# clear();

my $shell_sock;
while ($connect) {

    $shell_sock
        = shell_auth( shell_connect( $core_addr, $core_port ), login_prompt() );

    if ( -S $shell_sock ) {
        clear();
        $0 = "nshell ( $core_addr : $core_port ) ";
        shell_loop( $shell_sock, $prompt );
    }
}

sub login_prompt {
    if (    $remember
        and defined $core_user
        and defined $core_pass ) {
        return ( $core_user, $core_pass );
    }
    my ( $user, $pass );
    print "\n :: user :. ";
    chop( $user = <STDIN> );
    $pass = read_password(" :: pass :. ");
    print "\n";
    ( $core_user, $core_pass ) = ( $user, $pass ) if $remember;
    return ( $user, $pass );
}

sub shell_connect {
    my $sock = new IO::Socket::INET(
        PeerAddr => "$_[0]",
        PeerPort => "$_[1]",
        Proto    => 'tcp'
    ) or die "\n [!] failed to connect to $_[0]:$_[1] [$!]\n\n";
    die " [!] connection failed [protocol error]\n" if <$sock> !~ />:\]/;
    return $sock;
}

sub shell_auth {
    syswrite( $_[0], "auth $_[1] $_[2]\n" );
    sysread( $_[0], my $answer, 8 );
    if ( $answer =~ /YEAH/ ) {
        print " :: authentication successful ::\n";
        return $_[0];
    } elsif ( $answer =~ /FAIL >:\|/ ) {
        die " :: authentication failed ::\n\n";
    } elsif ( $answer =~ />:\|/ ) {
        print " :: authentication timeout ::\n";
        return 0;
    } else {
        die " :: protocol error ::\n\n";
    }
}

sub clear { print "\e[37m\e[40m\e[H\e[2J" }

sub shell_loop {
    my $sock   = $_[0];
    my $prompt = $_[1];

    if ( !fork() ) { stdout_fork(); exit }

    my $term = new Term::ReadLine 'nailara.shell';

    while ( defined( my $line = $term->readline($prompt) ) and -S $sock ) {
        print $color;

        if ( $line ne '' ) {
            if ( $line =~ /^\.cd ([^\s]+)/ ) {
                if ( !chdir($1) ) { print "cd: " . $! . "\n" }
            } elsif ( $line !~ /^\.\./ and $line =~ /^\.(.+)$/ ) {
                if ( my $err = system($1) ) {
                    print "error code: " . $err . "\n";
                }
            } else {

                if ( !syswrite( $sock, "$line\n" ) ) {
                    select( undef, undef, undef, 0.1 );
                    exit;
                }
                select( undef, undef, undef, 0.2 );
                if ( $line eq '[quit]' or $line =~ "ACK session closed\n" ) {
                    exit;
                } elsif ( !-S $sock or !$sock->connected ) {
                    print "\e[2H\e[2J :: reconnecting...\n";
                    last;
                }

            }
        } elsif ( !-S $sock or !syswrite( $sock, "\n" ) or !$sock->connected ) {
            print "\e[2H\e[2J :: reconnecting...\n";
            last;
        }
    }
}

sub stdout_fork {
    close(STDIN);
    $0 = "nshell ( stdout ) ";
    while ( my $out = <$shell_sock> ) {
        $out =~ s/\n$//;
        print "$out\n";
    }
    print ":\n:..[ connection terminated ]\n\n";
}
