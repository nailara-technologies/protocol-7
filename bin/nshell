#!/usr/bin/perl

BEGIN { $ENV{'PERL_RL'} = 'Perl' }

use utf8;
use strict;
use warnings;
use File::Spec;
use IO::Socket;
use IO::Socket::INET;
use IO::Socket::UNIX;
use Term::ReadPassword;
use Term::ReadLine::Perl;
use POSIX ":sys_wait_h";
use Digest::MD5 qw(md5);
use MIME::Base64 qw(encode_base64url);

my $bin_path = File::Spec->rel2abs($0);

$0 = 'nshell ';

$SIG{'PIPE'} = 'IGNORE';
binmode STDOUT, ":utf8";

my $stdout_pid;
$SIG{'CHLD'} = sub {
    $0 .= "[disconnected] " if waitpid( -1, WNOHANG ) == $stdout_pid;
};

my @args;
my $remember  = 0;
my $arg_index = 0;
foreach my $param (@ARGV) {
    if ( $param =~ /^(-r|--remember)$/ ) {
        $remember = 1;
    } else {
        push( @args, $param );
    }
}

my $core_user;
my $core_pass;
my $link_type = 'tcp/ip';
my $sckargcnt = scalar @args;
my $core_addr = shift(@args) || '127.0.0.1';
my $core_port = shift(@args) || 242;
my $usock_dir = '/tmp/.n/sock';

my $color  = "\e[37m\e[40m";
my $prompt = $color . ':. ';

my $connect = 1;
my $WARNED  = 0;

$| = 0;

# clear();

my $term = new Term::ReadLine 'nailara.shell';

no warnings 'once';
$readline::rl_completion_function = "main::rl_filename_list_lcl";
use warnings 'once';

my $shell_sock;
while ($connect) {

    $shell_sock = shell_connect( $core_addr, $core_port );
    if ( $link_type eq 'unix' and $bin_path =~ /\.([^\/\.]+)$/ ) {
        my $core_user = $1;
        $shell_sock = unix_auth( $shell_sock, $core_user );
    } else {
        $shell_sock = shell_auth( $shell_sock, login_prompt() );
    }
    if ( -S $shell_sock ) {
        clear();
        print "\e[1m\e[5m\e[36m\e[40m`\e[0m\n";
        $0 = "nshell ( $core_addr : $core_port ) ";
        shell_loop( $shell_sock, $prompt );
    }
}

sub login_prompt {
    if (    $remember
        and defined $core_user
        and defined $core_pass ) {
        return ( $core_user, $core_pass );
    }
    my ( $user, $pass );
    print "\n :: user :. ";
    chop( $user = <STDIN> );
    $pass = read_password(" :: pass :. ");
    print "\n";
    ( $core_user, $core_pass ) = ( $user, $pass ) if $remember;
    return ( $user, $pass );
}

sub shell_connect {
    my $sock;
    if ( !$sckargcnt ) {
        my $sock_path
            = "$usock_dir/" . encode_base64url( md5("$core_addr:$core_port") );
        if ( -e $sock_path ) {
            $sock = IO::Socket::UNIX->new(
                Type => SOCK_STREAM(),
                Peer => $sock_path,
            ) or warn "\n [!] failed to connect to unix:$sock_path [$!]\n";
        }
    }
    if ( not defined $sock ) {
        $sock = new IO::Socket::INET(
            PeerAddr => $core_addr,
            PeerPort => $core_port,
            Proto    => 'tcp'
            )
            or die "\n [!] failed to connect to $core_addr:$core_port [$!]\n\n";
    } else {
        $link_type = 'unix';
    }
    die " [!] connection failed [protocol error]\n" if <$sock> !~ />:\]/;
    return $sock;
}

sub shell_auth {
    my ( $fh, $usr, $pwd ) = @_;
    syswrite( $fh, "auth $usr $pwd\n" );
    my $answer = <$fh>;
    if ( $answer =~ /YEAH/ ) {
        print " :: authentication successful ::\n";
        return $fh;
    } elsif ( $answer =~ /FAIL >:\|/ ) {
        die " :: authentication failed ::\n\n";
    } elsif ( $answer =~ />:\|/ ) {
        print " :: authentication timeout ::\n";
        return 0;
    } else {
        die " :: protocol error ::\n\n";
    }
}

sub unix_auth {
    my ( $fh, $usr ) = @_;
    syswrite( $fh, "select unix\n" );
    my $answer = <$fh>;
    if ( $answer !~ /^ACK continue/ ) {
        die " :: unix auth not available ::\n\n";
    }
    syswrite( $fh, "auth $usr\n" );
    $answer = <$fh>;
    print "\n";
    if ( $answer =~ /YEAH/ ) {
        print " :: authentication successful ::\n";
        return $fh;
    } elsif ( $answer =~ /FAIL >:\|/ ) {
        die " :: authentication failed ::\n\n";
    } elsif ( $answer =~ />:\|/ ) {
        print " :: authentication timeout ::\n";
        return 0;
    } else {
        die " :: protocol error ::\n\n";
    }
}

sub clear { print "\e[37m\e[40m\e[H\e[2J" }

sub shell_loop {
    my $sock   = $_[0];
    my $prompt = $_[1];

    if ( not $stdout_pid = fork() ) { stdout_fork(); exit }

    while ( defined( my $line = $term->readline($prompt) ) and -S $sock ) {
        $WARNED = 0;
        print $color;

        if ( $line ne '' ) {
            if ( $line =~ /^\.cd ([^\s]+)/ ) {
                if ( !chdir($1) ) { print "cd: " . $! . "\n" }
            } elsif ( $line !~ /^\.\./ and $line =~ /^\.(.+)$/ ) {
                if ( my $err = system($1) ) {
                    print "error code: " . $err . "\n";
                }
            } else {

                if ( !syswrite( $sock, "$line\n" ) ) {
                    select( undef, undef, undef, 0.1 );
                    exit;
                }
                select( undef, undef, undef, 0.2 );
                if ( $line eq '[quit]' or $line =~ "ACK session closed\n" ) {
                    exit;
                } elsif ( !-S $sock or !$sock->connected ) {
                    print "\e[2H\e[2J :: reconnecting...\n";
                    last;
                }

            }
        } elsif ( !-S $sock or !syswrite( $sock, "\n" ) or !$sock->connected ) {
            print "\e[2H\e[2J :: reconnecting...\n";
            last;
        }
    }
}

sub stdout_fork {
    close(STDIN);
    $0 = "nshell ( stdout ) ";
    while ( my $out = <$shell_sock> ) {
        $out =~ s/\n$//;
        print "$out\n";
    }
    print ".\n  .      .   .   .    .:\e[31m [\e[\e[0m connection"
        . " terminated\e[0m \e[31m]\e[0m :.    .   .   .\n\n";
}

sub rl_filename_list_lcl {
    my ( $text, $line, $pos ) = @_;

    if ( !$pos or $line !~ /^\./ ) {
        no warnings 'once';
        $readline::rl_completer_terminator_character = '';
        use warnings 'once';
        if ( !$WARNED and $line !~ /^\./ ) {
            print "\n[!] local shell commands need '.' prefix!\n";
            $WARNED = 1;
        }
        return '';
    }

    my @files = (<$text*>);
    foreach (@files) {
        if ( -d $_ ) {
            next if $pos == 0 and !-x $_;
            $_ .= '/';
        }
    }
    no warnings 'once';
    $readline::rl_completer_terminator_character = '';
    use warnings 'once';
    return @files;
}
