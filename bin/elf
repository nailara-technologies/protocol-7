#!/usr/bin/perl
use v5.24;
use strict;
use English;
use warnings;
use IPC::Open2;
use Digest::Elf;
use Getopt::Std;

getopts( 'f:q', \my %mode );

if ( defined $mode{'f'} and ( -f $mode{'f'} or $mode{'f'} eq '-' ) ) {
    my $fname = $mode{'f'};
    if ( $fname eq '-' ) {    ## STDIN-mode ##
        while (<STDIN>) { say encode_output( elf_val($ARG) ) }
    } else {
        open( my $FH, '<' . $fname ) or die ":\n:: \l$! :: $fname \n\n";
        while (<$FH>) {
            chomp($ARG);
            if ( $mode{'q'} ) {
                say encode_output( elf_val($ARG) );
            } else {
                say sprintf( ": %s : %s",
                    encode_output( elf_val($ARG) ), $ARG );
            }
        }
        close($FH);
    }
} else {
    say encode_output( elf_val( join( ' ', @ARGV ) ) );
}

sub elf_val {
    my $elf = Digest::Elf::elf( $_[0] );    ## <-- investigate \\ replace ..,
    return external_elf( $_[0] )
        if length($elf) > 10
        or length( $_[0] )
        and $elf == 0;
    return $elf;
}

sub external_elf {    ## used when Digest::Elf has an overflow ##
    my $pid = open2( my $output, undef, 'elf', $_[0] );
    chomp( my $elf_val = <$output> );
    return $elf_val;
}

sub encode_output {    ## decimal [ base encoding ]
    return sprintf( '%09d', $_[0] );
}

# ## for later ## use Crypt::Misc qw| encode_b32r |;
#     my $checksum = shift;
#     return substr( encode_b32r($checksum), 0, $bytes ) if not $numerical;
#     return join( '',
#         map { sprintf "%03d", $ARG }
#             unpack( 'C*', substr( $checksum, 0, $bytes ) ) );
# }

#.............................................................................
#NPXYTB7XCI6EOGOOWTK7M43KOV4XXNVJULOS63CPM67YKZTZMYL7OZER2SRRAMOFHFSPGJ2UXDTJI
#::: D5N2CDME4FKUSK4K4JRAD2LOF4XQG3HE4VFB6ONLSE5C23XCLSZ :::: NAILARA AMOS :::
# :: 56DUTABL74RTJYHZX35ZXGZYW7IWFMDCMWYPJ2T5S6ZU64ZFCIBQ :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
