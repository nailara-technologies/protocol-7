#!/usr/bin/perl -C31

use v5.10.1;
use strict;
use warnings;

no warnings 'deprecated';    # XXX: warning temporarely disabled (:utf8)

BEGIN {
    ( my $local_lib_path = $0 ) =~ s|/[^/]+/[^/]+$|/lib/pm|;
    unshift( @INC, $local_lib_path ) if -d $local_lib_path;
}

use open ':encoding(UTF-8)';

# globals
our %code;
our %data;
our %KEYS;
our %ANSI;

$ENV{'PATH'}       = '/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin';
$ENV{'LC_NUMERIC'} = 'en_US.UTF-8';

prepare_subs();
&{ $code{'base.init_exec'} };

$code{'base.load_code'}->('base');

my $agentname;

if ( $0 =~ /^.*nailara\./ ) {
    $agentname = lc($0);
    $agentname =~ s/^.*nailara\.|[\. ]$//g;
} elsif ( defined $ARGV[0] and $ARGV[0] =~ /^([^\-].*)/ ) {
    $agentname = $1;
    shift(@ARGV);
}

( $agentname, @ARGV ) = ( split( / +/, $agentname ), @ARGV )
    if defined $agentname and index( $agentname, ' ' ) != -1;

( $data{'system'}{'args'} = join( ' ', @ARGV ) ) =~ s/ *-[v]+ *//;

if ( defined $agentname and $agentname ne '' ) {
    if ( $data{'system'}{'startup_initcode'} ) {
        $data{'startup'}{'init_code'} = [];
        $code{'log.ok'}->('< accepting stdin init-code >');
        while (<STDIN>) {
            push( @{ $data{'startup'}{'init_code'} }, $_ );
        }
        my $lines = @{ $data{'startup'}{'init_code'} };
        my $s = $lines != 1 ? 's' : '';
        $code{'log.ok'}->("< / read $lines line$s of init-code >");
    }
    $code{'base.init'}->( $data{'system'}{'node'}{'name'} . '.' . $agentname );
} else {
    if ( !@ARGV or not defined $data{'system'}{'agent'}{'name'} ) {
        $data{'system'}{'agent'}{'name'} = '<stdin>';
    }
    $0 = "nailara.$data{'system'}{'agent'}{'name'} ";    # <- whowatch ;/
    $/ = "\n";

    my @agent_code = <STDIN>;

    if ( $data{'system'}{'daemon_mode'} ) { $code{'base.daemonize'}->() }

    $code{'base.execute_agent_code'}
        ->( $code{'base.parser.config'}->( \@agent_code ) )
        if @agent_code;
}

$code{'log.ok'}->("done.");
close;
exit;

# :: initialization / basic subroutines ::

sub prepare_subs {

    # install Time::HiRes versions of base.time and base.sleep (if available)
    my $th_ref
        = (
              eval 'use Time::HiRes; return [ '
            . 'sub{ my $f = $_[0]; $f = 6 if not defined $f or $f =~ /\D/;'
            . ' sprintf( "%.${f}f", Time::HiRes::time ) }, \&Time::HiRes::sleep'
            . ' ]' );
    $data{'system'}{'perl_module'}{'installed'}{'Time::HiRes'} = 1
        if defined $th_ref and ref($th_ref) eq 'ARRAY';
    $th_ref = [ sub { time() }, sub { select( undef, undef, undef, $_[0] ) } ]
        if not defined $th_ref
        or ref($th_ref) ne 'ARRAY';
    $code{'base.time'}  = \&{ $th_ref->[0] };
    $code{'base.sleep'} = \&{ $th_ref->[1] };
    undef $th_ref;

    # override fork() to make rand() fork safe
    $code{'base.fork'} = sub {
        my $pid = CORE::fork;
        if ( !$pid ) {
            ( my $seed = $$ + $code{'base.time'}->(20) ) =~ s/\.//;
            srand($seed);
        }
        return $pid;
    };
    no warnings 'once';
    *CORE::GLOBAL::fork = $code{'base.fork'};
    use warnings 'once';

    # basic subroutine definitions

    $code{'base.init_exec'} = sub {

        use Sys::Hostname;
        use File::Spec;

        $SIG{PIPE} = 'IGNORE';

        $SIG{__WARN__} = $code{'base.sig_warn'};

        $data{'system'}{'start'}{'exec_name'} = File::Spec->rel2abs($0);

        if ( -l $data{'system'}{'start'}{'exec_name'} ) {
            my $new_path = readlink( $data{'system'}{'start'}{'exec_name'} );
            if ( $new_path =~ /\// ) {
                $data{'system'}{'start'}{'exec_name'} = $new_path;
            }
        }

        $data{'system'}{'perl_version'} = $];    # < v5.6
        $data{'system'}{'perl_version'} = sprintf( "%vd", $^V ) if defined $^V;
        $data{'system'}{'perl_unicode'} = ${^UNICODE};
        $data{'system'}{'root_path'}    = $data{'system'}{'start'}{'exec_name'};
        $data{'system'}{'root_path'} =~ s|/[^/]+/[^/]+$||;
        $data{'system'}{'code_path'} = "$data{'system'}{'root_path'}/src";
        $data{'system'}{'conf_path'} = $data{'system'}{'root_path'} . '/cfg';
        $data{'system'}{'lmod_path'} = $data{'system'}{'root_path'} . '/lib/pm';
        delete $data{'system'}{'lmod_path'} if !-d $data{'system'}{'lmod_path'};

        if ( $0 =~ /^.*nailara\./ ) {
            $data{'system'}{'agent'}{'name'} = lc($0);
            $data{'system'}{'agent'}{'name'} =~ s/^.*nailara\.|[\. ]$//g;
        } elsif ( defined $ARGV[0] and $ARGV[0] =~ /^([^\-].*)/ ) {
            my $agent_name = $1;
            $data{'system'}{'agent'}{'subname'} = $1
                if $agent_name =~ s|\[([^\]]+)\]$||;
            $data{'system'}{'agent'}{'name'} = $agent_name;
        }

        if ( not defined $data{'system'}{'agent'}{'name'}
            or $data{'system'}{'agent'}{'name'} eq '' ) {
            $data{'system'}{'agent'}{'name'} = '<init>';
        }

        #	( $data{'system'}{'node'}{'name'},
        #          $data{'system'}{'agent'}{'name'} ) = split ( /\./, $_[0] );

        $data{'system'}{'verbosity'}           = 0;
        $data{'system'}{'ansi_color'}          = 1;
        $data{'system'}{'start'}{'showbanner'} = 1;

        my $stdin_mode = 1;
        foreach my $arg (@ARGV) {
            $stdin_mode = 0 if $arg =~ /^[^\-]/;
            if ( $arg =~ /^-(v+)$/ ) {
                $data{'system'}{'verbosity'} = length($1);
            }
            if ( $arg eq '-d' )   { $data{'system'}{'daemon_mode'}      = 1 }
            if ( $arg eq '-na' )  { $data{'system'}{'ansi_color'}       = 0 }
            if ( $arg eq '-sic' ) { $data{'system'}{'startup_initcode'} = 1 }
            if ( $arg eq '-nb' ) {
                $data{'system'}{'start'}{'showbanner'} = 0;
            }
            if ( $arg =~ /^-N(.+)$/ ) {
                $data{'system'}{'agent'}{'name'} = $1;
            } elsif ($stdin_mode) {
                $data{'system'}{'agent'}{'name'} = '<stdin>';
            }
        }

        $data{'system'}{'node'}{'name'} = hostname || 'nailara';
        $data{'system'}{'node'}{'name'} =~ s/\..+$//;

        if ( $data{'system'}{'ansi_color'} ) {
            %ANSI = (
                'bold'      => "\c[[1m",
                'yelblue'   => "\c[[44m\c[[33m\c[[38;5;202m\c[[48;5;17m",
                'underline' => "\c[[4m",
                'reverse'   => "\c[[7m",
                'normal'    => "\c[[m",
                'cls'       => "\c[[H\c[[2J"
            );
        } else {
            %ANSI = (
                'yelblue'   => '',
                'bold'      => "<< ",
                'underline' => "<< ",
                'reverse'   => "<< ",
                'normal'    => " >>",
                'cls'       => "\c[[H\c[[2J"
            );
        }

        if (   $data{'system'}{'verbosity'}
            && $data{'system'}{'start'}{'showbanner'} ) {
            print "..\n";
            &{ $code{'base.banner'} };
        }
    };

    $code{'base.banner'} = sub {

        local $/ = undef;
        open( my $banner_fh, $data{'system'}{'conf_path'} . '/.banner' )
            or return;
        my $banner = <$banner_fh>;
        close($banner_fh);
        if ( $data{'system'}{'ansi_color'} ) {
            $banner =~ s/\n/$ANSI{normal}\n : $ANSI{bold}/g;
            print " : $ANSI{bold}$banner$ANSI{normal}\n";
        } else {
            print ' : ' . join( "\n : ", split( /\n/, $banner ), "\n" );
            $ANSI{'yelblue'} = '';    # no color
        }

    };

    $code{'base.load_code'} = sub {

        my ( $codedir, $file, $code_name );
        $data{'callbacks'}{'end_code'} //= [];
        $data{'base'}{'modules'}{'load_errors'} = 0;

        if ( !opendir( $codedir, $data{'system'}{'code_path'} ) ) {
            $data{'base'}{'modules'}{'load_errors'}++;
            $code{'log.failed'}->( ": can not open module directory"
                    . " '$data{'system'}{'code_path'}' [$!]" );
            return undef;
        }
        my @code_files = readdir($codedir);
        closedir($codedir);
        $| = 1;

        my @compile_them = ();
        my @remaining    = @_;
        while ( my $code_name = shift @remaining ) {
            $code{'log.ok'}->( "loading module '" . $code_name . "'" );
            my $code_count      = 0;
            my $last_code_count = 0;
            if ( exists $data{'base'}{'modules'}{'internal_name'} ) {
                my $internal_name
                    = delete $data{'base'}{'modules'}{'internal_name'};
                delete $data{'base'}{'modules'}{'moved_to'}{$internal_name}
                    if exists $data{'base'}{'modules'}{'moved_to'};
            }
            foreach my $file_name (@code_files) {
                if (    -f $data{'system'}{'code_path'} . '/' . $file_name
                    and $file_name =~ /^$code_name\.|^$code_name$/
                    and $file_name !~ /^\.|~$|\.orig$/ ) {
                    $code_count++;
                    $/ = undef;
                    open( $file, '<',
                        $data{'system'}{'code_path'} . '/' . $file_name )
                        or die $!;

                    $data{'code'}{$file_name}{'source'} = <$file>;

                    # <[sub_name]>->(  -->  $code{'sub_name'}->(
                    my $orig_len
                        = length( $data{'code'}{$file_name}{'source'} );
                    $data{'code'}{$file_name}{'source'}
                        =~ s|(?<!\\)<\[([\w\-]+\.[\w\-\.]+?)\]>\s*->\(
                            |\$code{'$1'}->(|sgxo;

                    # warn: this parser currently doesn't respect quoted strings
                    #       escape like \<[sub.name]> <-- this to avoid a match!

                    # <[sub_name]>  -->  $code{'sub_name'}->()
                    $data{'code'}{$file_name}{'source'}
                        =~ s|(?<!\\)<\[([\w\-]+\.[\w\-\.]+)\]>
                            |\$code{'$1'}->()|gxo;

                    # <foo.bar>  -->  $data{'foo'}{'bar'}
                    # (requires at least 1 . in the data key to match)
                    $data{'code'}{$file_name}{'source'}
                        =~ s|(?<!\\)<([\w\-:]+\.[\w\-\.:]+)(?<!\\)>
                            |my $k="\$data{'$1'}";$k=~s/\./'}{'/g;$k|gexo;
                    close($file);
                    $/ = "\n";
                    if (length( $data{'code'}{$file_name}{'source'} )
                        > $orig_len and $data{'system'}{'verbosity'} > 3 ) {
                        $code{'log.failed'}->( "\n\n .: $file_name :.\n\n"
                                . $data{'code'}{$file_name}{'source'} );
                    }
                    push( @compile_them, $file_name );
                }
            }
            if ( !$code_count ) {
                $code{'log.failed'}
                    ->(": failed to load module '$code_name' \t[ not found ]");
                $data{'base'}{'modules'}{'load_errors'}++;
            } elsif ( $code_count > $last_code_count ) {
                $data{'system'}{'subs_loaded'}{$code_name}
                    = $code_count - $last_code_count;
            }
            $last_code_count = $code_count;
        }
        my $mod_count = scalar @compile_them;
        return if !$mod_count and !@remaining;
        next if !$mod_count;

        $code{'log.debug'}->(": compiling ...");
        my ( $ok_count, $err_count ) = ( 0, 0 );

        my %disabled_commands;
        map { $disabled_commands{$_} = 1 } @{ $data{'disabled_commands'} }
            if exists $data{'disabled_commands'}
            and ref( $data{'disabled_commands'} ) eq 'ARRAY';

        foreach my $sub_name ( sort(@compile_them) ) {

            local $SIG{__WARN__} = 'IGNORE';
            local $SIG{__DIE__}  = 'IGNORE';

            my $sub_code     = undef;
            my $code_header  = '';
            my $code_footer  = '';
            my $sub_conflict = 0;

            if ( $sub_name =~ /\.(cmd|cli)\.(.+)$/ ) {
                next if $1 eq 'cmd' and exists $disabled_commands{$2};   # skip!
                if ( exists $data{'base'}{$1}{$2} ) {
                    my $old_sub = $data{'base'}{$1}{$2};
                    if ( not exists $data{'base'}{'overwritten'}{$1}{$2} ) {
                        if ( $sub_name ne $old_sub ) {
                            $code{'log.ok'}->("[!] $sub_name >> $old_sub");
                        } else {
                            $code{'log.ok'}->("[!] replacing $sub_name");
                        }
                        $data{'base'}{'overwritten'}{$1}{$2} = {
                            'old' => $old_sub,
                            'new' => $sub_name
                        };
                    } else {
                        push(
                            @{  $data{'base'}{'overwritten'}
                                    {$1}{$2}{'conflicts'}
                            },
                            $sub_name
                        );
                        $data{'base'}{'modules'}{'load_errors'}++;
                        $code{'log.failed'}->("[!] conflict: $sub_name");
                        $sub_conflict = 1;
                    }
                }

                $data{'base'}{$1}{$2} = $sub_name if !$sub_conflict;

                $code_header
                    = 'my $call={}; my $reply={ \'mode\' => \'nack\', \'data\''
                    . ' => \'internal command error\'}; '
                    . 'if ( ref( $_[0] ) eq \'HASH\' ) { '
                    . ' $call=$_[0]; } else { $$call{\'args\'}=$_[0] } ';
                $code_footer = ' ; return $reply';

                $data{'code'}{$sub_name}{'source'}
                    = $code_header
                    . $data{'code'}{$sub_name}{'source'}
                    . $code_footer;
            }

            if ( $data{'system'}{'verbosity'} > 2 ) {
                my $line_comment = "\n# line 1 \"" . $sub_name . "\"\n";
                $sub_code
                    = 'sub {'
                    . $line_comment
                    . "\&{\$code{'base.debug_sub'}}('$sub_name',\@_); "
                    . $data{'code'}{$sub_name}{'source'} . ' }';
            } else {
                my $line_comment = "\n# line 1 \"" . $sub_name . "\"\n";
                $sub_code
                    = 'sub {'
                    . $line_comment
                    . $data{'code'}{$sub_name}{'source'} . '}';
            }

            if ( $code{$sub_name} = eval($sub_code)
                and ref( $code{$sub_name} ) eq 'CODE' ) {
                delete $data{'code'}{$sub_name}{'source'};
                $data{'code'}{$sub_name}{'status'} = 'ok';
                $ok_count++;
                if (    $sub_name !~ /\.(cmd|cli)\./
                    and $sub_name =~ /\.end_code$/ ) {
                    push( @{ $data{'callbacks'}{'end_code'} }, $sub_name );
                }
            } else {
                $code{$sub_name} = sub {
                    {
                        $code{'log.failed'}
                            ->("< ! > - [ broken cmd sub '$sub_name' called ]");
                        return {
                            'mode' => 'nack',
                            'data' => "$1 command is broken <!> see startup log"
                            }
                            if $sub_name =~ /\.cmd\.(.+)$/;
                    }
                };
                delete $data{'code'}{$sub_name}{'source'};
                $data{'base'}{'modules'}{'load_errors'}++;
                my $err_str = $@;
                $err_str =~ s| at $sub_name line (\d+)\.\n| ( line $1 )\n|sg;
                $code{'log.failed'}->(
                    '>', ".:[ $sub_name ]:.",
                    ':', ( map {": [!] $_"} split( /\n+/, $err_str ) ), '-'
                );
                $err_str =~ s/\n/ /sg;
                $err_str =~ tr/ //s;
                $data{'code'}{$sub_name}{'status'} = "[error] $err_str";
                $err_count++;
            }
            if ( $sub_name =~ /\.(cmd|cli)\.(.+)$/ ) { # set command desciptions
                my $section = $1;
                my $command = $2;
                if ( $data{'code'}{$sub_name}{'status'} eq 'ok' ) {
                    if ( $sub_code =~ /\#\s*param\s*=\s*(.+)/ ) {
                        $data{'base'}{'help'}{$section}{$command}{'param'} = $1;
                    }
                    if ( $sub_code =~ /\#\s*descr\s*=\s*(.+)/ ) {
                        $data{'base'}{'help'}{$section}{$command}{'descr'} = $1;
                    } else {
                        $data{'base'}{'help'}{$section}{$command}{'descr'}
                            = 'n/a';
                    }
                } else {
                    $data{'base'}{'modules'}{'load_errors'}++;
                    $code{'log.failed'}->("!> broken command : $2");
                    $data{'base'}{'help'}{$section}{$command}{'descr'}
                        = '! command broken !';
                }
            }
        }
        delete $data{'callbacks'}{'end_code'}
            if !@{ $data{'callbacks'}{'end_code'} };
        map { $data{'code'}{$_}{'status'} = 'removed' if not exists $code{$_} }
            keys %{ $data{'code'} };

        if ($err_count) {
            $code{'log.failed'}
                ->(": $ok_count routines ok, $err_count broken..");
        } else {
            $code{'log.debug'}->(": $ok_count routines, all ok.");
        }
        return ( $ok_count, $err_count );
    };

    $code{'base.debug_sub'} = sub {
        return if $data{'system'}{'verbosity'} < 2;
        my $sub_name     = shift(@_);
        my $quoted_chars = qr/[\ ;:,\.'\\]|^$/o;
        my @_p           = @_;

        # hiding plain text passwords in debug output (not including conf files)
        $_p[2] = '*' x 5 if $sub_name eq 'net.authme';
        $_p[1] = '*' x 5 if $sub_name eq 'auth.ok';
        $_p[0] = '*' x 5 if $sub_name eq 'digest.sha1';
        $_p[1] =~ s/^(auth [^\ ]+) [^\ ]+\n$/$1 *****\n/o
            if $sub_name eq 'net.out';

        map { $_ =~ s|\'|\\'|go if defined $_ } @_p;
        my $param_list = join( ', ',
            map { defined $_ ? ( $_ =~ $quoted_chars ? "'$_'" : $_ ) : '' }
                @_p );

        $param_list =~ s|\n|\\n|g;
        $param_list =~ s|\e|\\e|g;
        $param_list =~ s|\0|\\0|g;

        print ' . '
            . $data{'system'}{'agent'}{'name'}
            . " : $sub_name ( "
            . $param_list . " )\n"
            if $sub_name ne 'base.log'
            and ( $sub_name ne 'base.buffer.add_line' or $_[0] ne 'system' )
            and $sub_name ne 'base.dump_data';    # skipping too much output...
    };
    $code{'log.ok'} = sub {
        if ( defined $code{'base.log'} ) {
            map { $code{'base.log'}->( 1, $_ ) } @_;
        } elsif ( $data{'system'}{'verbosity'} ) {
            map {
                      print ' :'
                    . $data{'system'}{'node'}{'name'} . '.'
                    . $data{'system'}{'agent'}{'name'} . ' '
                    . $_ . "\n"
            } @_;
        }
    };
    $code{'log.failed'} = sub {
        if ( defined $code{'base.log'} ) {
            map { $code{'base.log'}->( 0, $_ ) } @_;
        } else {
            map {
                      print ' :'
                    . $data{'system'}{'node'}{'name'} . '.'
                    . $data{'system'}{'agent'}{'name'} . ' '
                    . $ANSI{'bold'}
                    . $_
                    . $ANSI{'normal'} . "\n"
            } @_;
        }
    };
    $code{'log.debug'} = sub {
        if ( defined $code{'base.log'} ) {
            map { $code{'base.log'}->( 2, $_ ) } @_;
        } elsif ( $data{'system'}{'verbosity'} > 1 ) {
            map {
                      print ' :'
                    . $data{'system'}{'node'}{'name'} . '.'
                    . $data{'system'}{'agent'}{'name'} . ' '
                    . $_ . "\n"
            } @_;
        }
    };

    $code{'dev.null'} = sub { };

    $code{'base.sig_warn'} = sub {
        if (@_) {
            my $level = 0;
            chomp( my @err = @_ );
            if ( $err[0] =~ /^Deep recursion / ) {
                no warnings 'recursion';    # no followups!
                my $msg = join( ' ', '((FATAL))', @err );
                undef $code{'base.log'} if $err[0] =~ /$0|nailara/;
                $code{'log.failed'}->($msg);
                exit(2);
            }
            my ( $package, $filename, $line, $subroutine ) = caller;
            if ( defined $data{'sig_warn_blacklist'} ) { # XXX: <- use an array!
                return
                    if defined $data{'sig_warn_blacklist'}{'package'}
                    and $package eq $data{'sig_warn_blacklist'}{'package'}
                    or defined $data{'sig_warn_blacklist'}{'pattern'}
                    and join( ' ', @err )
                    =~ $data{'sig_warn_blacklist'}{'pattern'};
            }  # todo: human readable way do debug (eval) callers.. (+stacktrc?)
            map {
                $_ =~ s| at $filename line $line[\.,].*$||;
                $level = $1 || 1 if $_ =~ s| *<\{C(\d{1,3})?\}>$||
            } @err;
            ( $package, $filename, $line, $subroutine ) = caller($level)
                if $level;    # <- log parent caller instead ('<{C[level]}>')
            my $caller_str = "[ $filename, line $line ]";
            $caller_str = "[ ... caller level $level too high ... ]"
                if !length( $filename . $line );
            push( @err, $caller_str );
            $code{'log.failed'}->( join( ' ', '[WARN]', @err ) );
        }
    };

    $code{'base.handler.end_code'} = sub {
        return if not exists $data{'callbacks'}{'end_code'};
        foreach
            my $callback_name ( reverse @{ $data{'callbacks'}{'end_code'} } ) {
            if ( exists $code{$callback_name} ) {
                $code{'base.log'}
                    ->( 2, "calling end_code callback '$callback_name' ..." );
                $code{$callback_name}->();
            } else {
                $code{'base.log'}->(
                    0,
                    "[!] referenced end_code callback " ..
                        "'$callback_name' does not exist!"
                );
            }
        }
    };
}

END {
    $code{'base.handler.end_code'}->();
}
