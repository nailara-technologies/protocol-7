#!/usr/bin/perl -C31

use v5.19.8;
use strict;
use warnings;

BEGIN {
    ( my $local_lib_path = $0 ) =~ s|/[^/]+/[^/]+$|/lib/pm|;
    unshift( @INC, $local_lib_path ) if -d $local_lib_path;
}

# somewhat reduntant with -C31 ... to be decided later [which to drop]..,
use open ':encoding(UTF-8)';
map { binmode( $_, ':encoding(UTF-8)' ) } ( *STDIN, *STDOUT, *STDERR );

# globals
our %code;
our %data;
our %KEYS;
our %ANSI;

$ENV{'PATH'}       = '/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin';
$ENV{'LC_NUMERIC'} = 'en_US.UTF-8';

prepare_subs();
&{ $code{'base.init_exec'} };

$code{'base.load_code'}->('base');

my $agentname;

if ( $0 =~ /^.*nailara\./ ) {
    $agentname = lc($0);
    $agentname =~ s/^.*nailara\.//g;
} elsif ( defined $ARGV[0] and $ARGV[0] =~ /^([^\-].*)/ ) {
    $agentname = $1;
    shift(@ARGV);
}

( $agentname, @ARGV ) = ( split( / +/, $agentname ), @ARGV )
    if defined $agentname and index( $agentname, ' ' ) != -1;

( $data{'system'}{'args'} = join( ' ', @ARGV ) ) =~ s/ *-[v]+ *//;

if ( defined $agentname and $agentname ne '' ) {
    if ( $data{'system'}{'startup_initcode'} ) {
        $data{'startup'}{'init_code'} = [];
        $code{'log.noerr'}->('> awaiting stdin init-code');
        while (<STDIN>) {
            push( @{ $data{'startup'}{'init_code'} }, $_ );
        }
        my $lines = @{ $data{'startup'}{'init_code'} };
        my $s     = $lines != 1 ? 's' : '';
        $code{'log.noerr'}->("< read $lines line$s of init-code");
    }
    $code{'base.init'}->( $data{'system'}{'node'}{'name'} . '.' . $agentname );
} else {
    if ( !@ARGV or not defined $data{'system'}{'agent'}{'name'} ) {
        $data{'system'}{'agent'}{'name'} = '<stdin>';
    }
    $0 = "nailara.$data{'system'}{'agent'}{'name'}";
    $/ = "\n";

    my @agent_code = <STDIN>;

    if ( $data{'system'}{'daemon_mode'} ) { $code{'base.daemonize'}->() }

    if (@agent_code) {
        $data{'base'}{'config_parser'}{'cfg_type'}  = 'start_cfg';
        $data{'base'}{'config_parser'}{'cfg_name'}  = 'agent';
        $data{'base'}{'config_parser'}{'cfg_descr'} = '<STDIN>';
        $code{'base.execute_agent_code'}
            ->( $code{'base.parser.config'}->( \@agent_code ) );
    }
}

$code{'log.noerr'}->("done.");
close;
exit;

# :: initialization / basic subroutines ::

sub prepare_subs {

    # install Time::HiRes versions of base.time and base.sleep (if available)
    my $th_ref
        = (
              eval 'use Time::HiRes; return [ '
            . 'sub{ my $f = $_[0]; $f = 6 if not defined $f or $f =~ /\D/;'
            . ' sprintf( "%.${f}f", Time::HiRes::time ) }, \&Time::HiRes::sleep'
            . ' ]' );
    $data{'system'}{'perl_module'}{'installed'}{'Time::HiRes'} = 1
        if defined $th_ref and ref($th_ref) eq 'ARRAY';
    $th_ref = [ sub { time() }, sub { select( undef, undef, undef, $_[0] ) } ]
        if not defined $th_ref
        or ref($th_ref) ne 'ARRAY';
    $code{'base.time'}  = \&{ $th_ref->[0] };
    $code{'base.sleep'} = \&{ $th_ref->[1] };
    undef $th_ref;

    $code{'base.ntime'} = sub { # [ network time : secs from 2002-06-05 * 4200 ]
        my $param = shift // 0;
        my $ntime = $data{'base'}{'ntime_ustart'} //= 1023228000;
        my ( $cur_time, $precision ) = ( undef, 0 );
        if ( length($param) >= 9 ) { $cur_time = $param }    # <- < unix time >
        else {
            $precision = $param > 11 ? 11 : $param;
            $cur_time  = $code{'base.time'}->( 2 + $precision );
        }
        return sprintf( "%.${precision}f", ( $cur_time - $ntime ) * 4200 );
    };

    $code{'base.log_prefix_width'} = sub {
        ( my $agent_name, my $agent_subname ) = @_;
        $agent_name //= $data{'system'}{'agent'}{'name'};
        $agent_subname = $data{'system'}{'agent'}{'subname'} if !@_;
        my $lp_len = 4 + length( $data{'system'}{'node'}{'name'} )
            + length($agent_name);
        $lp_len += 2 + length($agent_subname) if defined $agent_subname;
        return $lp_len;
    };

    # basic subroutine definitions

    $code{'base.init_exec'} = sub {

        use FindBin qw| $RealBin $RealScript |;
        use File::Spec::Functions;
        use Cwd 'abs_path';
        use Sys::Hostname;
        use File::stat;

        $SIG{'PIPE'} = 'IGNORE';

        $SIG{'__WARN__'} = $code{'base.sig_warn'};

        $data{'system'}{'start'}{'exec_name'}
            = abs_path( catfile( $RealBin, $RealScript ) );
        my $root_path = $data{'system'}{'root_path'}
            = abs_path( catdir( $RealBin, updir() ) );
        $data{'system'}{'perl_version'} = $];    # < v5.6
        $data{'system'}{'perl_version'} = sprintf( "%vd", $^V ) if defined $^V;
        $data{'system'}{'perl_unicode'} = ${^UNICODE};
        $data{'system'}{'code_path'}    = catdir( $root_path, 'src' );
        $data{'system'}{'conf_path'}    = catdir( $root_path, 'cfg' );
        $data{'system'}{'lmod_path'}    = catdir( $root_path, 'lib', 'pm' );
        delete $data{'system'}{'lmod_path'} if !-d $data{'system'}{'lmod_path'};

        my $ver_str = $data{'nailara'}{'source_version'} = 'unknown';
        my $version_file
            = catfile( $data{'system'}{'conf_path'}, 'nailara.source_version' );

        if ( -f $version_file and open( my $ver_fh, '<' . $version_file ) ) {
            ( $data{'nailara'}{'source_version'} = $ver_str = <$ver_fh> )
                =~ s|\s||g;
            close($ver_fh);
        }
        my $release_file
            = catfile( $data{'system'}{'conf_path'},
            'nailara.release_version' );
        if ( -f $release_file and open( my $ver_fh, '<' . $release_file ) ) {
            ( $data{'nailara'}{'release_version'} = $ver_str = <$ver_fh> )
                =~ s|\s||g;
            close($ver_fh);
        }
        if ( $0 =~ /^.*nailara\./ ) {
            $data{'system'}{'agent'}{'initialized'} = 0;
            $data{'system'}{'agent'}{'name'}        = lc($0);
            $data{'system'}{'agent'}{'name'} =~ s/^.*nailara\.|[\. ]$//g;
        } elsif ( defined $ARGV[0] and $ARGV[0] =~ /^([^\-].*)/ ) {
            my $agent_name = $1;
            $data{'system'}{'agent'}{'subname'} = $1
                if $agent_name =~ s|\[([^\]]+)\]$||;
            $data{'system'}{'agent'}{'name'} = $agent_name;
        }

        if ( not defined $data{'system'}{'agent'}{'name'}
            or $data{'system'}{'agent'}{'name'} eq '' ) {
            $data{'system'}{'agent'}{'name'} = '<init>';
        }

        #	( $data{'system'}{'node'}{'name'},
        #          $data{'system'}{'agent'}{'name'} ) = split ( /\./, $_[0] );

        $data{'system'}{'verbosity'}           = 0;
        $data{'system'}{'ansi_color'}          = 1;
        $data{'system'}{'start'}{'showbanner'} = 1;

        my $stdin_mode = 1;
        foreach my $arg (@ARGV) {
            $stdin_mode = 0 if $arg =~ /^[^\-]/;
            if ( $arg =~ /^-(v+)$/ ) {
                $data{'system'}{'verbosity'} = length($1);
            }
            if ( $arg eq '-d' )     { $data{'system'}{'daemon_mode'}      = 1 }
            if ( $arg eq '-stdin' ) { $data{'system'}{'startup_initcode'} = 1 }
            if ( $arg eq '-na' )    { $data{'system'}{'ansi_color'}       = 0 }
            if ( $arg eq '-nb' ) {
                $data{'system'}{'start'}{'showbanner'} = 0;
            }
            if ( $arg =~ /^-N(.+)$/ ) {
                $data{'system'}{'agent'}{'name'} = $1;
            } elsif ($stdin_mode) {
                $data{'system'}{'agent'}{'name'} = '<stdin>';
            }
            if ( $arg =~ /^-lpw=(\d{1,2})$/ ) {    # <- used by 'nroot' agent
                $data{'system'}{'start'}{'log_prefix_width'} = $1;
            }
            if ( $arg =~ /^-export-core-subs$/ ) {
                $code{'dump_core_subs'}->();
                exit(0);
            }
        }
        $data{'system'}{'path'}{'rel'}{'cur_agent_cfg'} = '<STDIN>'
            if $stdin_mode;
        $data{'system'}{'node'}{'name'} = hostname || 'nailara';
        $data{'system'}{'node'}{'name'} =~ s/\..+$//;

        if ( $data{'system'}{'ansi_color'} ) {
            %ANSI = (
                'bold'      => "\c[[1m",
                'yelblue'   => "\c[[44m\c[[33m\c[[38;5;202m\c[[48;5;17m",
                'underline' => "\c[[4m",
                'reverse'   => "\c[[7m",
                'normal'    => "\c[[m",
                'cls'       => "\c[[H\c[[2J"
            );
        } else {
            %ANSI = (
                'yelblue'   => '',
                'bold'      => "<< ",
                'underline' => "<< ",
                'reverse'   => "<< ",
                'normal'    => " >>",
                'cls'       => "\c[[H\c[[2J"
            );
        }

        my $own_len = &{ $code{'base.log_prefix_width'} };
        if ( defined $data{'system'}{'start'}{'log_prefix_width'}
            and $own_len <= $data{'system'}{'start'}{'log_prefix_width'} ) {
            my $dot_cnt
                = $data{'system'}{'start'}{'log_prefix_width'} - $own_len + 2;
            $data{'history'}{'dots'} = '.' x $dot_cnt;
        }

        if (   $data{'system'}{'verbosity'}
            && $data{'system'}{'start'}{'showbanner'} ) {
            say ".\n.";
            &{ $code{'base.banner'} };
        }
    };

    $code{'base.banner'} = sub {
        my $version_str = sprintf( " \\ protocol-seven version \\ %s \\",
            $data{'nailara'}{'source_version'} );
        local $/ = undef;
        open( my $banner_fh,
            catfile( $data{'system'}{'conf_path'}, '.banner' ) )
            or return;
        my $banner = <$banner_fh>;
        close($banner_fh);
        my $n = $b = '';
        if ( $data{'system'}{'ansi_color'} ) {
            $n = $ANSI{'normal'} and $b = $ANSI{'bold'};
        } else {
            $ANSI{'yelblue'} = '';
        }
        map { say "$n: $b$_" } split( /\n/, $banner ), '';
        say "$n: $version_str\n:";
    };

    $code{'dump_core_subs'} = sub {
        my %core_subs;
        my $bin_path = $data{'system'}{'start'}{'exec_name'};
        open( my $nlr_fh, $bin_path ) or die "$bin_path: $!\n";
        my %sub_src;
        my $sub_name;
        foreach my $src_line (<$nlr_fh>) {
            $sub_name = undef
                if defined $sub_name and $src_line =~ m|^\s*};\s*(\#.*)?\n$|;
            if ( defined $sub_name ) {
                $sub_src{$sub_name} //= [];
                push( @{ $sub_src{$sub_name} }, $src_line );
            }
            $sub_name = $1
                if $src_line
                =~ m|^\s*\$code\{\'([^\']+)\'\}\s*=\s*sub\s*\{\s*(\#[^\n]*)?\n$|;
        }
        print "\n";
        close($nlr_fh);
        foreach
            my $sub_name ( sort { length $a <=> length $b } sort keys %sub_src )
        {
            print "\n#  .::[ $sub_name ]:.\n#  ::\n";
            foreach my $sub_line ( @{ $sub_src{$sub_name} } ) {
                print $sub_line;
            }
            print "\n#  .\n#  ::.\n";

        }
        exit;
    };

    $code{'base.purge_code'} = sub { # todo : create callback registry [to skip]
        my $code_name   = shift;
        my $purge_count = 0;
        my @agent_commands;
        map {
            if ( $_ !~ /\.(callback|handler)\./
                and not exists $data{'base'}{'core_subs'}{$_} ) {
                ++$purge_count
                    and $data{'code'}{$_}{'status'} = 'purged'
                    and eval { undef &{ delete $code{$_} } };
                push( @agent_commands, $1 ) if $_ =~ /\.cmd\.(.+)$/;
                --$purge_count if $@;
            }
            }
            grep {/^$code_name(\..+)?$/} keys %code;
        map {
            delete $data{'base'}{'cmd'}{$_};
            delete $data{'base'}{'help'}{'cmd'}{$_};
        } @agent_commands;
        return $purge_count;
    };

    $code{'base.code.file_list'} = sub {
        my $codedir_fh;
        $data{'base'}{'modules'}{'load_errors'} //= 0;
        if ( !opendir( $codedir_fh, $data{'system'}{'code_path'} ) ) {
            $data{'base'}{'modules'}{'load_errors'}++;
            $code{'log.error'}->( ": can not open source code directory"
                    . " '$data{'system'}{'code_path'}' [$!]" );
            return undef;
        }
        my @code_files = grep { !/^\./ } readdir($codedir_fh);
        closedir($codedir_fh);
        return @code_files;
    };

    $code{'base.load_code'} = sub {
        my ( $file, $code_name );

        my @src_names = sort { length $a <=> length $b } sort @_;

        $data{'callbacks'}{'end_code'} //= [];

        map      { $data{'plugins'}{'status'}{$_}{'load_errors'} = 0 }
            grep {/^plugin\./} @src_names;

        my @code_files = $code{'base.code.file_list'}->();

        $| = 1;
        my @compile_them = ();
        while ( $code_name = shift @src_names ) {
            my $src_str = $code_name =~ /^plugin./ ? '' : ' source';
            $code{'log.noerr'}->(": loading$src_str '$code_name'");

            if ( my $purge_count = $code{'base.purge_code'}->($code_name) ) {
                my $s = $purge_count == 1 ? '' : 's';
                $code{'log.debug'}->(": $purge_count sub$s undefined");
            }

            my $code_count      = 0;
            my $last_code_count = 0;
            if ( exists $data{'base'}{'modules'}{'internal_name'} ) {
                my $internal_name
                    = delete $data{'base'}{'modules'}{'internal_name'};
                delete $data{'base'}{'modules'}{'moved_to'}{$internal_name}
                    if exists $data{'base'}{'modules'}{'moved_to'};
            }
            foreach my $file_name (@code_files) {
                if (    -f $data{'system'}{'code_path'} . '/' . $file_name
                    and $file_name =~ /^$code_name\.|^$code_name$/
                    and $file_name !~ /^\.|~$|\.orig$|\.LOG$/ ) {
                    $code_count++;
                    local $/ = undef;
                    open( $file, '<',
                        catfile( $data{'system'}{'code_path'}, $file_name ) )
                        or die $!;

                    $data{'code'}{$file_name}{'source'} = <$file>;

                    # <[sub_name]>->(  -->  $code{'sub_name'}->(
                    my $orig_len
                        = length( $data{'code'}{$file_name}{'source'} );

                    $data{'code'}{$file_name}{'source'}
                        =~ s|(?<!\\)<\[([\w\-]+\.[\w\-\.]+?)\]>\s*->\(
                            |\$code{'$1'}->(|sgxo;

                   # warn: this parser currently doesn't respect quoted strings
                   #       escape like \<[sub.name]> <-- this to avoid a match!
                   #
                   # note: a generic quoted string match would be :  ##########
                   # ####  (["'])(?:\\?+.)*?\1 or "([Ë†"]<(?<=\\)")+" #[mre:212]

                    # <[sub_name]>  -->  $code{'sub_name'}->()
                    $data{'code'}{$file_name}{'source'}
                        =~ s|(?<!\\)<\[([\w\-]+\.[\w\-\.]+)\]>
                            |\$code{'$1'}->()|gxo;

                    # <foo.bar>  -->  $data{'foo'}{'bar'}
                    # (requires at least 1 . in the data key to match)
                    $data{'code'}{$file_name}{'source'}
                        =~ s|(?<!\\)<([\w\-:]+\.[\w\-\.:]+)(?<!\\)>
                            |my $k="\$data{'$1'}";$k=~s/\./'}{'/g;$k|gexo;
                    close($file);
                    $/ = "\n";
                    if (length( $data{'code'}{$file_name}{'source'} )
                        > $orig_len and $data{'system'}{'verbosity'} > 3 ) {
                        $code{'log.error'}->( "\n\n .: $file_name :.\n\n"
                                . $data{'code'}{$file_name}{'source'} );

                        $data{'plugins'}{'status'}{$code_name}{'load_errors'}++
                            if !length($src_str);    # <- is plugin..
                    }
                    push( @compile_them, $file_name );
                } elsif ( $file_name =~ /\.orig$/ ) {
                    $code{'log.error'}->("[invalid/remove!] $file_name");
                }
            }
            if ( !$code_count ) {
                $code{'log.error'}
                    ->(": failed to load module '$code_name' \t[ not found ]");
                $data{'base'}{'modules'}{'load_errors'}++;
            } elsif ( $code_count > $last_code_count ) {
                $data{'system'}{'subs_loaded'}{$code_name}
                    = $code_count - $last_code_count;
            }
            $last_code_count = $code_count;
        }
        my $mod_count = scalar @compile_them;
        return if !$mod_count and !@src_names;
        next   if !$mod_count;

        $code{'log.debug'}->(": compiling ...");
        my ( $ok_count, $err_count ) = ( 0, 0 );

        my %disabled_commands;
        map { $disabled_commands{$_} = 1 } @{ $data{'disabled_commands'} }
            if exists $data{'disabled_commands'}
            and ref( $data{'disabled_commands'} ) eq 'ARRAY';

        foreach my $sub_name ( sort(@compile_them) ) {

            local $SIG{'__WARN__'} = 'IGNORE';
            local $SIG{'__DIE__'}  = 'IGNORE';

            my $sub_code     = undef;
            my $code_header  = '';
            my $code_footer  = '';
            my $sub_conflict = 0;

            if ( $sub_name =~ /\.(cmd|cli)\.(.+)$/ ) {
                my $cmd_type = $1;
                my $cmd_name = $2;
                next
                    if $cmd_type eq 'cmd'
                    and exists $disabled_commands{$cmd_name};
                if ( exists $data{'base'}{$cmd_type}{$cmd_name} ) {
                    my $old_sub = $data{'base'}{$cmd_type}{$cmd_name};
                    if (not exists $data{'base'}{'overwritten'}{$cmd_type}
                        {$cmd_name} ) {
                        if ( $sub_name ne $old_sub ) {
                            $code{'log.debug'}->("[!] $sub_name >> $old_sub");
                        } else {
                            $code{'log.debug'}->("[!] replacing sub $sub_name");
                        }
                        $data{'base'}{'overwritten'}{$cmd_type}{$cmd_name} = {
                            'old' => $old_sub,
                            'new' => $sub_name
                        };
                    } else {
                        push(
                            @{  $data{'base'}{'overwritten'}
                                    {$cmd_type}{$cmd_name}{'conflicts'}
                            },
                            $sub_name
                        );
                        $data{'base'}{'modules'}{'load_errors'}++;
                        $code{'log.error'}->("[!] conflict: $sub_name");
                        $sub_conflict = 1;
                    }
                }

                $data{'base'}{$cmd_type}{$cmd_name} = $sub_name
                    if !$sub_conflict;
                $code_header
                    = 'my $call={}; my $reply={ \'mode\' => \'nak\', \'data\''
                    . " => \"error during invocation of '$cmd_name' command"
                    . " [ details logged ]\" }; "
                    . 'if ( ref( $_[0] ) eq \'HASH\' ) { '
                    . ' $call=$_[0]; } else { $$call{\'args\'}=$_[0] } ';
                $code_footer = ' ; return $reply';

                $data{'code'}{$sub_name}{'source'}
                    = $code_header
                    . $data{'code'}{$sub_name}{'source'}
                    . $code_footer;
            }

            if ( $data{'system'}{'verbosity'} > 2 ) {
                my $line_comment = "\n# line 1 \"" . $sub_name . "\"\n";
                $sub_code
                    = 'sub {'
                    . $line_comment
                    . "\&{\$code{'base.debug_sub'}}('$sub_name',\@_); "
                    . $data{'code'}{$sub_name}{'source'} . ' }';
            } else {
                my $line_comment = "\n# line 1 \"" . $sub_name . "\"\n";
                $sub_code
                    = 'sub {'
                    . $line_comment
                    . $data{'code'}{$sub_name}{'source'} . '}';
            }

            ##                      ###
            ## compiling subroutine ###
            ##                      ###

            open( my $std_err, ">&", \*STDERR ) or warn "can not dup [STDERR]";
            open STDERR, '>>/dev/null' or warn "/dev/null: $!"; # <- silencing..

            my $compilation_success
                = ( $code{$sub_name} = eval($sub_code)
                    and ref( $code{$sub_name} ) eq 'CODE' )
                ? 1
                : 0;
            open( STDERR, ">&$std_err" ) or warn "can not dup [OERR]"; # restore

            if ($compilation_success) {
                delete $data{'code'}{$sub_name}{'source'};
                $data{'code'}{$sub_name}{'status'} = 'no-err';
                $ok_count++;
                if (    $sub_name !~ /\.(cmd|cli)\./
                    and $sub_name =~ /\.end_code$/ ) {
                    push( @{ $data{'callbacks'}{'end_code'} }, $sub_name );
                }
            } else {
                $code{$sub_name} = sub {
                    {
                        $code{'log.error'}
                            ->("< ! > - [ broken cmd sub '$sub_name' called ]");
                        return {
                            'mode' => 'nak',
                            'data' => "$1 command is broken <!> see startup log"
                            }
                            if $sub_name =~ /\.cmd\.(.+)$/;
                    }
                };
                delete $data{'code'}{$sub_name}{'source'};
                $data{'base'}{'modules'}{'load_errors'}++;
                my $err_str = $@;
                $err_str =~ s| at $sub_name line (\d+)\.\n| ( line $1 )\n|sg;

                my @compile_errors = (
                    '>', ".:[ $sub_name ]:.",
                    ':', ( map {": [!] $_"} split( /\n+/, $err_str ) ), '-'
                );

                $code{'log.error'}->(@compile_errors);
                map { $code{'base.buffer.add_line'}->( 'compile-errors', $_ ) }
                    @compile_errors;

                $err_str =~ s/\n/ /sg;
                $err_str =~ tr/ //s;
                $data{'code'}{$sub_name}{'status'} = "[error] $err_str";
                $err_count++;
            }
            if ( $sub_name =~ /\.(cmd|cli)\.(.+)$/ ) { # set command desciptions
                my $section = $1;
                my $command = $2;
                if ( $data{'code'}{$sub_name}{'status'} eq 'no-err' ) {
                    if ( $sub_code =~ /\#\s*param\s*=\s*(.+)/ ) {
                        $data{'base'}{'help'}{$section}{$command}{'param'} = $1;
                    }
                    if ( $sub_code =~ /\#\s*descr\s*=\s*(.+)/ ) {
                        $data{'base'}{'help'}{$section}{$command}{'descr'} = $1;
                    } else {
                        $data{'base'}{'help'}{$section}{$command}{'descr'}
                            = '<<< \'descr\' header key not defined >>>';
                    }
                } else {
                    $data{'base'}{'modules'}{'load_errors'}++;
                    $code{'log.error'}->("!> broken command : $2");
                    $data{'base'}{'help'}{$section}{$command}{'descr'}
                        = '<<< command did not compile properly >>>';
                }
            }
        }
        delete $data{'callbacks'}{'end_code'}
            if !@{ $data{'callbacks'}{'end_code'} };
        map { $data{'code'}{$_}{'status'} = 'removed' if not exists $code{$_} }
            keys %{ $data{'code'} };
        my $s = $ok_count != 1 ? 's' : '';
        if ($err_count) {
            $code{'log.error'}
                ->(": success on $ok_count sub$s, $err_count broken., `:|");
        } else {
            $code{'log.noerr'}->(": $ok_count sub$s., no errors.., =)");
        }
        if ( defined $code{'base.buffer.add_line'}
            and not defined $data{'buffer'}{'agent'} ) {
            $data{'buffer'}{'agent'}{'max_size'} //= 131072;    # 128K
            my $seperator_len = 18 + length( $data{'system'}{'agent'}{'name'} );
            map { $code{'base.buffer.add_line'}->( 'agent', $_ ) } (
                join( ' ', $code{'base.ntime'}->(3), 1, '_' x $seperator_len ),
                $code{'base.ntime'}->(3)
                    . " 1 STARTUP 'agents/$data{system}{agent}{name}'/",
                $code{'base.ntime'}->(3)
                    . " 1 VERSION '$data{nailara}{source_version}'"
            );
        }
        return ( $ok_count, $err_count );
    };

    $code{'base.debug_sub'} = sub {
        return if $data{'system'}{'verbosity'} < 2;
        my $sub_name     = shift(@_);
        my $quoted_chars = qr/[\ ;:,\.'\\]|^$/o;
        my @_p           = @_;

        # log all used subroutines if $sub_touch_dir exist and is owned by root!
        my $sub_touch_dir = $data{'system'}{'path'}{'sub_log_dir'}
            // '/tmp/nailara_debug.sub_log';
        if ( -d $sub_touch_dir and File::stat::stat($sub_touch_dir)->uid == 0 )
        {
            my $agent_name = $data{'system'}{'agent'}{'name'};
            my $actual_dir = "$sub_touch_dir/$agent_name";
            if ( !-d $actual_dir ) {
                mkdir($actual_dir);
                chmod( 0777, $actual_dir );
            }
            open( my $_fh, ">$actual_dir/$sub_name" )
                if !-f ">$actual_dir/$sub_name";
            if ( fileno($_fh) ) {
                say {$_fh} $code{'base.ntime'}->(3);
                close($_fh);
            }
        }

        # hiding plain text passwords in debug output (not including conf files)
        $_p[2] = '*' x 7 if $sub_name eq 'net.authme';
        $_p[1] = '*' x 7 if $sub_name eq 'auth.ok';
        $_p[0] = '*' x 7 if $sub_name eq 'digest.sha.1';
        $_p[1] =~ s|^(auth [^\ ]+) [^\ ]+\n$|$1 *****\n|o
            if $sub_name eq 'net.out';

        map { $_ =~ s|(\')|\\$1|go if defined $_ } @_p;
        my @params
            = map { defined $_ ? ( $_ =~ $quoted_chars ? "'$_'" : $_ ) : '' }
            @_p;

        my $param_list = join( ', ', @params );

        $param_list =~ s|\n|\\n|g;
        $param_list =~ s|\e|\\e|g;
        $param_list =~ s|\0|\\0|g;

        ## replacing perl objects ##
        eval { use Crypt::Misc qw|encode_b32r| }
            if not defined &{'encode_base32'};
        if ( $param_list =~ s|\'?(\S+(::\S+)+)|lc($1)|ge ) {
            $param_list =~ s|::|.|g;
            $param_list =~ s|event\.event|event|g;
        }
        $param_list =~ s{=(CODE|SCALAR|GLOB|HASH|ARRAY)}{' : '.lc($1)}ige;
        $param_list =~ s{(CODE|SCALAR|GLOB|HASH|ARRAY)}{lc($1)}ge;
        $param_list =~ s{\(0x([a-f0-9]+)\)\'?}{ sprintf( " :: %s ::",
            lc(encode_b32r(pack("H*",$1))))
        }gxe
            if defined &{'encode_b32r'};
        ##

        say ' . ', $data{'system'}{'agent'}{'name'},
            " : $sub_name ( $param_list )"
            if $sub_name ne 'base.log'
            and ( $sub_name ne 'base.buffer.add_line' or $_[0] ne 'agent' )
            and $sub_name ne 'base.dump_data';    # skipping too much output...
    };
    $code{'log.noerr'} = sub {
        if ( defined $code{'base.log'} ) {
            map { $code{'base.log'}->( 1, $_ ) } @_;
        } elsif ( $data{'system'}{'verbosity'} ) {
            my $dot
                = defined $data{'history'}{'dots'}
                ? $data{'history'}{'dots'}
                : '.';
            map {
                say ':.', $data{'system'}{'node'}{'name'},
                    $dot, $data{'system'}{'agent'}{'name'}, '.', $_
            } @_;
        }
    };
    $code{'log.error'} = sub {
        if ( defined $code{'base.log'} ) {
            map { $code{'base.log'}->( 0, $_ ) } @_;
        } else {
            my $dot
                = defined $data{'history'}{'dots'}
                ? $data{'history'}{'dots'}
                : '.';
            map {
                say ':.', $data{'system'}{'node'}{'name'},
                    $dot, $data{'system'}{'agent'}{'name'}, '.', $ANSI{'bold'},
                    $_, $ANSI{'normal'}
            } @_;
        }
    };
    $code{'log.debug'} = sub {
        if ( defined $code{'base.log'} ) {
            map { $code{'base.log'}->( 2, $_ ) } @_;
        } elsif ( $data{'system'}{'verbosity'} > 1 ) {
            my $dot
                = defined $data{'history'}{'dots'}
                ? $data{'history'}{'dots'}
                : '.';
            map {
                say ':.', $data{'system'}{'node'}{'name'},
                    $dot, $data{'system'}{'agent'}{'name'}, '.', $_
            } @_;
        }
    };

    $code{'dev.null'} = $code{'base.undef'} = sub { return undef };

    $code{'base.sig_warn'} = sub {
        if (@_) {
            my $level = 0;
            chomp( my @err = @_ );
            if ( $err[0] =~ /^Deep recursion / ) {
                no warnings 'recursion';    # no followups!
                my $msg = join( ' ', '<< FATAL >>', @err );
                undef $code{'base.log'} if $err[0] =~ /$0|nailara/;
                $code{'log.error'}->($msg);
                exit(2);
            }
            my ( $package, $filename, $line, $subroutine ) = caller;
            if ( defined $data{'sig_warn_blacklist'} ) { # LLL: <- use an array!
                return
                    if defined $data{'sig_warn_blacklist'}{'package'}
                    and $package eq $data{'sig_warn_blacklist'}{'package'}
                    or defined $data{'sig_warn_blacklist'}{'pattern'}
                    and join( ' ', @err )
                    =~ $data{'sig_warn_blacklist'}{'pattern'};
            }  # todo: human readable way do debug (eval) callers.. (+stacktrc?)
            map {
                $_ =~ s| at $filename line $line[\.,].*$||;
                $level = $1 || 1 if $_ =~ s| *<\{C(\d{1,3})?\}>$||
            } @err;
            ( $package, $filename, $line, $subroutine ) = caller($level)
                if $level;    # <- log parent caller instead ('<{C[level]}>')

            # special exception for agent code evaluation
            if ( abs_path($filename) eq $data{'system'}{'start'}{'exec_name'}
                and $line == 56 ) {
                my $l = 0;
                $filename = $data{'base'}{'eval_error'}{'name'}
                    //= [ caller($l) ]->[1];
                $line = $data{'base'}{'eval_error'}{'line'}
                    //= [ caller($l) ]->[2];
            }

            my $caller_str = "[ $filename, $line ]";
            $caller_str = "[ ... caller level $level too high ... ]"
                if !length( $filename . $line );
            push( @err, $caller_str );
            $code{'log.error'}->( join( ' ', '<< warn >>', @err ) );
        }
    };

    $code{'base.handler.end_code'} = sub {
        return if not exists $data{'callbacks'}{'end_code'};
        foreach
            my $callback_name ( reverse @{ $data{'callbacks'}{'end_code'} } ) {
            if ( exists $code{$callback_name} ) {
                $code{'base.log'}
                    ->( 2, "calling end_code callback '$callback_name'..," );
                $code{$callback_name}->();
            } else {
                $code{'base.log'}->(
                    0,
                    "<< ! >> referenced end_code callback "
                        . "'$callback_name' does not exist. << ! >>"
                );
            }
        }
    };

    map { $data{'base'}{'core_subs'}{$_} = $code{$_} } keys %code;
}

END {
    $code{'base.handler.end_code'}->();
}
