#!/usr/bin/perl
use v5.24;
use strict;
use English;
use warnings;
use Term::Size;
use Getopt::Std;
use Term::ANSIColor;
use Digest::Elf qw| elf |;
use Crypt::PRNG::Fortuna;
use Text::Wrap qw| wrap |;
use Time::HiRes qw| sleep |;
use Unicode::MapUTF8 qw| to_utf8 utf8_charset_alias utf8_supported_charset |;
use Crypt::Misc qw| encode_b32r decode_b32r |;

no warnings 'experimental';

my $base_size  = '6';
my $base_table = 'cp10007';

## [LLL] disable ANSIColor on 'piped' STDOUT mode .., [$mode{Q}]

getopts( 'LhBSvs:r:eqQd:DC:U:', \my %mode );

## table aliases ##
utf8_charset_alias(
    {   '57' => '857',
        'U7' => 'utf7',
        '17' => 'cp10007',
        'y'  => 'cyrillic',
        '5'  => 'ISO-8859-5',
        '4'  => 'ISO-8859-4',
    }
);

if ( $mode{'L'} ) {    ## list \ search tables [ -L ]
    say '.';
    my @charsets_available = utf8_supported_charset;
    ( my $s ) = ( @ARGV ? shift @ARGV : undef );
    my @matches;
    my $max_len = 0;
    map {
        if ( not defined $s or $ARG =~ m|$s|i ) {
            push( @matches, $ARG );
            $max_len = length($ARG) if length($ARG) > $max_len;
        }
        }
        sort { length $b <=> length $a } reverse sort @charsets_available;
    map { printf( ": %${max_len}s : :\n", uc($ARG) ) } @matches;
    say ':.,' and exit;
}

my $skip_repeat_spaces = 1;

my @highlight_chars = qw| ℍ ᔈ 5 .٫ ܳ L = ≠ ≤ т † Ҭ T Т ∞ • |;    #  ℍ === 8461

my $highlight = { map { unpack( "%U", $ARG ) => 1 } @highlight_chars };

map { $highlight->{$ARG} = 1 } qw| 7692 1538 |;                  # Ḍ ؂

( my $x, my $y ) = Term::Size::chars;

$x //= 80;
$y //= 25;

my $screen_chars = $y * $x;

say " $x x $y == $screen_chars" if $mode{'D'};    ## <-- '-D' debug mode is ..,

$skip_repeat_spaces = 0 if $mode{'S'};

my $result_prefix = ':: ';

my $B32         = qr|[A-Z2-7]+|o;
my $nailara_bg  = color('on_r09g05b41');
my $nailara_fg  = color('r38g46b153');
my $error_color = color('r195g71b6');
my $blacklight  = color('r68g39b172');
my $green       = color('r71g195b6');

$mode{'q'} = 1        if $mode{'Q'};
$mode{'C'} = 'BASE32' if defined $mode{'C'} and $mode{'C'} eq 'B';

my @B32_exclude
    = grep {length} map { defined $mode{$ARG} && "-$ARG" } qw| S B v r d U |;
say sprintf( ":\n:: mutually exclusive modes selected [ -C BASE32 and %s ]\n",
    join( ', ', reverse sort @B32_exclude ) )
    and exit(4)
    if defined $mode{'C'}
    and $mode{'C'} eq 'BASE32'
    and scalar(@B32_exclude);

$mode{'d'} //= 0;

$SIG{'__WARN__'} = sub {
    my $err = shift;
    return if lc($err) =~ m|^wide character| or $mode{'q'};
    my $w = 44;
    $err =~ s{ at .+$|\n+}{}g if not $mode{'D'};
    $err =~ s{[0\\]x(\S\S)}
    { $w+=-3+length("$nailara_fg");
    $blacklight.sprintf(":.%03d.:",unpack("H2","0x$1")).$nailara_fg.' ' }ge;
    $Text::Wrap::columns = $w;
    print STDERR "$nailara_fg\r" . wrap( '  ', '  ', $err ) . "\r$blacklight\n";
};

$| = 1;
input_complaint() and exit if !@ARGV;
( my $input_num = join( '', @ARGV ) ) =~ s|\D+||g;
input_complaint() and exit if !length($input_num);

my $U = $mode{'d'} // $base_size;
$mode{'C'} //= $base_table if not defined $mode{'U'};
my $C = $mode{'C'} // "UTF-$U";

if ( not $mode{'Q'} ) {
    print $nailara_fg . ":\n" . $result_prefix if not $mode{'S'};
    print $nailara_bg . $blacklight;
}

## randomized selection ##
if ( $C eq 'R' ) {
    my @select_from = utf8_supported_charset;
    my $fortuna     = Crypt::PRNG::Fortuna->new( scalar elf($input_num) );
    my $index       = $fortuna->irand;
    while ( $index >= scalar @select_from ) {
        $index = int( $index * 0.7 ) % scalar @select_from;
    }
    $C = $select_from[$index];
}
##

$C = ':raw' if $C eq 'raw' or $C eq 'r';
say ":\n:: ${error_color}character set '$C' not supported\n" . color('reset')
    and exit(4)
    if $C ne ':raw'
    and $C !~ m|^UTF-\d{1,2}|
    and $C ne 'BASE32'
    and not utf8_supported_charset($C);

my $encoding      = $C =~ m{^:|^BASE32$} ? $C : sprintf(":encoding($C)");
my $encoding_mode = 'native';

if ( $C ne 'BASE32' and not utf8_supported_charset($C) ) {
## testing ##
    no warnings;
    eval 'use warnings FATAL => "all"; binmode( STDOUT, $encoding )';
    use warnings;
    binmode( STDOUT, ":raw" )
        and say "   $blacklight<< encoding"
        . " [${error_color}'$encoding'$blacklight]"
        . " not found >>  $nailara_fg\n:"
        . color('reset')
        and exit
        if $EVAL_ERROR;
## applying ##
    binmode( STDOUT, $encoding );
} elsif ( $C ne 'BASE32' ) {
    $encoding_mode = 'map';
}

my $c_mode = $mode{'d'} // 1;
$c_mode = 2 if $mode{'d'} !~ m|^\d+$|;
my $delay = $mode{'s'} // 0.07;
$delay = 0 if $mode{'S'};

$mode{'r'} //= 2.42 if $mode{'S'};
my $repeat = $mode{'r'} // 0;
$repeat ||= 1;

$screen_chars *= $repeat if defined $mode{'r'};

if ( $mode{'q'} ) {
    no warnings;
}
my $num_buffer;
my $last_char      = '';
my $char_buffer    = '';
my $input_num_copy = $input_num;
while ( $mode{'S'} and length( $char_buffer // '' ) < $screen_chars
    or !$mode{'S'} and $repeat-- ) {
    while ( length($input_num) > 1 ) {
        my $c_count = $c_mode;
        if ( $c_mode < 2 ) {
            $c_count = 3;
            $c_count = 2
                if length($input_num) == 2
                or $input_num =~ m|^(\d{$c_count})| and $MATCH > 255;
        }
        $c_count = length($input_num) if $c_count > length($input_num);
        printf "%s <%02d:%03d> %s", $nailara_fg, $c_count, $MATCH, $blacklight
            if $mode{'v'};

        last if $c_count < 2;

        my $c_num = $MATCH if $input_num =~ s|^\d{$c_count}||;
        $c_num = 32 if not defined $c_num or $c_num < 32;
        $num_buffer .= $c_num;

        next if $C eq 'BASE32';    ## encode numericals as received ##

        my $char = chr($c_num);
        $char = to_utf8( { -string => pack( 'U', $c_num ), -charset => $C } )
            if $encoding_mode eq 'map';

        $char_buffer .= $char;

        next if $skip_repeat_spaces and $char =~ m|\s| and $char =~ m|\s|;
        ## hightlight ##
        $char = $green . $char . $blacklight
            if $mode{'h'}
            and ( exists $highlight->{$c_num} or @highlight_chars ~~ $char );
        ##
        print $char and sleep $delay if $delay and $C ne 'BASE32';
        $last_char = $char;
    }

    last if length($char_buffer) == 0;
    $input_num = $input_num_copy;
}

########################################
binmode( STDOUT, ":raw" );
########################################

if ( $C eq 'BASE32' ) {    ## special 'character set' BASE32 [ encoding ]
    my $char_buffer = encode_b32r($input_num_copy);
    my $char_length = length($char_buffer);
    my $pad_len     = 8 - $char_length % 8;
    while ( $pad_len > 7 ) { $pad_len -= 8 }
    $char_buffer .= 'A' x $pad_len;

    print $char_buffer;

} elsif ( defined $char_buffer ) {

} elsif ( $mode{'B'} ) {    ## not working .., ## change ., ##
    ## [ experiments ]
    # $char_buffer = Encode::decode( 'UTF-7', $char_buffer );
    # $char_buffer =~ s|$B32||g;
    # $char_buffer = decode_b32r($char_buffer);
}

print $char_buffer if defined $char_buffer and !$delay;

##############################################
say ' ' . color('reset') . $nailara_fg . "\n:"
    if not $mode{'S'} and not $mode{'Q'};
##############################################
if ( $mode{'e'} ) {

    my $char_desc = " .:[ $green$C$nailara_fg ]:. ";
    my $cd_len    = length($char_desc) - length( $error_color . $nailara_fg );
    print "\r$nailara_fg$char_desc";

    if ( $mode{'S'} ) {
        ## print substr( $char_buffer, 0, $x - $cd_len )."\n"; ## <-- repair ..,
    } else {

        say "\n " . ':' x ( $cd_len - 2 );
        say "\n..,";
    }
    print $blacklight if not $mode{'Q'};

}
print color('reset') if not $mode{'Q'};

my $wait = <STDIN> if $mode{'S'} and not defined $mode{'s'};

sub input_complaint { say ":\n:: numerical input expected\n" }

# ______________________________________________________________________________
#\\YXJASLBX5BZP7OQMGZOJSSUM5RJWSCUWFF2VMGVZJU7RUJPNFZYQ4LEVO6X5FKZLX5SZY7J44BMZI
# \\ IZNNC2EULCD2X5QM6BJ72XB2GYNJA7YZEH7CIUH4FIYFDMEWDYIL \\// C25519-BASE-32 //
#  \\// 4WC4IQDV7NP6GG35HD5EADNFFGZDMV3PQ2332UN2WXGGV3DLGAQ \\ CODE SIGNATURE \\
#   ````````````````````````````````````````````````````````````````````````````
