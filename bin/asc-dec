#!/usr/bin/perl
use v5.24;
use strict;
use English;
use warnings;
use Term::Size;
use Getopt::Std;
use Term::ANSIColor;
use Digest::Elf qw| elf |;
use Crypt::PRNG::Fortuna;
use Text::Wrap qw| wrap |;
use Time::HiRes qw| sleep |;
use Unicode::MapUTF8 qw| to_utf8 from_utf8 utf8_supported_charset |;

use Crypt::Misc qw| encode_b32r decode_b32r |;
no warnings 'experimental';

my $base_size  = '6';
my $base_table = 'cp10007';

my $skip_repeat_spaces = 1;

my @highlight_chars = qw| ℍ ᔈ 5 .٫ ܳ L = ≠ ≤ т † Ҭ T Т ∞ • |;    #  ℍ === 8461

my $highlight = { map { unpack( "%U", $ARG ) => 1 } @highlight_chars };

map { $highlight->{$ARG} = 1 } qw| 7692 1538 |;                  # Ḍ ؂

( my $x, my $y ) = Term::Size::chars;
getopts( 'hBSvs:r:eqd:C:U:', \my %mode );

$x //= 80;
$y //= 25;

my $screen_chars = $y * $x;

# say " $x x $y == $screen_chars" and sleep 1.2 and exit;

$skip_repeat_spaces = 0 if $mode{'S'};

my $B32         = qr|[A-Z2-7]+|o;
my $nailara_bg  = color('on_r09g05b41');
my $nailara_fg  = color('r38g46b153');
my $error_color = color('r195g71b6');
my $blacklight  = color('r68g39b172');
my $green       = color('r71g195b6');

# my $blacklight  = color('r71g195b6'); ## <-- AMOS-green

$SIG{'__WARN__'} = sub {
    my $err = shift;
    return if lc($err) =~ m|^wide character| or $mode{'q'};
    my $w = 44;
    $err =~ s{ at .+$|\n+}{}g;
    $err =~ s{[0\\]x(\S\S)}
    { $w+=-3+length("$nailara_fg");
    $blacklight.sprintf(":.%03d.:",unpack("H2","0x$1")).$nailara_fg.' ' }ge;
    $Text::Wrap::columns = $w;
    print STDERR "$nailara_fg\r" . wrap( '  ', '  ', $err ) . "\r$blacklight\n";
};

$| = 1;
exit if !@ARGV;
( my $input_num = join( '', @ARGV ) ) =~ s|\D+||g;
exit if !length($input_num);

my $U = $mode{'d'} // $base_size;
$mode{'C'} //= $base_table if not defined $mode{'U'};
my $C = $mode{'C'} // "UTF-$U";

print $nailara_fg . ":\n    " if not $mode{'S'};
print $nailara_bg . $blacklight;

## randomized selection ##
if ( $C eq 'R' ) {
    my @select_from = utf8_supported_charset;
    my $fortuna     = Crypt::PRNG::Fortuna->new( scalar elf($input_num) );
    my $index       = $fortuna->irand;
    while ( $index >= scalar @select_from ) {
        $index = int( $index * 0.7 ) % scalar @select_from;
    }
    $C = $select_from[$index];
}
##

$C = ':raw' if $C eq 'raw' or $C eq 'r';
say ":\n:: ${error_color}character set '$C' not supported\n" . color('reset')
    and exit(4)
    if $C ne ':raw'
    and $C !~ m|^UTF-\d{1,2}|
    and not utf8_supported_charset($C);

my $encoding      = $C =~ m|^:| ? $C : sprintf(":encoding($C)");
my $encoding_mode = 'native';

if ( not utf8_supported_charset($C) ) {
## testing ##
    no warnings;
    eval 'use warnings FATAL => "all"; binmode( STDOUT, $encoding )';
    use warnings;
    binmode( STDOUT, ":raw" )
        and say "   $blacklight<< encoding"
        . " [${error_color}'$encoding'$blacklight]"
        . " not found >>  $nailara_fg\n:"
        . color('reset')
        and exit
        if $EVAL_ERROR;
## applying ##
    binmode( STDOUT, $encoding );
} else {
    $encoding_mode = 'map';
}

my $c_mode = $mode{'d'} // 3;
my $delay  = $mode{'s'} // 0.07;
$delay = 0 if $mode{'S'};

$mode{'r'} //= 2.42 if $mode{'S'};
my $repeat = $mode{'r'} // 0;
$repeat ||= 1;

$screen_chars *= $repeat if defined $mode{'r'};

if ( $mode{'q'} ) {
    no warnings;
}
my $num_buffer;
my $last_char      = '';
my $char_buffer    = '';
my $input_num_copy = $input_num;
while ( $mode{'S'} and length( $char_buffer // '' ) < $screen_chars
    or !$mode{'S'} and $repeat-- ) {
    while ( length($input_num) > 1 ) {
        my $c_count = $c_mode;
        if ( $c_mode < 2 ) {
            $c_count = 3;
            $c_count = 2
                if length($input_num) == 2
                or $input_num =~ m|^(\d{$c_count})| and $MATCH > 255;
        }
        $c_count = length($input_num) if $c_count > length($input_num);
        printf "%s <%02d:%03d> %s", $nailara_fg, $c_count, $MATCH, $blacklight
            if $mode{'v'};

        last if $c_count < 2;

        my $c_num = $MATCH if $input_num =~ s|^\d{$c_count}||;

        $c_num = 32 if $c_num < 32;

        my $char = chr($c_num);

        $num_buffer .= $c_num;

        $char = to_utf8( { -string => pack( 'U', $c_num ), -charset => $C } )
            if $encoding_mode eq 'map';

        $char_buffer .= $char;

        next if $skip_repeat_spaces and $char =~ m|\s| and $char =~ m|\s|;

        $char = $green . $char . $blacklight
            if $mode{'h'}
            and ( exists $highlight->{$c_num} or @highlight_chars ~~ $char );
        print $char and sleep $delay if $delay;

        $last_char = $char;
    }

    last if length($char_buffer) == 0;
    $input_num = $input_num_copy;
}

if ( defined $char_buffer ) {
    if ( $mode{'B'} ) {    ## not working .., ## change ., ##

        #        $char_buffer = Encode::decode( 'UTF-7', $char_buffer );
        #        $char_buffer =~ s|$B32||g;
        # $char_buffer = decode_b32r($char_buffer);
    }
    print $char_buffer if defined $char_buffer and !$delay;
}

binmode( STDOUT, ":raw" );

say ' ' . color('reset') . $nailara_fg . "\n:" if not $mode{'S'};

if ( $mode{'e'} ) {

    my $char_desc = " .:[ $green$C$nailara_fg ]:. ";
    my $cd_len    = length($char_desc) - length( $error_color . $nailara_fg );
    print "\r$nailara_fg$char_desc";

    if ( $mode{'S'} ) {

#        print substr( $char_buffer, 0, $x - $cd_len ) . "\n"; ## <-- repair ..,
    } else {

        say "\n " . ':' x ( $cd_len - 2 );
        say "\n..,";
    }
    print $blacklight;

}
print color('reset');

my $wait = <STDIN> if $mode{'S'} and not defined $mode{'s'};

# ______________________________________________________________________________
#\\I7USIP3WYNBJJWCG5RMVXVJRESR4FS76WYIGBAT5U32UVQHB6PBIDQ6PGKXCGI65SGN5GW4KE5IKW
# \\ QRRTOO2P3LRAHNYEBA3BH4HHQSWVQT67BECAY4QTSLIRFNSYNWJU \\// C25519-BASE-32 //
#  \\// C55EZISWBNYPR7WT6JIHMTQBGP6MUDLKLWBJMI4CUSBWJ6NSMBQ \\ CODE SIGNATURE \\
#   ````````````````````````````````````````````````````````````````````````````
