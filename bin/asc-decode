#!/usr/bin/perl
use v5.24;
use strict;
use English;
use warnings;
use Term::Size;
use Getopt::Std;
use Term::ANSIColor;
use Digest::Elf qw| elf |;
use Crypt::PRNG::Fortuna;
use Text::Wrap qw| wrap |;
use Time::HiRes qw| sleep |;
use Unicode::MapUTF8 qw| to_utf8 from_utf8 utf8_supported_charset |;

( my $x, my $y ) = Term::Size::chars;
getopts( 'BSvs:r:equ:C:U:', \my %mode );

my $screen_chars = $y * $x;

# say " $x x $y == $screen_chars" and sleep 1.2 and exit;

my $B32         = qr|[A-Z2-7]+|o;
my $nailara_bg  = color('on_r09g05b41');
my $nailara_fg  = color('r38g46b153');
my $amos_color  = color('r71g195b6');
my $error_color = color('r195g71b6');

$SIG{'__WARN__'} = sub {
    my $err = shift;
    return if lc($err) =~ m|^wide character| or $mode{'q'};
    my $w = 44;
    $err =~ s{ at .+$|\n+}{}g;
    $err =~ s{[0\\]x(\S\S)}
    { $w+=-3+length("$nailara_fg");
    $amos_color.sprintf(":.%03d.:",unpack("H2","0x$1")).$nailara_fg.' ' }ge;
    $Text::Wrap::columns = $w;
    print STDERR "$nailara_fg\r" . wrap( '  ', '  ', $err ) . "\r$amos_color\n";
};

$| = 1;
exit if !@ARGV;
( my $input_num = join( '', @ARGV ) ) =~ s|\D+||g;
exit if !length($input_num);

my $U = $mode{'U'} // '8';

print $nailara_fg . ":\n    " if not $mode{'S'};
print $nailara_bg . $amos_color;

my $C = $mode{'C'} // "UTF-$U";

## randomized selection ##
if ( $C eq 'R' ) {
    my @select_from = utf8_supported_charset;
    my $fortuna     = Crypt::PRNG::Fortuna->new( scalar elf($input_num) );
    my $index       = $fortuna->irand;
    while ( $index >= scalar @select_from ) {
        $index = int( $index * 0.7 ) % scalar @select_from;
    }
    $C = $select_from[$index];
}
##

$C = ':raw' if $C eq 'raw' or $C eq 'r';
say ":\n:: ${error_color}character set '$C' not supported\n" . color('reset')
    and exit(4)
    if $C ne ':raw'
    and $C !~ m|^UTF-\d{1,2}|
    and not utf8_supported_charset($C);

my $encoding      = $C =~ m|^:| ? $C : sprintf(":encoding($C)");
my $encoding_mode = 'native';

if ( not utf8_supported_charset($C) ) {
## testing ##
    no warnings;
    eval 'use warnings FATAL => "all"; binmode( STDOUT, $encoding )';
    use warnings;
    binmode( STDOUT, ":raw" )
        and say "   $amos_color<< encoding"
        . " [${error_color}'$encoding'$amos_color]"
        . " not found >>  $nailara_fg\n:"
        . color('reset')
        and exit
        if $EVAL_ERROR;
## applying ##
    binmode( STDOUT, $encoding );
} else {
    $encoding_mode = 'map';
}

my $c_mode = $mode{'u'} // 4;
my $delay  = $mode{'s'} // 0.13;
$delay = 0 if $mode{'S'};

my $repeat = $mode{'r'} // $MATCH if $input_num =~ m|^\d|;
$repeat ||= 1;

$screen_chars *= $repeat if defined $mode{'r'};

if ( $mode{'q'} ) {
    no warnings;
}
my $num_buffer;
my $char_buffer    = '';
my $input_num_copy = $input_num;
while ( $mode{'S'} and length( $char_buffer // '' ) < $screen_chars
    or !$mode{'S'} and $repeat-- ) {
    my $old_len = length($char_buffer);
    while ( length($input_num) > 1 ) {
        my $c_count = $c_mode;
        if ( $c_mode < 2 ) {
            $c_count = 3;
            $c_count = 2
                if length($input_num) == 2
                or $input_num =~ m|^(\d{$c_count})| and $MATCH > 255;
        }
        $c_count = length($input_num) if $c_count > length($input_num);
        printf "%s <%02d:%03d> %s", $nailara_fg, $c_count, $MATCH, $amos_color
            if $mode{'v'};

        last if $c_count < 2;

        my $c_num = $MATCH if $input_num =~ s|^\d{$c_count}||;

        $c_num = 32 if $c_num < 32;

        my $char = chr($c_num);

        next if $mode{'B'} and $char !~ $B32;

        $num_buffer .= $c_num;

        $char = to_utf8( { -string => chr($c_num), -charset => $C } )
            if $encoding_mode eq 'map';

        if ($delay) {
            print $char and sleep $delay;
        } else {
            $char_buffer .= $char;
        }
    }
    last if $old_len == length($char_buffer);
    $input_num = $input_num_copy;
}

if ( defined $char_buffer ) {

    $char_buffer = ' < U7 > ' . Encode::decode( 'UTF-7', $char_buffer )
        if $mode{'B'};

    print $char_buffer if defined $char_buffer;
}

binmode( STDOUT, ":raw" );

say ' ' . color('reset') . $nailara_fg . "\n:" if not $mode{'S'};
if ( $mode{'e'} ) {
    my $char_desc = " .:[ $error_color$C$nailara_fg ]:. ";
    print "\r$nailara_fg$char_desc$amos_color";
    print substr( $char_buffer, 0, $x - length($char_desc) ) . "\r"
        if $mode{'S'};
}
print color('reset');

my $wait = <STDIN> if $mode{'S'} and not defined $mode{'s'};

# ______________________________________________________________________________
#\\JPDURKJC2ZGWX5JCUQNQQR5X4UFESZUZ5JUHZESGIKQWOTVPHLVKGJ52DKXMX5HLAXMFCSHY7ZJ6G
# \\ XF4DU3RTQORO3KDG422776DLYNFJRRCCWPBIMVEBTLKXPNBOD5HX \\// C25519-BASE-32 //
#  \\// K5EKP5ZDLZKPWXRCFYQ7OWHHT65W5RTXQDDJBAZMR6FH7XVCKAA \\ CODE SIGNATURE \\
#   ````````````````````````````````````````````````````````````````````````````
