#!/usr/bin/perl

use utf8;
use strict;
use v5.28.0;
use English;
use warnings;

# globals
our %code;
our %data;
our %keys;
our %colors;
our @INDEXCUBE;
our %p7_subroutines;

p7_load_time_hires();
p7_load_perl_modules();

##[ global constants ]##
use constant TRUE  => 5;    ##  TRUE.  ##
use constant FALSE => 0;    ##  false  ##

# is protocol 7 code? #
our $PROTOCOL_SEVEN = TRUE;    ##  TRUE  ##
##

##  setting input \ output streams and file open to UTF-8 default  ##
use open qw| :encoding(UTF-8) |;    ##  affecting all open calls  ##
map { binmode( $ARG, qw| :encoding(UTF-8) | ) } ( *STDIN, *STDOUT, *STDERR );

p7_import_main_subroutines();   ##  importing p7_<subname> into %code hash  ##
p7_load_inline_subroutines();   ## load subroutine code from DATA block ##

p7_init_exec();                 ##  main variable initialization  ##

p7_load_code(qw| base |);       ## loading remaining base module routines ##

###                                               ###
##  additional initializations and zenka start-up  ##
##                                                 ##

my $zenkaname;
$data{'system'}{'start'}{'program_name'} = $PROGRAM_NAME;
if ( $PROGRAM_NAME =~ m|^.*Protocol-7\.|i ) {
    $zenkaname = lc $PROGRAM_NAME;
    $zenkaname =~ s|^.*protocol-7\.||ig;
} elsif ( defined $ARGV[0] and $ARGV[0] =~ m|^([^\-].*)| ) {
    $zenkaname = $LAST_PAREN_MATCH;
    shift @ARGV;
}

( $zenkaname, @ARGV ) = ( split( m| +|, $zenkaname ), @ARGV )
    if defined $zenkaname and index( $zenkaname, ' ' ) != -1;

$SIG{'INT'} = $code{'base.sig_int'} if defined $code{'base.sig_int'};

##  remove known parameters from <system.args>  ##
$data{'system'}{'args'} = join( ' ', @ARGV ) // '';
$data{'system'}{'args'} =~ s,(^| +)\-[v]+h?z?d?( +|$), ,g;
$data{'system'}{'args'} =~ s,(^\s+|\s+$),,g;

if ( defined $zenkaname and length $zenkaname ) {

    if ( $data{'system'}{'start-up'}{'stdin'}{'read-init-code'} ) {
        $data{'zenka'}{'start-up'}{'init_code'} = [];
        $code{'log.noerr'}->('< awaiting init-code on stdin');

        my $lines
            = scalar( $data{'zenka'}{'start-up'}{'init_code'}->@* = <STDIN> );

        $code{'base.logs'}->(
            '> read %d line%s of init-code',
            $lines, $code{'base.cnt_s'}->($lines)
        );
    }
    my $node_name = $data{'system'}{'node'}{'name'};

    $code{'base.init'}->( sprintf qw| %s.%s |, $node_name, $zenkaname );

} else {

    ## need to skip DATA block here for zenka config reading ##

    ## becomes obsolete with load_inline_subroutines ##
    ##
    ## if ( $PROGRAM_NAME eq qw| - | and tell(STDIN) ) {
    ##     foreach my $errmsg (
    ##         'skipping DATA block in STDIN-mode is not implemented',
    ##         ':. need zenka name parameter to initialize ..,'
    ##     ) {
    ##         $code{'log.error'}->($errmsg);
    ##     }
    ##     $code{'base.exit'}->('0110');
    ## }

    if ( @ARGV == 0 or not defined $data{'system'}{'zenka'}{'name'} ) {
        $data{'system'}{'zenka'}{'name'} = qw| <stdin> |;
    }

    $RS           = "\n";
    $PROGRAM_NAME = sprintf qw| Protocol-7.%s |,
        $data{'system'}{'zenka'}{'name'};

    ##  checking if already available [ for log level ]  ##
    *STDIN{IO}->blocking(0);
    my $first_line = <STDIN>;
    *STDIN{IO}->blocking(1);

    my $stdin_config_log_level;
    if ( not defined $first_line ) {
        my $reminder_log_level = $data{'system'}{'verbosity'}{'console'};

        $SIG{'ALRM'} = sub {
            alarm 0;
            undef $SIG{'ALRM'};
            $code{'base.log'}->(
                $reminder_log_level,
                '.. expecting zenka start description from < STDIN > .,'
            );
        };
        my $warning_delay = $reminder_log_level ? 4 : 13;
        $warning_delay          = 1 if $reminder_log_level > 1;
        $stdin_config_log_level = 1;
        alarm($warning_delay);

    } else {    ##  with already present zenka description  ##
        $stdin_config_log_level = 2;
        $code{'base.log'}->(
            $stdin_config_log_level,
            ':. reading zenka start description from < STDIN >'
        );
    }

READ_STDIN_CONFIGURATION:
    my @zenka_code = <STDIN>;
    alarm 0;    ##  stopping timer for read reminder  ##
    unshift @zenka_code, $first_line if defined $first_line;
    undef $first_line;

    my $zenka_lines = scalar @zenka_code;
    if ($zenka_lines) {
        $code{'base.logs'}->(
            $stdin_config_log_level,
            ':  :. zenka cfg reading completed. [ %d line%s ].,',
            $zenka_lines, $zenka_lines == 1 ? '' : 's'
        );
    } else {
        $code{'log.error'}->(':: STDIN closed and no configuration read..,');
    }

    if ( $data{'system'}{'background_mode'} ) {    ## backgrounding parent ##
        use warnings qw| FATAL |;

        #        eval '$code{base.process-into-background}->()';
        $code{'base.exit'}->(
            ':: exit :: cannot background zenka process ::',
            0, qw| 0110 |
        ) if length $EVAL_ERROR;
    }

    if (@zenka_code) {
        $data{'base'}{'config_parser'}{'cfg_type'}  = qw| start_cfg |;
        $data{'base'}{'config_parser'}{'cfg_name'}  = qw| zenka |;
        $data{'base'}{'config_parser'}{'cfg_descr'} = qw| <STDIN> |;
        $code{'base.execute_zenka_code'}
            ->( $code{'base.parser.config'}->( \@zenka_code ) );
    }
}

$code{'log.noerr'}->(qw|  done. |);
close;
exit;

##                          ##
##  early used subroutines  ##
##                          ##

##############################################################################

sub p7_import_main_subroutines {    ##  making subroutines P7 available  ##

    foreach my $subname ( p7_scan_main_subroutines()->@* ) {
        my $code_subname = $subname;
        if ( $code_subname !~ s|^p7__||g ) {    ## special syntax ##
            $code_subname =~ s|^p7_|base.|;     ## otherwise base. prefix ##
        }
        $code_subname =~ s|__|\.|g;             ## special syntax ##

        ## copying into protocol-7 code hash ##
        $code{$code_subname} = $p7_subroutines{$subname};

        $data{'p7_subroutine'}{$code_subname} = {    ## updating registry ##
            qw| installed | => $code{'base.time'}->(7),
            qw|  sub-cref | => $code{$code_subname}
        };

        ## old registry namespace [ becomes redundant ] ##
        $data{'base'}{'core_subs'}{$code_subname} = $code{$code_subname};
        $data{'code'}{$code_subname}{'status'} = qw| core-sub |;

    }
}

##############################################################################

sub p7_scan_main_subroutines {

    my $prefix_pattern = shift // qw| p7_ |;
    my $result_aref    = shift;

    my $update_p7_main_subs_hash = FALSE;
    if ( not defined $result_aref and $prefix_pattern eq qw| p7_ | ) {
        $update_p7_main_subs_hash = TRUE;    ## true ##
    }
    $result_aref //= [];
    my @symbol_names                         ## collect all symbol names ##
        = sort { length $a <=> length $b } reverse sort keys %main::;
    $result_aref->@*    ## filter subroutine names [ maim:: and prefix ] ##
        = grep { index( $ARG, $prefix_pattern, 0 ) == 0 }
        grep { defined &{ sprintf qw| main::%s |, $ARG } } @symbol_names;
    if ($update_p7_main_subs_hash) {
        %p7_subroutines = map { $ARG => \&{ sprintf qw| main::%s |, $ARG } }
            $result_aref->@*;    ## update %p7_subroutines subroutine table ##
    }
    return $result_aref;         ##  return matching sub names  ##
}

##############################################################################

sub p7_load_perl_modules { ##  load early used perl modules [ more later ]  ##

    ##  MODULES  ##

    use File::stat;
    use IO::Handle;
    use IO::Scalar;
    use Sys::Hostname;
    use Cwd qw| abs_path |;
    use Text::Wrap qw| wrap |;
    use File::Spec::Functions;
    use List::MoreUtils qw| :all |;
    use FindBin qw| $RealBin $RealScript |;

    ##  includes : S_IWUSR, S_IWGRP, S_ISFIFO  ##
    use Fcntl qw| :seek :mode :DEFAULT :flock |;

    ## MATHEMATICAL CONSTANTS ##

    use constant qw| τ |   => 6.28318530717958647692;
    use constant qw| tau | => qw| τ |;

## registering loaded modules ##

    foreach my $module ( qw[
        Cwd
        Fcntl
        FindBin
        File::stat
        Text::Wrap
        IO::Handle
        IO::Scalar;
        Sys::Hostname
        List::MoreUtils
        File::Spec::Functions
        ]
    ) {
        $data{'base'}{'perlmod'}{'loaded'}->{$module} = TRUE;    ## true ##
    }
}

##############################################################################

sub p7_load_time_hires {

    my $TH_aref;
    ## installing 'Time::HiRes' versions of 'base.time' and 'base.sleep' ##
    eval {
        use Time::HiRes;
        $TH_aref = [    ## takes floating point precision argument ##
            sub { sprintf qw| %.*f |, $ARG[0] // 7, Time::HiRes::time },
            \&Time::HiRes::sleep
        ];
    };
    if ( defined $TH_aref and ref($TH_aref) eq qw| ARRAY | ) {
        $data{'base'}{'perlmod'}{'loaded'}->{'Time::HiRes'} = 5;    ## true ##
        $data{'system'}{'perl_module'}{'installed'}{'Time::HiRes'} = 5;
    }
    $TH_aref = [ sub {&time}, sub { select( undef, undef, undef, $ARG[0] ) } ]
        if length $EVAL_ERROR    ## alternative microsecond sleep version ##
        or not defined $TH_aref
        or ref $TH_aref ne qw| ARRAY |;
    $code{'base.time'}  = \&{ $TH_aref->[0] };
    $code{'base.sleep'} = \&{ $TH_aref->[1] };
}

##############################################################################

sub p7_security_hardening {    ## SOME BASIC SECURITY HARDENING ##

    BEGIN {

        $ENV{'PATH'} = qw| /usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin |;
        delete @ENV{qw| IFS CDPATH ENV BASH_ENV |};
        $ENV{'LC_NUMERIC'} = qw| en_US.UTF-8 |;
        umask(0027);    ## <-- restricted, set manually .., ###

        ## character whitelist ##
        my $char_map = qr|([^0-9a-zA-Z\-\+\.:_\[\]\/]+)|;
        ## checking program name ##
        die "\n\n << not valid characters [ '%s' ]"
            . " in program name '%s' >>\n\n\n",
            , ${^CAPTURE}[0], $PROGRAM_NAME
            if $PROGRAM_NAME =~ $char_map;
        ##  verified clean  ##
        my $bin_path = $PROGRAM_NAME;
        ## checking program name link target ##
        while ( my $link_target = readlink($bin_path) ) {
            die sprintf "\n\n<< not valid characters [ '%s' ]"
                . " in program name link target '%s' >>\n\n\n",
                ${^CAPTURE}[0], $link_target
                if $link_target =~ $char_map;
            ##  verified clean  ##
            $bin_path = $link_target;
        }

        ## prepending local pm module pach to @INC ##

        use File::Spec;    ## ./..,/protocol-7 case .., ##
        ( my $local_lib_path = File::Spec->rel2abs($bin_path) )
            =~ s|/[^/]+/[^/]+$|/data/lib-path/pm|;

        warn sprintf ':: << local lib path not found >> : %s .:',
            $local_lib_path
            if not -d $local_lib_path;

        unshift @INC, $local_lib_path if -d $local_lib_path;
    }
}

##############################################################################

sub p7_init_exec {    ##  main variable initialization  ##

    $SIG{'INT'} = sub { print "\b\b" if fileno(STDOUT); exit };    ## ^C ##

    ## choose harmonic PID on -NP switch ##
    #
    # ISSUES : returns to shell, not working with child zenki yet ##
    #
    my $change_pid = FALSE;
    map { $change_pid = TRUE if $ARG eq qw| -NP | } @ARGV;
    &{ $code{'base.choose_true_pid'} } if $change_pid;
    #
    ##

    $SIG{'PIPE'} = qw| IGNORE |;
    ## overriding warn subroutine ###
    $SIG{'__WARN__'} = $code{'base.sig_warn'};

    ## special case when Protocol-7 code given on <STDIN> ##
    $PROGRAM_NAME = qw| Protocol-7 | if $PROGRAM_NAME eq qw| - |;

    ## early variable initialization ##
    my $actual_exec = abs_path( catfile( $RealBin, $RealScript ) );
    my $bin_path    = [ File::Spec->splitpath($actual_exec) ]->[1];
    $data{'system'}{'start'}{'true_exec'} = $actual_exec;
    $data{'system'}{'start'}{'exec_name'}    # apparent exec [symlink]
        = File::Spec->rel2abs( canonpath($PROGRAM_NAME) );
    $data{'system'}{'root_path'}
        = abs_path( catdir( $bin_path, updir() ) );
    $data{'system'}{'perl_execname'} = $EXECUTABLE_NAME;
    $data{'system'}{'perl_version'}  = $PERL_VERSION;
    $data{'system'}{'perl_unicode'}  = ${^UNICODE};
    my $root_path = $data{'system'}{'root_path'};
    $data{'system'}{'code_path'} = catdir( $root_path, qw| modules | );
    $data{'system'}{'conf_path'}
        = catdir( $root_path, qw| configuration | );
    $data{'system'}{'lmod_path'}
        = catdir( $root_path, qw| data lib-path pm | );
    delete $data{'system'}{'lmod_path'}
        if !-d $data{'system'}{'lmod_path'};
    $data{'base'}{'httpc'}{'last_mlen'}  //= 80;
    $data{'buffer'}{'zenka'}{'max_size'} //= 64 * 1024;    # 64K log-buffer

    ## source code version ##
    my $version_file
        = catfile( $data{'system'}{'conf_path'}, qw|protocol-7.src-ver| );

    $data{'protocol-7'}{'src-ver'}
        = $code{'base.read_from_version_file'}->($version_file);

    ## source code release version ##
    my $release_file
        = catfile( $data{'system'}{'conf_path'}, qw|protocol-7.rel-ver| );

    $data{'protocol-7'}{'rel-ver'}
        = $code{'base.read_from_version_file'}->($release_file);

    ## determine zenka name and subname ###
    if ( $PROGRAM_NAME =~ m|^.*Protocol-7\.| ) {
        $data{'system'}{'zenka'}{'initialized'} = FALSE;
        $data{'system'}{'zenka'}{'name'}        = lc($PROGRAM_NAME);
        $data{'system'}{'zenka'}{'name'} =~ s,^.*protocol-7\.|[\. ]$,,g;
    } elsif ( defined $ARGV[0] and $ARGV[0] =~ m|^([^\-].*)| ) {
        my $zenka_name = $LAST_PAREN_MATCH;
        $data{'system'}{'zenka'}{'subname'} = ${^CAPTURE}[0]
            if $zenka_name =~ s|\[([^\]]+)\]$||;
        $data{'system'}{'zenka'}{'name'} = $zenka_name;
    }
    if ( not defined $data{'system'}{'zenka'}{'name'}
        or $data{'system'}{'zenka'}{'name'} eq '' ) {
        $data{'system'}{'zenka'}{'name'} = qw| <init> |;
    }

    $data{'system'}{'node'}{'name'} = hostname() // qw| protocol-7 |;
    $data{'system'}{'node'}{'name'} =~ s|\..+$||;

    #   ( $data{'system'}{'node'}{'name'},
    #    $data{'system'}{'zenka'}{'name'} ) = split ( m|\.|, $_[0] ); #[LLL]

    ## early verbosity settings ###
    $data{'system'}{'verbosity'}{'console'}       = 0;
    $data{'system'}{'verbosity'}{'zenka_buffer'}  = 1;
    $data{'system'}{'verbosity'}{'zenka_logfile'} = 0;

    $data{'system'}{'ansi_color'} = TRUE;
    $data{'system'}{'start'}{'showbanner'} = TRUE;

    my $stdin_mode = 1;
    ## process command line arguments ###
    $data{'system'}{'console-mode'} //= FALSE;
    foreach my $arg (@ARGV) {
        $stdin_mode = 0 if $arg =~ m|^[^\-]|;
        if ( $arg =~ m|^-(v+)(h?z?d?)?$| ) {
            $data{'system'}{'verbosity'}{'console'}
                = length( ${^CAPTURE}[0] );
            my $vis       = ${^CAPTURE}[1] // '';
            my $visualize = $data{'base'}{'harmony'}{'visualize'} //= {
                qw| enabled |    => FALSE,    ## overall ##
                qw| zulum |      => FALSE,    ## show 0 ##
                qw| harmony |    => FALSE,    ## 538461 ##
                qw| disharmony | => FALSE     ## 076923 ##
            };
            $visualize->{'enabled'} = TRUE if $vis =~ m|[hzd]|;    ## true ##
            if ( $visualize->{'enabled'} ) {
                $visualize->{'harmony'}    = TRUE if $vis =~ m|h|;  ## true ##
                $visualize->{'zulum'}      = TRUE if $vis =~ m|z|;  ## true ##
                $visualize->{'disharmony'} = TRUE if $vis =~ m|d|;  ## true ##
            }
        }

        if ( $arg =~ qw| -B(K?) | ) {    ##  -BK == keep output open  ##
            $data{'system'}{'background'}{'redirect_output'} = FALSE
                if length $LAST_PAREN_MATCH;
            $data{'system'}{'background_mode'} = TRUE;    ## true ##
        }
        if ( $arg eq qw| -stdin | ) {
            $data{'system'}{'start-up'}{'stdin'}{'read-init-code'} = TRUE;
            $data{'system'}{'console-mode'} = FALSE;   ## LLL: more conditions
        }
        if ( $arg eq qw| -console | ) {
            $data{'system'}{'console-mode'} = TRUE;    ## true ##
            $code{'log.error'}->('<< in console mode >>');
        }
        if ( $arg eq qw| -c | ) {
            $data{'system'}{'ansi_color'}   = TRUE;    ## true ##
            $data{'system'}{'force-colors'} = TRUE;    ## true ##
        }
        if ( $arg eq qw| -nc | ) {
            $data{'system'}{'ansi_color'}   = FALSE;
            $data{'system'}{'force-colors'} = FALSE;
        }
        if ( $arg eq qw| -nb | ) {
            $data{'system'}{'start'}{'showbanner'} = FALSE;
        }
        if ( $arg =~ m|^-N(.+)$| ) {
            $data{'system'}{'zenka'}{'name'} = $LAST_PAREN_MATCH;
        } elsif ($stdin_mode) {
            $data{'system'}{'zenka'}{'name'} = qw| <stdin> |;
        }
        if ( $arg =~ m|^-lpw=(\d{1,2})$| ) {    # <-- used by 'p7' zenka
            $data{'system'}{'zenka'}{'log_prefix_width'} = ${^CAPTURE}[0];
        }
        if ( $arg eq qw| -use-http-src | ) {
            $data{'system'}{'use_http_source'} = FALSE;    ## true ##
        }
        if ( $arg eq qw| -export-core-subs | ) {
            $code{'dump_core_subs'}->();
            exit(0);
        }
    }

    ## setting log prefix width values \ defaults ##
    $data{'system'}{'start'}{'log_prefix_width'}
        = &{ $code{'base.get_start_lpw'} };
    $data{'system'}{'zenka'}{'log_prefix_width'}
        //= $data{'system'}{'start'}{'log_prefix_width'};

    ### load zenka code from stdin ###
    $data{'system'}{'path'}{'rel'}{'cur_zenka_cfg'} = qw| <STDIN> |
        if $stdin_mode;

    ## prepare zenka name column width and color mode pipe override ###
    if ( not defined $code{'base.term.size'}->(*STDIN) ) {
        $data{'system'}{'term'}{'piped'}{'stdin'} = TRUE;    ## true ##
    } else {
        $data{'system'}{'term'}{'piped'}{'stdin'} = FALSE;
    }
    if ( not defined $code{'base.term.size'}->(*STDOUT) ) {
        $data{'system'}{'term'}{'piped'}{'stdout'} = TRUE;    ## true ##
    } else {
        $data{'system'}{'term'}{'piped'}{'stdout'} = FALSE;
    }
    if ( not defined $code{'base.term.size'}->(*STDERR) ) {
        $data{'system'}{'term'}{'piped'}{'stderr'} = TRUE;    ## true ##
    } else {
        $data{'system'}{'term'}{'piped'}{'stderr'} = FALSE;
    }
    ##
    map {
        if ( $data{'system'}{'term'}{'piped'}{$ARG} ) {
            $data{'system'}{'term'}{'colors'}{$ARG}
                = $data{'system'}{'ansi_color'}
                = $data{'system'}{'force-colors'} // FALSE;
        } else {
            $data{'system'}{'term'}{'colors'}{$ARG}
                = $data{'system'}{'ansi_color'} // TRUE;    ## true ##
        }
    } qw| stdout stderr |;
    $data{'system'}{'ansi_color'} //= TRUE;                 ## true ##
    ##

    $data{'base'}{'timestamp-count'}      //= {};
    $data{'base'}{'retry-limits-reached'} //= {};

    ## defining console ansi colors ###
    if ( $data{'system'}{'ansi_color'} ) {
        %colors = (
            qw| B00 |      => "\e[48;2;0;0;17m",
            qw| B01 |      => "\e[48;2;9;5;24m",
            qw| B02 |      => "\e[48;2;9;5;42m",
            'p7_fg_0000'   => "\e[38;2;68;39;172m",
            'p7_fg_0001'   => "\e[38;2;38;46;153m",
            'p7_fg_0002'   => "\e[38;2;197;141;7m",
            'p7_fg_0003'   => "\e[38;2;71;185;6m",
            'p7_fg_0004'   => "\e[38;2;6;71;195m",
            'bold'         => "\e[1m",
            'reset'        => "\e[0m",
            'clear_screen' => "\e[H\c[[2J"
        );
    } else {
        %colors = (
            qw| B00 |      => '',
            qw| B01 |      => '',
            qw| B02 |      => '',
            'p7_fg_0000'   => '',
            'p7_fg_0001'   => '',
            'p7_fg_0002'   => '',
            'p7_fg_0003'   => '',
            'p7_fg_0004'   => '',
            'bold'         => '',
            'reset'        => '',
            'clear_screen' => "\c[[H\c[[2J"
        );
    }
    ## prepare for stripping ansi from output ##
    $data{'base'}{'ansi_re'} = join(
        '|',
        map { ( my $A = $colors{$ARG} ) =~ s|^\e(.+)$|\\e\Q$1\E|; $A }   # \1?
            keys %colors
    );
    ## initializing console output ##
    print STDERR $colors{'p7_fg_0002'};

    my $start_string = qw| \\ |;
    ## nailara start-up banner ##
    {
        my $prefix = '';
        ( my $x, my $y ) = $code{'base.term.size'}->();
        my ( $x_offset, $y_offset, $s_x, $s_y ) = ( 0, 0, 0, 0 );
        my $show_banner_mode = FALSE;
        my $center_xy        = 0;
        if ( map {m,(^| )-show-banner( |$),} @ARGV ) {
            $show_banner_mode = 1;
            $center_xy        = 1 if map {m,(^| )-center( |$),} @ARGV;
            ( $x, $y ) = @{^CAPTURE}
                if map {m,(^| )-size=(\d+)x(\d+)( |$),} @ARGV;
            if ($center_xy) {
                ## center-y ##
                $y_offset += $y > 7 ? int( ( $y - 8 ) / 2 ) : 0;
                print "\n" x $y_offset;
                ## center-x ##
                my $x_offset += $x > 74 ? int( ( $x - 78 ) / 2 ) : 0;
                $prefix = ' ' x $x_offset;
            }
        }
        my $spaces = '';
        if (   $data{'system'}{'verbosity'}{'console'}
            && $data{'system'}{'start'}{'showbanner'}
            or $show_banner_mode ) {
            say $prefix, $colors{'B02'}, $colors{'p7_fg_0000'},
                $start_string,
                , $colors{'B00'},
                ' ' x 77, $colors{'B02'} . $colors{'p7_fg_0000'}, qw| / |,
                $colors{'reset'};
            ## centered-xy ## ..,
            $code{'base.banner'}->($prefix);
            print "\n" x $y_offset if $show_banner_mode and $y_offset;
            exit(0)                if $show_banner_mode;
        } else {
            my $lpw = $data{'system'}{'zenka'}{'log_prefix_width'};
            $spaces = ' ' x int( 68 - $lpw );
        }
        $code{'log.noerr'}->( qw| .\\7 | . $spaces );
    }
    ## initializing early zenka buffer capture ###
    $data{'system'}{'start'}{'zenka-buffer'} = [];
    my $s_version = $data{'protocol-7'}{'src-ver'};
    my $tenki
        = length($s_version)
        > ( length( sprintf 'zenka %s', $data{'system'}{'zenka'}{'name'} ) )
        ? sprintf ' %s,',
        '.' x (
              length($s_version)
            - length( sprintf 'zenka %s', $data{'system'}{'zenka'}{'name'} )
            - 1 )
        : '';
    map { push( @{ $data{'system'}{'start'}{'zenka-buffer'} }, $ARG ) } (
        $code{'base.anum_log_time'}->()
            . sprintf(
            ' 0 . startup zenka %s%s',
            $data{'system'}{'zenka'}{'name'}, $tenki
            ),
        $code{'base.anum_log_time'}->()
            . sprintf( ' 0 . version %s', $s_version )
    );
}

##############################################################################

sub p7_term__size {

    my $handle = shift // *STDIN;    ## use *STDOUT for pipe detection ##

    return undef if not -t $handle;
    state $size       = "\0" x 8;
    state $TIOCGWINSZ = 21523;

    ioctl( $handle, $TIOCGWINSZ, $size ) or return undef;
    my $size_aref = [ unpack qw| S!S!S!S! |, $size ];

    return ( $size_aref->[1], $size_aref->[0] );
}

##############################################################################

sub p7_ntime {    # [ netw. time : secs from 2002-06-05 * 4200 ]

    my $param        = shift // 0;
    my $want_harmony = shift // $data{'base'}{'ntime-harmony'} // TRUE;
    my $ntime_start  = $data{'base'}{'ntime_ustart'} //= 1023228000;

    my $retries_left    = 24;    ## <-- configure [ retries-max ]
    my $collision_delay = 0;
    my $last_time       = 0;
    my $unix_precision  = 3;
    my $was_unix_input  = 0;
    my $ntime_precision;

    $data{'base'}{'retry-count'}{'ntime'} //= 0;
    ##  count for statistics  ##
    $data{'base'}{'timestamp-count'}{'ntime_numerical'} //= 0;
    if ( length $data{'base'}{'timestamp-count'}{'ntime_numerical'}++ > 17 ) {
        $data{'base'}{'timestamp-count'}{'ntime_numerical'}  = 1;
        $data{'base'}{'retry-limits-reached'}{'ntime_value'} = 0;
    }

    my ( $unix_time, $precision ) = ( undef, 0 );
    if ( length($param) >= 9 ) {    # < unix time + inherited precision >

        $unix_time      = $param;
        $was_unix_input = TRUE;     ## true ##

        $unix_precision = length $LAST_PAREN_MATCH
            if $unix_time =~ m{\.(\d+)$};
        $ntime_precision = $unix_precision - 2;
        $ntime_precision = 0 if $ntime_precision < 0;

    } else {

        $ntime_precision = $param;

        $ntime_precision = 8 if $ntime_precision > 8;
        $unix_precision  = $ntime_precision + 2;
        $unix_precision  = 11 if $unix_precision > 11;
    }

    $collision_delay = sprintf qw| %.*f |, $unix_precision,
        7 * ( 1 / 10**$unix_precision );

RETRY_BASE_NTIME:
    if ( not $was_unix_input ) {    ##  retry until time value is true  ##

        $last_time = $unix_time if defined $unix_time;
        $unix_time = $code{'base.time'}->($unix_precision);

        ## same input \ collision ##
        if ( $want_harmony and $unix_time == $last_time ) {
            Time::HiRes::sleep($collision_delay);
            goto RETRY_BASE_NTIME;
        }
    }

    my $ntime = sprintf qw| %.*f |, $ntime_precision // 0,
        ( $unix_time - $ntime_start ) * 4200;

    if (    $want_harmony
        and $unix_precision > 0

        and not $code{'base.assert.harmony'}->( $unix_time, 0 )
        and $retries_left--
    ) {

        if ( $was_unix_input and $unix_precision ) { ##  randomizing value  ##

            $unix_time = sprintf qw| %.*f |, $unix_precision,
                $unix_time + 1 / 10**$unix_precision;
        }

        ++$data{'base'}{'retry-count'}{'ntime'}
            and goto RETRY_BASE_NTIME;
    }

    if ( $retries_left <= 0 ) {    ##  count limit reached  ##
        $data{'base'}{'retry-limits-reached'}{'ntime_value'} //= 0;
        $data{'base'}{'retry-limits-reached'}{'ntime_value'}++;
    }

    return $ntime;
}

##############################################################################

sub p7_ntime__b32 {

    my $param        = shift // 4;    # <-- precision or utime
    my $want_harmony = shift // $data{'base'}{'ntime-harmony'} // TRUE;
    my $ntime_value;
    my $last_ntime      = 0;
    my $ntime_precision = 0;
    my $was_unix_input  = FALSE;

    ##  keeping low to visualize disharmony in system events  ##
    ##
    my $retries_left = 9;    ## <-- is exceeding occassionally  ##

    $data{'base'}{'retry-count'}{'ntime-B32'} //= 0;
    ##  count for statistics  ##
    $data{'base'}{'timestamp-count'}{'ntime_base32'} //= 0;
    if ( length $data{'base'}{'timestamp-count'}{'ntime_base32'}++ > 17 ) {
        $data{'base'}{'timestamp-count'}{'ntime_base32'}   = 1;
        $data{'base'}{'retry-limits-reached'}{'ntime-B32'} = 0;
    }

    ##  updated below  ##
    my $zulum_len       = $ntime_precision + 1;
    my $collision_delay = 0;

    $was_unix_input = TRUE if length $param >= 3;    ## true ##

RETRY_BASE_NTIME_B32:    ##  harmonizing values  ##

    $last_ntime = $ntime_value
        if $want_harmony
        and not $was_unix_input
        and defined $ntime_value
        and $ntime_value != $last_ntime;

    ####
    $ntime_value = $code{'base.ntime'}->( $param, $want_harmony );
    ####

    if ($want_harmony) {

        $ntime_precision ||= length $LAST_PAREN_MATCH
            if $ntime_value =~ m|\.(\d+)$|;

        my $unix_precision = $ntime_precision + 2;

        my $zulum_len ||= $ntime_precision + 1;
        my $collision_delay ||= 0 + sprintf qw| 0.%s113 |, '0' x $zulum_len;

        if ($was_unix_input) {    ##  randomizing value  ##

            if ( $unix_precision > 0 ) {
                $param = sprintf qw| %.*f |, $unix_precision,
                    $param + 1 / 10**$unix_precision;
            }

        } elsif ( $last_ntime == $ntime_value ) { ## same input \ collision ##
            Time::HiRes::sleep($collision_delay);
            goto RETRY_BASE_NTIME_B32;
        }
    }

    my $encoded_ntime = $code{'base.encode_ntime_to_B32'}->($ntime_value);

    ++$data{'base'}{'retry-count'}{'ntime-B32'}
        and goto RETRY_BASE_NTIME_B32
        if $want_harmony
        and length($param) < 9    # <-- precision
        and $code{'base.assert.harmony'}->($encoded_ntime) == 0
        and $retries_left-- > 0;

    if ( $retries_left <= 0 ) {    ##  count limit reached  ##
        $data{'base'}{'retry-limits-reached'}{'ntime_b32'} //= 0;
        $data{'base'}{'retry-limits-reached'}{'ntime_b32'}++;
    }

    return $encoded_ntime;
}

sub p7_encode_ntime_to_B32 {

    my $ntime_value = shift // '';

    if ( $ntime_value !~ m|^\d{13,17}(\.\d{1,17})?$| ) {
        warn 'expecting numerical ntime parameter <{C1}>';
        return undef;
    }
    my @ntme = split( qw| \. |, $ntime_value );

    ##  7 catches 0 prefix  ##
    $ntme[1] = sprintf qw| 7%s |, $ntme[1] if scalar @ntme == 2;
    my $encoded_ntime = Crypt::Misc::encode_b32r( pack( qw| w* |, @ntme ) );

    return $encoded_ntime;
}

##############################################################################

sub p7_ntime_BASE32_to_numerical {

    my $tstamp = shift;

    state $b32_re //= qr|^[A-Z2-7]+$|;

    if ( not defined $tstamp or $tstamp !~ $b32_re ) {
        warn 'encoded network time not valid [ BASE32 ] <{C1}>';
        return undef;
    }

    my $ntime_value = eval { Crypt::Misc::decode_b32r($tstamp) };

    if ( not defined $ntime_value or length $EVAL_ERROR ) {
        warn 'network time not valid [ '
            . 'BASE32 decoding not successful ] <{C1}>';
        return undef;
    }

    eval {
        ## contains network time with arbitary precision
        my @nt_val = unpack( qw| w* |, $ntime_value );
        $nt_val[1] =~ s|^7|| if @nt_val == 2;    ## <-- saves 0 prefixes
        $ntime_value = join( qw| . |, @nt_val );
    };

    if ( not defined $ntime_value
        or $ntime_value !~ m|^\d{1,17}(\.\d{1,20})?$| ) {
        warn 'protocol 7 network-time decoding was not successful <{C1}>';
        return undef;
    }

    return $ntime_value;   ##  returning numerical protocol 7 network time  ##

}

##############################################################################

sub p7_choose_true_pid {

    local $SIG{'CHLD'} = qw| IGNORE |;

    $data{'system'}{'start'}{'fork-count'} //= 0;
    local $data{'system'}{'verbosity'}{'console'}      = 1;
    local $data{'system'}{'verbosity'}{'zenka_buffer'} = 1;
    ## choose as TRUE asserted PID by forking ##
    my $fork_start_time = sprintf( '%.5f', &{ $code{'base.time'} } );
    local $data{'system'}{'start'}{'zenka_buffer'} = 1;
    while ( not $code{'base.assert.harmony'}->($PID) ) {
        $data{'system'}{'start'}{'fork-count'}++;
        my $new_pid = fork();
        last    if not defined $new_pid;    ## cannot fork ##
        exit(0) if $new_pid != 0;
    }
    $data{'system'}{'start-up'}{'fork-duration'}
        = $data{'system'}{'start'}{'fork-count'}
        ? sprintf( qw| %.5f |, $code{'base.time'}->() - $fork_start_time )
        : 0;
}

##############################################################################

sub p7_chk_nlr_path {    ## LLL: reduce calls \ exposure .,

    my $chk_path = shift // '';
    my $d_aref   = shift // [qw| ext/ / |];

    my $base_dir = shift // $data{'system'}{'root_path'} // '';
    die 'no base_dir defined'        if not length $base_dir;
    die 'chk_path argument expected' if not length $chk_path;
    die 'expected array ref as second argument'
        if ref($d_aref) ne qw| ARRAY |;

    if ( $data{'system'}{'use_http_source'} ) {
        return $chk_path
            if exists $data{'base'}{'httpc'}{'remote_source'}->{$chk_path};
        ## else | not exists ###
        warn "<< remote source file not found : $chk_path >> <{C1}>";
        return undef;
    }
    my $f_path;
    foreach my $chk_parent ( $d_aref->@* ) {
        $f_path
            = canonpath catfile( catfile( $base_dir, $chk_parent ),
            $chk_path );
        ( my $path_str = catfile( $chk_parent, $chk_path ) ) =~ s|^/+||;
        return $path_str if defined $f_path and -r $f_path;
    }
    $data{'modules'}{'warned'}{$f_path} //= {};    # <-- clean-up later..,LLL
    my $reason
        = ( -l $f_path and !-r readlink $f_path ) ? 'readable' : 'found';
    warn "<< source not $reason : '$chk_path' >> <{C1}>"
        if not $data{'modules'}{'warned'}{$f_path}++;
    return undef;
}

##############################################################################

sub p7_source_path_valid {

    my $src_file_rel = shift // '';

    warn 'no file name supplied' if !length($src_file_rel);
    my $src_remote = $data{'base'}{'httpc'}{'remote_source'} // {};
    ## ignored ##
    return FALSE
        if not length $src_file_rel
        or $src_file_rel =~ m,~$|\.orig$|\.LOG$,;
    ## remote ##
    return TRUE
        if $data{'system'}{'use_http_source'}
        and exists $src_remote->{$src_file_rel};
    ## local ##
    my $src_abs_path
        = abs_path( catfile( $data{'system'}{'root_path'}, $src_file_rel ) );
    return TRUE
        if defined $src_abs_path
        and ( -f $src_abs_path
        or -l $src_abs_path and -f readlink($src_abs_path) );
    warn "<< no match : $src_abs_path >> <{C1}>";
    return FALSE;    # <-- no match.
}

##############################################################################

sub p7_referenced_subroutines__add {

    my $code_name       = shift;
    my $sub_source_sref = shift;

    state $sub_name_re = qr|\w\d\-\.|;

    if ( not defined $code_name ) {
        warn 'expected subroutine source name <{C1}>';
        return undef;
    } elsif ( ref $sub_source_sref ne qw| SCALAR | ) {
        warn 'expected subroutine source reference <{C1}>';
        return undef;
    }

    my $sub_sourcecode = $sub_source_sref->$*;
    $sub_sourcecode =~ s|#[^\n]+$||mg;    ## <-- improve ##  [LLL]

    my @source_lines = split "\n", $sub_sourcecode;

    $data{'base'}{'subroutines'}{'referenced'} //= {};
    my $src_linenum = 0;
    foreach my $source_line (@source_lines) {
        $src_linenum++;
        while ( $source_line =~ s|\$code\{'([$sub_name_re]+)'}|| ) {
            my $subroutine = $LAST_PAREN_MATCH;
            ## track where it was found ##
            $data{'base'}{'subroutines'}{'referenced'}->{$subroutine}
                ->{$src_linenum}->{$code_name}++;
        }
    }
}

##############################################################################

sub p7_referenced_subroutines__clear_found {

    state $clean_found = TRUE;    ## for later ##

    return -1 if not $clean_found;    ## keep them ##

    my $removed = 0;
    return $removed
        if ref $data{'base'}{'subroutines'}{'referenced'} ne qw| HASH |
        or not keys $data{'base'}{'subroutines'}{'referenced'}->%*;
    map {

        ++$removed    ## remove all that are found to be loaded ##
            and delete $data{'base'}{'subroutines'}{'referenced'}->{$ARG}
            if defined $code{$ARG}

    } uniq $code{'base.sort'}
        ->( $data{'base'}{'subroutines'}{'referenced'} );

    return $removed;
}

##############################################################################

sub p7__dump_core_subs {

    my %core_subs;
    my $bin_path = $data{'system'}{'start'}{'exec_name'};
    open( my $p7_fh, $bin_path ) or die "$bin_path : \l$OS_ERROR\n";
    my %sub_src;
    my $sub_name;
    foreach my $src_line (<$p7_fh>) {
        $sub_name = undef
            if defined $sub_name and $src_line =~ m|^\s*};\s*(#.*)?\n$|;
        if ( defined $sub_name ) {
            $sub_src{$sub_name} //= [];
            push( @{ $sub_src{$sub_name} }, $src_line );
        }
        my $code_re = qr|\s*\$code\{\'([^\']+)\'\}\s*|;
        $sub_name = ${^CAPTURE}[0]
            if $src_line =~ m|^$code_re=\s*sub\s*\{\s*(#[^\n]*)?\n$|;
    }
    print "\n";
    close($p7_fh);
    foreach my $sub_name (
        sort { length $a <=> length $b }
        sort keys %sub_src
    ) {
        print "\n#  .::[ $sub_name ]:.\n#  ::\n";
        foreach my $sub_line ( $sub_src{$sub_name}->@* ) {
            print $sub_line;
        }
        print "\n#  .\n#  ::.\n";

    }
    exit;
}

##############################################################################

sub p7_load_code {

    my ( $file, $code_name );

    my $base = FALSE;    ## loading 'base' first ##
    map { $base = TRUE if $ARG eq qw| base | } @ARG;
    my @module_names = sort { length $a <=> length $b } reverse sort
        grep { !m|^base$| } uniq @ARG;
    unshift( @module_names, qw| base | ) if $base;

    $data{'callbacks'}{'end_code'} //= [];

    map { $code{'plugins.status'}->{$ARG}->{'load_errors'} = 0 }
        grep {m|^plugin\.|} @module_names;

    ## http source ### ..,/.v7/file-list
    my $base_url_aref = $data{'system'}{'http_src_base_urls'};
    my @http_src_base_urls
        = ref($base_url_aref) eq qw| ARRAY |
        ? @{$base_url_aref}
        : qw|
        http://nailara.network/sourcecode
        http://src.v7.ax/nailara/
        |;

    my $src_from_http = (
        ( $data{'system'}{'use_http_source'} // FALSE )
            or !-r $data{'system'}{'code_path'}
            and not( $data{'system'}{'no_http_source'} // FALSE )
    ) ? TRUE : FALSE;

    $code{'log.error'}->( '< not readable > ' . $data{'system'}{'code_path'} )
        if $src_from_http
        and !-r $data{'system'}{'code_path'}
        and not( $data{'system'}{'use_http_source'} // FALSE );

    $data{'system'}{'use_http_source'} = $src_from_http;

    my $c_ref            = $data{'base'}{'source'}{'code_files'} // [];
    my @subroutine_names = @{$c_ref};

    if ($src_from_http) {
        $code{'log.error'}->('<<< network source loading enabled >>>')
            if !@subroutine_names;
        ##### remote source code access ###
        my $method = ${^CAPTURE}[0]
            if $http_src_base_urls[0] =~ m|^(\w+):|;
        $code{'log.devmod'}->(": reading source file list over $method ..,");
        my $remote_data_str
            = $code{'base.httpc.remote_file'}
            ->( qw| .v7/file-list/base |, \@http_src_base_urls );
        if ( defined $remote_data_str ) {
            my $read_len = length($remote_data_str);
            @subroutine_names = split( m|\n|, $remote_data_str );
            $data{'base'}{'httpc'}{'remote_source'} = {};
            map {
                $data{'base'}{'httpc'}{'remote_source'}->{"modules/$ARG"}
                    = 1
            } @subroutine_names;
            $data{'base'}{'source'}{'code_files'} = \@subroutine_names;
        } else {
            $code{'log.error'}
                ->(': no success reading remote source file list .,');
            $code{'log.noerr'}->(': :');
            $code{'log.error'}->(': :. terminating startup sequence..,');
            $code{'log.noerr'}->(':....,');
            if ( defined $code{'base.exit'} ) {
                $code{'base.exit'}->(1);
            } else {
                exit(1);
            }
        }
        ####
    } else {
        $code{'log.devmod'}->(': reading source list from disk.,');
        @subroutine_names = $code{'base.code.file_list'}->();
        my $file_cnt = scalar @subroutine_names;
        $code{'log.devmod'}->(": :. $file_cnt files. [modules]");
    }
    $OUTPUT_AUTOFLUSH = TRUE;

    my %module_code_map;
    my @compile_order = ();

    while ( $code_name = shift @module_names ) {

        my $src_str = $code_name =~ m|^(.+/)?plugin.| ? '' : ' p7-source';
        $code{'log.noerr'}->(". loading$src_str : $code_name");

        $data{'base'}{'p7_mod'}{'errors'}->{$code_name} = 0;
        $data{'base'}{'p7_mod'}{'loaded'}->{$code_name} = 0;

        if ( my $purge_count = $code{'base.purge_code'}->($code_name) ) {
            my $s = $purge_count == 1 ? '' : 's';
            $code{'log.devmod'}->(": $purge_count sub$s undefined");
        }

        my $code_count      = 0;
        my $last_code_count = 0;
        if ( exists $data{'base'}{'modules'}{'internal_name'} ) {
            my $internal_name
                = delete $data{'base'}{'modules'}{'internal_name'};
            delete $data{'base'}{'modules'}{'moved_to'}{$internal_name}
                if exists $data{'base'}{'modules'}{'moved_to'};
        }

        foreach my $file_name (@subroutine_names) {
            next if not defined $file_name or not length $file_name;
            ## todo : reconcile with code_path ##
            my $src_abs_path;
            my $src_rel = $code{'base.chk_nlr_path'}->("modules/$file_name");

            $src_rel = "modules/$file_name"
                if not defined $src_rel;    # <-- warn.

            $src_abs_path
                = abs_path(
                catfile( $data{'system'}{'root_path'}, $src_rel ) )
                if defined $src_rel;

            if (    $src_rel =~ m|^(.*/)?$code_name(\..+)?$|
                and $code{'base.source_path_valid'}->($src_rel) ) {
                $code_count++;
                local $RS = undef;
                if ( $src_from_http
                    or !-r $src_abs_path
                    and !( $data{'system'}{'no_http_source'} // 0 ) ) {
                    ## read modules from network [ more methods coming ]

                    # $code{'log.devmod'}->(":[http]: $src_rel .,");

                    $data{'code'}{$file_name}{'source'}
                        = $code{'base.httpc.remote_file'}
                        ->( $src_rel, \@http_src_base_urls );
                    ####
                } else {
                    ## loading code from disk [ including ext directory ]
                    $code{'log.devmod'}->(":[disk]: $src_rel .,");
                    open( my $src_fh, qw| < |, $src_abs_path )
                        or die ":$src_abs_path : \l$OS_ERROR";
                    $data{'code'}{$file_name}{'source'} = <$src_fh>;
                    close($src_fh);
                }

                # <[sub_name]>->(  -->  $code{'sub_name'}->(
                my $orig_len
                    = length $data{'code'}{$file_name}{'source'};

                $data{'code'}{$file_name}{'source'}
                    =~ s|(?<!\\)<\[([\w\-]+\.[\w\-\.]+?)\]>\s*->\(
                            |\$code{'$LAST_PAREN_MATCH'}->(|sgxo;

                # < ! > the parser currently does not respect quoted strings
                #       escape like \<[sub.name]> <-- this to avoid a match.
                #
                # note: a generic quoted string match might be :  ##########
                # ####  (["'])(?:\\?+.)*?\1 or "([ˆ"]<(?<=\\)")+" #[mre:212]

                # <[sub_name]>  -->  $code{'sub_name'}->()
                $data{'code'}{$file_name}{'source'}
                    =~ s|(?<!\\)<\[([\w\-]+\.[\w\-\.]+)\]>
                            |\$code{'$LAST_PAREN_MATCH'}->()|gxo;

                ## needs to skip comments + better key syntax check ##

                # <foo.bar>  -->  $data{'foo'}{'bar'}
                # (requires at least 1 . in the data key to match)
                $data{'code'}{$file_name}{'source'}
                    =~ s|(?<!\\)<([\w\-:]+\.(\w[\w\-\.:]+)+)(?<!\\)>
                            | my $k = "\$data{'$1'}"; $k =~ s,\.,'}{',g;
                                 $k |gexo;
                $RS = "\n";
                if (length( $data{'code'}{$file_name}{'source'} ) > $orig_len
                    and $data{'system'}{'verbosity'}{'console'} > 3 ) {
                    $code{'log.devmod'}->( "\n\n .: $file_name :.\n\n"
                            . $data{'code'}{$file_name}{'source'} );
                    $data{'plugins'}{'status'}{$code_name}{'load_errors'}++
                        if not length($src_str);    # <-- is plugin..
                }

                ## track protocol-7 subroutines ##

                $code{'base.referenced_subroutines.add'}
                    ->( $file_name, \$data{'code'}{$file_name}{'source'} );

                push( @compile_order, $file_name );

                # register for error \ success tracking #
                $module_code_map{$file_name} = $code_name;

            } elsif ( $file_name =~ m|\.orig$| ) {
                $code{'log.error'}->(
                    sprintf( '[ not valid \\ remove., ] %s', $file_name ) );
            }
        }

        if (    $data{'system'}{'verbosity'}{'console'} == 1
            and $data{'system'}{'use_http_source'}
            and exists $data{'base'}{'httpc'}{'last_mlen'} ) {
            my $last_mlen = delete $data{'base'}{'httpc'}{'last_mlen'};
            $last_mlen += 92;
            $last_mlen = 79 if $last_mlen > 79;
            my $space_str = ' ' x $last_mlen;
            $OUTPUT_AUTOFLUSH = TRUE;
            print "\r$space_str\r";
            $OUTPUT_AUTOFLUSH = FALSE;
        }
        if ( $code_count == 0 ) {
            $code{'log.error'}->(
                sprintf( ": no success loading module [ %s ] \t[ not found ]",
                    $code_name )
            );
            $data{'base'}{'modules'}{'load_errors'}++;
        } elsif ( $code_count > $last_code_count ) {
            $data{'system'}{'subs_loaded'}{$code_name}
                = $code_count - $last_code_count;
        }
        $last_code_count = $code_count;
    }
    my $mod_count = scalar @compile_order;
    return if $mod_count == 0 and @module_names == 0;
    next   if $mod_count == 0;
    my $src_bytes_total = 0;
    $code{'log.devmod'}->(': compiling ..,');
    my ( $ok_count, $err_count, $warn_count, $warn_count_total )
        = ( 0, 0, 0, 0 );

    my %disabled_commands;
    map { $disabled_commands{$ARG} = 1 } @{ $data{'disabled_commands'} }
        if exists $data{'disabled_commands'}
        and ref( $data{'disabled_commands'} ) eq qw| ARRAY |;

    ## sort [ and filter ] in code occurence order ###
    @compile_order = $code{'base.code.sort_filter'}->(@compile_order);
    ##

    foreach my $sub_name (@compile_order) {
        my $module_name = $module_code_map{$sub_name};
        my $source_len  = length $data{'code'}{$sub_name}{'source'};
        $source_len //= 0;

        ## recompile twice case, now filtered ##
        $code{'log.error'}
            ->( sprintf( ':. << empty subroutine [ %s ] >>', $sub_name ) )
            if $source_len == 0;

        $data{'base'}{'p7_mod'}{'sbytes'}->{$module_name} = $source_len;

        local $SIG{'__WARN__'} = qw| IGNORE |;
        local $SIG{'__DIE__'}  = qw| IGNORE |;

        my $sub_code     = undef;
        my $sub_conflict = FALSE;

        if ( $sub_name =~ m{\.(cmd|console)\.(.+)$} ) {
            my $cmd_type = ${^CAPTURE}[0];
            my $cmd_name = ${^CAPTURE}[1];

            next
                if $cmd_type eq qw| cmd |
                and exists $disabled_commands{$cmd_name};

            if ( exists $data{'base'}{$cmd_type}{$cmd_name} ) {
                my $old_sub = $data{'base'}{$cmd_type}{$cmd_name};
                if (not
                    exists $data{'base'}{'overwritten'}{$cmd_type}{$cmd_name}
                ) {
                    if ( $sub_name ne $old_sub ) {
                        $code{'log.devmod'}->(
                            sprintf( ':: %s :. %s', $sub_name, $old_sub ) );
                    } else {
                        $code{'log.devmod'}->(
                            sprintf( '<< replacing sub %s >>', $sub_name ) );
                    }
                    $data{'base'}{'overwritten'}{$cmd_type}{$cmd_name} = {
                        qw| old | => $old_sub,
                        qw| new | => $sub_name
                    };
                } else {
                    push $data{'base'}{'overwritten'}
                        {$cmd_type}{$cmd_name}{'conflicts'}->@*,
                        $sub_name;
                    $data{'base'}{'modules'}{'load_errors'}++;
                    $code{'log.error'}
                        ->( sprintf( '<<< conflict : %s >>>', $sub_name ) );
                    $sub_conflict = TRUE;    ## true ##
                }
            }

            $data{'base'}{$cmd_type}{$cmd_name} = $sub_name
                if not $sub_conflict;
            my $stat_start_cref
                = defined $code{'stats.sub_start'}
                ? $code{'stats.sub_start'}->($sub_name)
                : sub { };
            my $stat_end_cref
                = defined $code{'stats.sub_end'}
                ? $code{'stats.sub_end'}->($sub_name)
                : sub { };

            if ( $cmd_type eq qw| cmd | ) {    ## not for console commands ##

                ## command type routine code header ##
                my $code_header = <<~ "EOC";

                    ##                                 ##
                    ##  compiled-in .cmd. code header  ##
                    ##                                 ##

                    my \$call  = {};
                    my \$reply = { qw| mode | => qw| false |,
                                  qw| data | => join( '',
                                    'error during invocation',
                                    " of '$cmd_name' command",
                                    ' [ details logged ]' )
                                };
                    \$code{'stats.sub_start'}->( \$sub_name )
                        if defined \$code{'stats.sub_start'} and
                            ref( \$code{'stats.sub_start'} ) eq qw| CODE |;

                    if ( ref( \$ARG[0] ) eq qw| HASH | ) { \$call = \$ARG[0] }
                    else { \$call->{'args'} = \$ARG[0] }
                    ##

                    EOC

                ##  command type routine code footer  ##
                my $code_footer = <<~ 'EOC';

                    ##                               ##
                    ## compiled-in .cmd. code-footer ##
                    ##                               ##
                    ;
                    ##  renamed reply type  ##
                    ##
                    if ( defined $reply->{'type'} and
                            $reply->{'type'} eq qw| data | ) {

                        $reply->{'type'} = qw| size |;
                        warn 'replaced meanwhile renamed'
                            .' DATA reply type [ fix ]';
                    }
                    ##

                    ###  'sub_end' callback  ###
                    $code{'stats.sub_end'}->($sub_name)
                        if ref( $code{'stats.sub_end'} ) eq qw| CODE |;

                    return $reply;
                    EOC

                $data{'code'}{$sub_name}{'source'} = join( '',
                    $code_header, $data{'code'}{$sub_name}{'source'},
                    ,             $code_footer );
            }
        }

        if ( $data{'system'}{'verbosity'}{'console'} > 2 ) {
            $sub_code = <<~ "EOC";
                sub {
                # line 1 "$sub_name"
                \$code{'base.devmod_sub'}->( qw| $sub_name |, \@ARG );
                $data{'code'}{$sub_name}{'source'}}
                EOC
        } else {
            $sub_code = <<~ "EOC";
                sub {
                # line 1 "$sub_name"
                $data{'code'}{$sub_name}{'source'}}
                EOC
        }

        ##                      ###
        ## compiling subroutine ###
        ##                      ###

        $src_bytes_total += $source_len;

        $code{'base.stderr_redir'}->( \my $s_comp_stderr );

        my $compilation_success
            = ( $code{$sub_name} = eval($sub_code)
                and ref( $code{$sub_name} ) eq qw| CODE | )
            ? TRUE
            : FALSE;

        my $err_str = $EVAL_ERROR;
        state $t_wrap //=
            ( defined &wrap )
            ? sub { return wrap( '', ': ..  ', $ARG ) }
            : sub { return $ARG };
        $err_str =~ s| at $sub_name line (\d+)[\.,]
                         | [ line $LAST_PAREN_MATCH ]\n|sx
            if defined $err_str;
        $warn_count_total += $warn_count
            = scalar $s_comp_stderr =~ s| at $sub_name line (\d+)[\.,]
                    | [ line $LAST_PAREN_MATCH ]\n|sgx

            if defined $s_comp_stderr and $s_comp_stderr;
        ( my $lpw )
            = ( $data{'system'}{'start'}{'log_prefix_width'}
                // $code{'base.get_start_lpw'}->() || 12 );
        my $width = 76 - $lpw;
        local $Text::Wrap::columns   = $width;
        local $Text::Wrap::separator = "\n";
        delete $data{'code'}{$sub_name}{'warnings'};    ## clear previous ##
        my @compile_errors = (
            '>',
            ".:[ $sub_name ]:.",
            ':',
            (   map  { s|Can.t|cannot|g; s|"|'|g; ": :  \l$ARG" }
                grep { !m|^BEGIN | } split( m|\n+|, $err_str )
            ),
            '='
            )
            if length( $err_str // '' )
            or defined $s_comp_stderr;
        push(
            @compile_errors,
            '>',
            '  :: warning ::',
            '  :',
            (   map {
                    push(
                        @{ $data{'code'}{$sub_name}{'warnings'} //= [] },
                        "\l$ARG"
                    );
                    "  :: \l$ARG"
                } split( m|\n+|, $s_comp_stderr )
            ),
            '..,'
        ) if defined $s_comp_stderr;

        $code{'base.stderr_restore'}->();

        $compilation_success = FALSE if $source_len == 0;

        if ($compilation_success) {

            $data{'base'}{'p7_mod'}{'loaded'}->{$module_name} = 1;

            delete $data{'code'}{$sub_name}{'source'};
            $data{'code'}{$sub_name}{'status'}
                = $warn_count ? qw| warned | : qw| no-error |;
            $ok_count++;
            if (    $sub_name !~ m{\.(cmd|console)\.}
                and $sub_name =~ m|\.end_code$| ) {
                ## needs module namespace for defined callback order ##
                push( $data{'callbacks'}{'end_code'}->@*, $sub_name );
            }
        } else {

            $data{'base'}{'p7_mod'}{'errors'}->{$module_name}++;

            $code{$sub_name} = sub {
                my $caller_str = $code{'base.caller'}->(1);
                undef $code{$sub_name}    ##  removing  ##
                    if $sub_name =~ m{^base.(log|buffer)};
                if ( $sub_name !~ m{\.(cmd|console)\.(.+)$} ) {    ## proto.,
                    my $lmsg = ": called broken routine : '$sub_name'";
                    $code{'log.error'}->($lmsg);
                    $code{'log.error'}->(":. $caller_str");
                    push(
                        $data{'system'}{'start'}{'zenka-buffer'}->@*,
                        join( ' ',
                            $code{'base.anum_log_time'}->(), 0,
                            join( ' ', $lmsg, '<-- UNDEFINED `:|' ) )
                    ) if $sub_name eq qw| base.log |;
                    ## raising silent exception ##
                    warn sprintf ':silent: %s <{C1}>', $lmsg;
                    return undef;
                } else {
                    $code{'log.error'}
                        ->(": broken command called : '$sub_name'");
                    $code{'log.error'}->(":. $caller_str");
                    return {
                        'mode' => qw| false |,
                        'data' => "command '$sub_name' is broken.,"
                            . " details in startup log.,"
                    };
                }
            };
            delete $data{'code'}{$sub_name}{'source'};
            $data{'base'}{'modules'}{'load_errors'}++;
            $data{'buffer'}{'compile-errors'}{'max_size'} //= 42 * 1024;
            my @wrapped_error
                = map { split m|\n|, $t_wrap->($ARG) } @compile_errors;
            $code{'log.error'}->(@wrapped_error);
            map { $code{'base.buffer.add_line'}->( 'compile-errors', $ARG ) }
                @wrapped_error
                if defined $code{'base.buffer.add_line'};

            $err_str =~ s|\n| |sg;
            $err_str =~ tr| ||s;
            $data{'code'}{$sub_name}{'status'} = "[error] $err_str";
            undef $s_comp_stderr;
            undef $err_str;
            $warn_count = 0;
            $err_count++;
        }
        if ( $compilation_success and $warn_count ) {
            $data{'buffer'}{'compile-errors'}{'max_size'} //= 42 * 1024;
            my @wrapped_error
                = map { split m|\n|, $t_wrap->($ARG) } @compile_errors;
            $code{'log.error'}->(@wrapped_error);
            map { $code{'base.buffer.add_line'}->( 'compile-errors', $ARG ) }
                @wrapped_error
                if defined $code{'base.buffer.add_line'};
            $warn_count = 0;
        }

        if ( $sub_name =~ m{\.(cmd|console|ext-cmd)\.(.+)$} )
        {    # command desciptions #
            my $section = ${^CAPTURE}[0];
            my $command = ${^CAPTURE}[1];
            if ( $data{'code'}{$sub_name}{'status'} eq qw| no-error | ) {
                if ( $sub_code =~ m|#\s*param\s*=\s*(.+)| ) {
                    $data{'base'}{'commands'}{$section}{$command}{'param'}
                        = ${^CAPTURE}[0];
                }
                if ( $sub_code =~ m|#\s*descr\s*=\s*(.+)| ) {
                    $data{'base'}{'commands'}{$section}{$command}{'descr'}
                        = ${^CAPTURE}[0];
                } else {    ##  command short description missing  ##
                    $data{'base'}{'commands'}{$section}{$command}{'descr'}
                        = qq|<< cmd description missing [param='descr'] >>|;
                    my $cmd_warn_string
                        = sprintf ':: %s :: missing command description',
                        $command;
                    $data{'buffer'}{'compile-errors'}{'max_size'}
                        //= 42 * 1024;
                    $code{'base.buffer.add_line'}
                        ->( qw| compile-errors |, $cmd_warn_string );
                    map { $code{'log.error'}->($ARG) }
                        ( ':', $cmd_warn_string, ':' );
                    $warn_count_total++;
                }

                # } elsif ( $data{'code'}{$sub_name}{'status'} ne 'warned' ) {
            } else {
                $code{'log.error'}
                    ->( ':', "::[ broken zenka command '$2' ]", ':' );
                $code{'log.error'}->(@compile_errors)
                    if not $data{'base'}{'modules'}{'load_errors'}++;
                $data{'base'}{'commands'}{$section}{$command}{'descr'}
                    = '<<< command did not compile properly >>>';
            }
        }
    }
    delete $data{'callbacks'}{'end_code'}
        if not $data{'callbacks'}{'end_code'}->@*;
    map {
        $data{'code'}{$ARG}{'status'} = qw| undefined |
            if not defined $code{$ARG}
        }
        keys %{ $data{'code'} };
    my $p     = '..: ';
    my $s     = $ok_count != 1         ? 's' : '';
    my $w     = $warn_count_total == 1 ? ''  : 's';
    my $w_msg = !$warn_count_total     ? '' : ", $warn_count_total warning$w";

    ## remove found subroutines from list ##
    $code{'base.referenced_subroutines.clear_found'}->();

    if ($err_count) {
        $code{'log.error'}->( $p
                . "success on $ok_count sub$s,"
                . " $err_count broken$w_msg., `:|" );
    } elsif ($warn_count_total) {
        $code{'log.error'}->( $p . "success on $ok_count sub$s$w_msg :|" );
    } else {
        $src_bytes_total = sprintf( qw| %.2f |, $src_bytes_total / 1024 );
        $src_bytes_total =~ s|\.?0+$||;
        $code{'log.noerr'}->(
            sprintf(
                $p . "%d sub%s., %dK src., no errors., =)",
                $ok_count, $s, $src_bytes_total
            )
        );
    }

    return ( $ok_count, $err_count );
}

##############################################################################

sub p7_stderr_redir {

    my $redir_ref = shift // \my $redir_var;

    open( $data{'base'}{'stderr_fh'}, qw| >& |, STDERR )
        or printf "\n<< cannot clone STDERR [ %s ] >>\n\n",
        $code{'base.format_error'}->($OS_ERROR);

    close(STDERR);
    open( STDERR, qw| > |, $redir_ref )
        or say sprintf '< stderr_redir > %s',
        $code{'base.format_error'}->($OS_ERROR);

    return $redir_ref;
}

##############################################################################

sub p7_stderr_restore {

    my $restore_fh = delete $data{'base'}{'stderr_fh'};

    close(STDERR);
    if ( defined $restore_fh ) {
        open( STDERR, qw| >& |, $restore_fh )
            or printf "\n<< cannot restore STDERR"
            . " to $restore_fh [ %s ] >>\n\n",
            $code{'base.format_error'}->($OS_ERROR);
    } else {
        open( STDERR, qw| > |, File::Spec->devnull() )
            or printf "\n<< cannot restore STDERR"
            . " to '/dev/null' [ %s ] >>\n\n",
            $code{'base.format_error'}->($OS_ERROR);
    }
}

##############################################################################

sub p7_collect_sub_stats {    ## [ LLL ] .. implement ., ###
    my $sub_name = shift;
}

##############################################################################

sub p7_devmod_sub {

    return if $data{'system'}{'verbosity'}{'console'} < 2;

    my $sub_name = shift @ARG;

    ## $code{'base.collect_sub_stats'}->($sub_name); #<--replace touch_dir
    my $quoted_chars = qr{[\ ;:,\.'\\]|^$};
    my @_p           = @ARG;

    # log all used subroutines if $sub_touch_dir exist and is owned by root.
    my $sub_touch_dir = $data{'system'}{'path'}{'sub_log_dir'}
        // qw| /var/tmp/protocol-7_devmod.sub_log |;
    if ( -d $sub_touch_dir
        and File::stat::stat($sub_touch_dir)->uid == 0 ) {
        my $zenka_name = $data{'system'}{'zenka'}{'name'};
        my $actual_dir = "$sub_touch_dir/$zenka_name";
        if ( !-d $actual_dir ) {
            my ( $dir_uid, $dir_gid );
            my $dir_mode = 0777;    ##  fallback mode ., non-critical.., ###
            if ( defined $data{'system'}{'privs'}{'user'} ) {
                ( undef, undef, $dir_uid, $dir_gid )
                    = getpwnam( $data{'system'}{'privs'}{'user'} );
                ## regular mode ###
                $dir_mode = 0770;
            }
            mkdir( $actual_dir, 0700 ) or warn "$actual_dir : $!";
            chown( $dir_uid, $dir_gid, $actual_dir ) if defined $dir_gid;
            chmod( $dir_mode, $actual_dir ) or warn "$actual_dir : $!";
        }
        my $sub_path = join( qw| / |, $actual_dir, $sub_name );
        open( my $_fh, qw| > |, $sub_path ) if !-f $sub_path;
        if ( fileno($_fh) ) {
            say {$_fh} $code{'base.ntime'}->(3);
            close($_fh);
        }
    }

    # hiding plain text passwords in devmod output [not including conf files]
    $_p[1] = '*' x 7 if $sub_name eq qw| auth.ok |;
    $_p[2] = '*' x 7 if $sub_name eq qw| base.net.client.auth_with_pwd |;
    $_p[0] = '*' x 7 if $sub_name eq qw| chk-sum.sha.1 |;
    $_p[1] =~ s|^(auth [^\ ]+) [^\ ]+\n$|$LAST_PAREN_MATCH *****\n|o
        if $sub_name eq qw| base.net.send_to_socket |;

    map { $ARG =~ s|(\')|\\$LAST_PAREN_MATCH|go if defined $ARG } @_p;
    my @params = map {
        defined $ARG
            ? ( $ARG =~ $quoted_chars ? "'$ARG'" : $ARG )
            : ''
    } @_p;

    my $param_list = join( ', ', @params );

    $param_list =~ s|\n|\\n|g;
    $param_list =~ s|\e|\\e|g;
    $param_list =~ s|\0|\\0|g;

    ## replacing perl objects ##
    eval { use Crypt::Misc qw| encode_b32r | }
        if not defined &{'encode_base32'};
    if ( $param_list =~ s|\'?(\S+(::\S+)+)|lc(${^CAPTURE}[0])|ge ) {
        $param_list =~ s|::|.|g;
        $param_list =~ s|event\.event|event|g;
    }
    $param_list =~ s{=(CODE|SCALAR|GLOB|HASH|ARRAY)}
                        {' : '.lc($LAST_PAREN_MATCH)}ige;
    $param_list =~ s{(CODE|SCALAR|GLOB|HASH|ARRAY)}
                        {lc($LAST_PAREN_MATCH)}ge;
    $param_list =~ s{\(0x([a-f0-9]+)\)\'?}{ sprintf( ' :: %s ::',
             substr( encode_b32r(pack("V*",
              Digest::Elf::elf(${^CAPTURE}[0]))) , 2,3 )
             .'0'. substr(
              Digest::Elf::elf(pack("H*",${^CAPTURE}[0])), -3, 3 )
             )
        }gxe if defined &{'encode_b32r'} and defined &Digest::Elf::elf;
    ## [ LLL ] ids need to become resolvable + devmod command ..,
    say sprintf(
        "$colors{p7_fg_0000}. %s$colors{p7_fg_0001} : $colors{p7_fg_0004}%s"
            . " [ $colors{p7_fg_0003}%s$colors{p7_fg_0000} ]"
            . $colors{'reset'},
        $data{'system'}{'zenka'}{'name'},
        $sub_name, $param_list
        )
        if $sub_name ne qw| base.log |
        and ( $sub_name ne qw| base.buffer.add_line |
        or $ARG[0] ne qw| zenka | )    # skipping too much output ..,
        and $sub_name ne qw| base.dump_data |;
}

##############################################################################

sub p7_log_hook {

    ## flush early zenka log buffer ###
    if (    defined $data{'system'}{'start'}{'zenka-buffer'}
        and $data{'system'}{'start'}{'zenka-buffer'}->@*
        and defined $code{'base.buffer.add_line'} ) {
        my $buffer = $data{'system'}{'start'}{'zenka-buffer'};
        while ( my $log_line = shift $buffer->@* ) {
            my $log_level
                = $log_line =~ m|^\S+ (\-?\d+) | ? $LAST_PAREN_MATCH : 0;
            $code{'base.buffer.add_line'}->( 'zenka', $log_line, $log_level )
                if $log_level <= $data{'system'}{'verbosity'}{'zenka_buffer'}
                or $log_level
                <= $data{'system'}{'verbosity'}{'zenka_logfile'};
        }
        delete $data{'system'}{'start'}{'zenka-buffer'};
    }
    ##
    return FALSE
        if not $data{'system'}{'use_http_source'}   # <-- check if required .,
        or not defined $data{'base'}{'httpc'}{'last_mlen'}
        or not $data{'system'}{'verbosity'}{'console'};
    if ( my $last_len = delete $data{'base'}{'httpc'}{'last_mlen'} ) {
        local $OUTPUT_AUTOFLUSH = TRUE;
        my $spaces = ' ' x $last_len;
        print "\r$spaces\r" and return $last_len;
    }
    return FALSE;
}

##############################################################################

sub p7_assert__harmony {    ##  rename and overload in base module  ##  [LLL]

    my $input_string = shift // '';
    my $check_elf    = shift // TRUE;    ## true ##

    return TRUE if not length $input_string;    ##  '' is true  ##

    my $visualize ## create seperate visualization routine in AMOS7::Assert ##
        = defined $data{'base'}{'harmony'}{'visualize'}
        ? $data{'base'}{'harmony'}{'visualize'}
        : {};     ## hashref with visualization settings ##

    if ( defined &AMOS7::Assert::Truth::is_true
        and not $visualize->{'enabled'} ) {
        ##  redirect to is_true  ##
        return AMOS7::Assert::Truth::is_true( \$input_string, 1, $check_elf );
    }

    my $visualize_zulum      = $visualize->{'zulum'}      // FALSE;
    my $visualize_harmony    = $visualize->{'harmony'}    // FALSE;
    my $visualize_disharmony = $visualize->{'disharmony'} // FALSE;

    state %a;
    if (   $visualize_zulum
        or $visualize_harmony
        or $visualize_disharmony ) {
        if ( not keys %a ) {

            #  reset          "\c[[m"
            my $reset       = "\e[0m";
            my $nailara_bg  = "\e[48;2;9;5;42m";
            my $blacklight  = "\e[38;2;68;39;172m";
            my $nailara_fg  = "\e[38;2;38;46;153m";
            my $error_color = "\e[38;2;197;141;7m";
            my $neon_green  = "\e[38;2;71;195;6m";
            %a = (
                'str'     => "\c[[1m",
                'bg'      => $nailara_bg,
                'bl'      => $blacklight,
                'reset'   => $reset,
                'ZL-B'    => $nailara_fg,
                'ZULUM'   => $blacklight,
                'Z-REST'  => "\c[[2m" . $reset . $nailara_bg . $nailara_fg,
                'D-REST'  => $reset . $nailara_bg . $neon_green,
                'NG'      => $neon_green . "\c[[1m",
                'UNKNOWN' => $neon_green . "\c[[5m",
                'color_y' => "\c[[6m" . $blacklight,
                'color_n' => $error_color . "\c[[1m",
                'clear'   => "\c[[H\c[[2J"
            );
        }
    }

    ## [ load modules first, if not present ] ##
    map {
        if ( not defined $data{'base'}{'perlmod'}{'loaded'}->{$ARG}
            or $data{'base'}{'perlmod'}{'loaded'}->{$ARG} == 0 ) {

            return TRUE
                if defined $data{'base'}{'perlmod'}{'loading-failed'}
                and exists $data{'base'}{'perlmod'}{'loading-failed'}->{$ARG};

            ( my $pm_name = "$ARG.pm" ) =~ s|::|/|g;

            eval { require $pm_name };    ## load _before_ logging ., ##

            if ($EVAL_ERROR) {
                $code{'log.error'}->(": loading not successful [ $ARG ]");
                ## give up assertions to not cause infinite loops ##
                $data{'base'}{'perlmod'}{'loading-failed'}->{$ARG} = 1;
                return 1;
            } else {
                $data{'base'}{'perlmod'}{'loaded'}->{$ARG} = 1;
                $code{'log.devmod'}->(": loaded perl module '$ARG'.,");
            }
        }
    } (qw| Digest::Elf Math::BigFloat |);
    ##

    ##                                   ##
    ## visualizing asserted numbers only ##
    ##                                   ##

    Math::BigFloat->round_mode(qw| trunc |);

    my $calc_str;
    ## check as mumber ##
    if ( $input_string =~ m|^\d+(\.\d+)?$| ) {
        ( my $input_num = $input_string ) =~ s|\.||;

        my $accuracy = 13;

        ( $calc_str
                = Math::BigFloat->new($input_num)
                ->bdiv( 13, $accuracy + length($input_num) ) ) =~ s|\.||;

        my $seperator_str = ' : ';

        if ( index( $calc_str, qw| 230769 | ) >= 0 ) {    ## FALSE ##

            my $min_len = $accuracy + 5;
            my $num_len = length($input_num);
            my $z_len   = abs( $min_len - $num_len );

            if (    $visualize_harmony
                and $visualize_disharmony
                and $num_len < $min_len ) {

                $input_num .= '0' x $z_len;
            }
            ### ..340769.., [E] ##
            $calc_str
                =~ s{(\d+?)((((((3)?0)?7)?6)?9)?230769([230769]+)*)(\d*)$}
                {$a{'D-REST'}${1}$a{'NG'}${2}$a{'D-REST'}${9}  $a{'reset'}}
                and say "$a{bg}$a{bl}: $input_num$seperator_str$calc_str "
                if $visualize_disharmony;

            return 0;
        } elsif ( $visualize_harmony
            and index( $calc_str, qw| 846153 | ) >= 0 ) {
            ### ..846153.., [T=5] ##
            $calc_str
                =~ s{(\d+?)((((((4)?6)?1)?5)?3)?846153([846153]+)*)(\d*)$}
                {$a{'ZULUM'}${1}$a{'ZL-B'}${2}$a{'Z-REST'}${9} $a{'reset'}};
            say "$a{bg}$a{bl}: $input_num$seperator_str$calc_str";

        } elsif ( $visualize_zulum
            and index( $calc_str, qw| 0000000 | ) >= 0 ) {
            $calc_str =~ s{(\d+?)?(0000000*)$}
                {$a{'ZULUM'}${1}$a{'ZL-B'}${2} $a{'reset'}};
            say "$a{bg}$a{bl}: $input_num$seperator_str$calc_str";

        } elsif ( $visualize_harmony and $visualize_disharmony ) {
            say "$a{bg}$a{bl}: $input_num$seperator_str$a{'UNKNOWN'}"
                . "$calc_str $a{'reset'}";
        }
    }

    return TRUE if not $check_elf;    ## true ##

    ##                                ##
    ##  checking for true elf chksum  ##
    ##                                ##

    state $load_already_attempted = FALSE;
    if (    not defined &AMOS7::Assert::Truth::is_true
        and not $load_already_attempted ) {    ## try only once ##
        eval { use AMOS7::Assert::Truth };
        $data{'base'}{'perlmod'}{'loaded'}->{'AMOS7::Assert::Truth'} = TRUE
            if not length $EVAL_ERROR
            and defined &AMOS7::Assert::Truth::is_true;
        $load_already_attempted = TRUE;        ## true ##
    }

    ## as string ##
    if ( defined &AMOS7::Assert::Truth::is_true ) {
        return &AMOS7::Assert::Truth::is_true( $input_string, 0, 1 );
    }

    my $elf_checksum;
    if ( defined $code{'chk-sum.elf'} ) {

        $elf_checksum = $code{'chk-sum.elf'}->( \$input_string );

    } else {    ## use fallback algorithm [ different settings ] ##

        $elf_checksum = Digest::Elf::elf($input_string);

    }

    if ( defined &AMOS7::Assert::Truth::true_int ) {

        return TRUE
            if AMOS7::Assert::Truth::true_int($elf_checksum);    ## true ##

        return FALSE;                                            ##  false  ##

    } else {    ## use modulo 13 ## [LLL]

        $calc_str = Math::BigFloat->new($elf_checksum)
            ->bdiv( 13, 13 + length $elf_checksum );

        return FALSE if index( $calc_str, qw| 230769 | ) >= 0;   ##  false  ##

        ## assertion complete : harmony detected ## [ no 230769.., ]
        return TRUE;
    }
    ##
}

##############################################################################

sub p7_load_B32_routines {    ## need fallback to CryptX ##  [ LLL ]

    if ( ( not defined &encode_b32r or not defined &decode_b32r )
        and not defined $data{'modules'}{'startup_error'}{'base32'} ) {
        eval { use Crypt::Misc qw| decode_b32r encode_b32r | };
        if ( $EVAL_ERROR or not defined &encode_b32r ) {
            $data{'modules'}{'startup_error'}{'base32'} = 1;
            return FALSE;    # module not found ##
        } else {
            return TRUE;     ## loading successful ##
        }
    } else {
        return TRUE;         ## function already present ##
    }
}

##############################################################################

sub p7_anum_log_time {

    my $pt_param     = shift // 5;    # <-- LLL: configure, precision\utime
    my $want_harmony = shift;         # <-- skip not harmonic time stamps ?

    if ( defined $code{'base.load_B32_routines'} ) {
        return $code{'base.ntime.b32'}->( $pt_param, $want_harmony );
    } else {
        return $code{'base.ntime'}->( $pt_param, $want_harmony );
    }
}

##############################################################################

sub p7_get_start_lpw {

    my $zenka_name = shift // $data{'system'}{'zenka'}{'name'};
    my $node_name  = $data{'system'}{'node'}{'name'};
    my $min_lpw    = length join( qw| . |, $node_name, qw| cube-13 | );
    my $start_lpw  = length( join( '.', $node_name, $zenka_name ) );
    $start_lpw = $min_lpw if $start_lpw < $min_lpw;
    return $start_lpw;
}

##############################################################################

sub p7_strip_ansi {
    my $scalar_ref = shift;
    return if !$data{'system'}{'ansi_color'};
    $$scalar_ref =~ s,$data{base}{ansi_re},,g;
}

##############################################################################

sub p7_banner {

    my $px = shift // '';

    ##  protocol-7 sourcecode version  ##
    my $version_str = sprintf 'protocol-7 srccode ver. : %s',
        $data{'protocol-7'}{'src-ver'};

    ## AMOS release version ##
    my $release_str = sprintf 'release ver. : %s',
        $data{'protocol-7'}{'rel-ver'};

    open( my $banner_file_fh,
        catfile( $data{'system'}{'conf_path'}, qw| .banner | ) )
        or return;

    local $RS = undef;    ## slurp mode ##
    my $nailara_header = <$banner_file_fh>;

    close($banner_file_fh);

    my $bg_0 = $colors{'B02'};
    my $bg_1 = $colors{'B00'};
    my $fg   = $colors{'p7_fg_0000'};
    my $rst  = $colors{'reset'};
    map {
        say $px, $bg_0, $fg, ' ', $bg_1, ' ', $bg_0, $fg, $ARG, $bg_1,
            ' ',
            $bg_0, $fg, ' ', $rst, "\r"
        }
        split( m|\n|, $nailara_header );
    say $px, $bg_0, $fg, ' ', $bg_1, ' ' x 77, $bg_0 . $fg, ' ', $rst,
        "\n",
        $px, $bg_0, $fg, ' ', $bg_1, ' ', $bg_0, $version_str, $bg_1,
        '    ',
        $bg_0, $fg, $release_str, $bg_1, ' ', $bg_0 . $fg, ' ', $rst,
        "\n", $px, $fg, $bg_0, '/', $bg_1, ' ' x 77, $bg_0 . $fg, '\\',
        $rst,
        "\r";
}

##############################################################################

sub p7_read_from_version_file {

    my $version_file    = shift;
    my $version_content = qw| UNKNOWN |;
    if (    defined $version_file
        and -e $version_file
        and open( my $ver_fh, qw|<|, $version_file ) ) {
        while ( my $line = <$ver_fh> ) {
            $line =~ s|#.+$||;
            $line =~ s|\s||g;
            next if not length $line;
            $version_content = $line;
            last;
        }
        close($ver_fh);
    }
    return $version_content;
}

##############################################################################

sub p7_caller__get_package_name {

    my $file = shift;
    my $line = shift;
    if ( not defined $file ) {
        warn 'file param is not defined <{C1}>';
        return undef;
    } elsif ( not defined $line ) {
        warn 'line param is not defined <{C1}>';
        return undef;
    }
    my $caller_lvl = 0;
    while ( my @caller_params = eval { caller( ++$caller_lvl ) }
        and not length $EVAL_ERROR ) {
        if ($caller_params[2] == $line
            and (  $caller_params[1] eq $file
                or $caller_params[3] eq $file )
        ) {
            ## returning package, subroutine in list context ##
            return ( $caller_params[0], $caller_params[3] ) if wantarray;
            ## returning package name in scalar context ##
            return $caller_params[0];
        }
    }
    return undef;    ##[ no match ]##
}

##############################################################################

sub p7_format_error {

    my $err_msg = shift // qw| :undef: |;
    my $c_lvl   = shift // 1;
    my ( $caller_str, $file, $line );
    $err_msg =~ s|\n$||;

    $err_msg =~ s{, <(STDIN|GEN\d+)> line \d+.+$}{}g;

    while ( $err_msg =~ s| at (\S+) line (\d+)[\.,]*$|| ) {
        ( $file, $line ) = @{^CAPTURE};
    }
    while ( $err_msg =~ s, ?\[([^\[]+):(\d+)\](( )|$),$3, ) {
        ( $file, $line ) = @{^CAPTURE};
    }

    $err_msg =~ s,",',g;   ##  replacing all double quotes [ with single ]  ##
    $err_msg =~ s|\((did[^\)]+)\?\)|[ $LAST_PAREN_MATCH ? ]|;
    $err_msg =~ s|\s+BEGIN failed.+$||sg;
    $err_msg =~ s|(*plb: in \@INC).+$||sg;
    $err_msg =~ s|(\S+(*nlb::)):(*pla: )|$LAST_PAREN_MATCH :|g;

    $err_msg = lcfirst $err_msg if $err_msg =~ m|^[A-Z][^A-Z]|;

    my @package;
    if ( defined $file ) {
        if (    defined $data{'code'}{$file}
            and defined $data{'code'}{$file}{'moved_to'} ) {
            ## sub renamed ? ##
            $file = $data{'code'}{$file}{'moved_to'};
            ## check where the old caller string comes from ##  [LLL]
        } else {
            $code{'base.clean_up_caller'}->( \$file );    ## shorten ##
        }
        @package    = $code{'base.caller.get_package_name'}->( $file, $line );
        $caller_str = sprintf qw| [%s:%d] |, $file, $line;
        $err_msg .= sprintf( ' %s', $caller_str ) if $c_lvl >= 0;
    }
    if ( index( $err_msg, qw| eval |, 0 ) > -1 ) {    ## missing closure ##
        if ( index( $err_msg, "[ '", 0 ) >= 0 and $err_msg !~ m|' ]'?$| ) {
            $err_msg =~ s| at .+line.+$|' \]|g;       ##  amending "' ]"  ##
        }
    }
    $err_msg =~ s,use of ,,g;
    $err_msg =~ s,no success on ,,g;
    $err_msg =~ s,(can't|unable to),cannot,g;
    $err_msg =~ s|^warning : something's wrong$|:undef:|g;
    $err_msg =~ s|^uninitialized value in warn$|:undef:|g;
    $err_msg =~ s|uninitialized value|undef value|g;
    $err_msg =~ s|argument in sprintf|sprintf argument|g;
    $err_msg =~ s| in use at \(eval \d+\) line \d+.||g;
    $err_msg =~ s| at \(eval \d+\) line \d+[\.,]||g;
    $err_msg =~ s|cannot use (an )?||g;
    $err_msg =~ s|(*plb: as )a ||g;

    ## check previously seen subroutine names ##
    if ( index( $err_msg, 'undefined value as subroutine reference', 0 ) >= 0
        and defined $data{'base'}{'subroutines'}{'referenced'}
        and defined $file
        and defined $line ) {
        my $sub_list_href = $data{'base'}{'subroutines'}{'referenced'};
        foreach my $subname ( keys $sub_list_href->%* ) {
            my $matched_href = $sub_list_href->{$subname};
            if ( defined $matched_href->{$line}->{$file} ) {
                $err_msg = sprintf    ## using an 'educated' guess here ##
                    'protocol-7 subroutine %s not defined',    ## <{NC}>? ##
                    $subname;
                ## $err_msg .=
                ## sprintf( ' %s', $caller_str ) if $c_lvl != -1; ## ? ##
            }
        }
    }
    if (wantarray) {
        my $force_caller = FALSE;
        if ( $c_lvl < -1 ) {
            ++$c_lvl;
            $force_caller = TRUE;    ## true ##
        }
        if ( $c_lvl != -1 or $force_caller ) {
            my @caller_params = $code{'base.caller'}->( abs($c_lvl) );
            ( $file, $line, @package ) = @caller_params;
            $caller_str = sprintf '[%s:%d]', $file, $line;
        }
        return ( $err_msg, $caller_str, $file, $line, @package );
    } else {
        return $err_msg;    ## scalar context ##
    }
}

##############################################################################

sub p7_caller {

    my $c_lvl = shift // 0;    ## 0 means caller parent [ from here ] ##
    $c_lvl++;                  ## <-- accounting for this subroutine ##
    my ( $package, $filename, $line, $subroutine ) = caller($c_lvl);
    if ( not defined $filename ) {
        return sprintf( '[ caller level too high : %03d ]', $c_lvl );
    } else {
        $code{'base.clean_up_caller'}->( \$filename );    ## shorten ##
        return ( $filename, $line, $package, $subroutine ) if wantarray;
        return "[$filename:$line]";
    }
}

##############################################################################

# [LLL] callback registry [ for skipping purging ]
sub p7_purge_code {

    my $code_name   = shift;
    my $purge_count = 0;
    my @zenka_commands;

    my $inline_subs;
    $inline_subs = $data{'base'}{'inline_subs'}{'sub-name'}
        if defined $data{'base.inline_subs'};
    $inline_subs //= {};

    map {
        if ($ARG !~ m{\.(callback|handler)\.}

            and not defined $inline_subs->{$ARG}
            and not defined $data{'base'}{'core_subs'}{$ARG}

            and $ARG ne qw|  base.log       |
            and $ARG ne qw|  base.logs      |
            and $ARG ne qw|  base.sort      |
            and $ARG ne qw|  base.time      |
            and $ARG ne qw|  base.sleep     |
            and $ARG ne qw|  base.gen_id    |
            and $ARG ne qw|  base.caller    |
            and $ARG ne qw|  base.s_read    |
            and $ARG ne qw|  base.s_write   |
            and $ARG ne qw|  base.sig_int   |
            and $ARG ne qw|  base.cfg_bool          |
            and $ARG ne qw|  base.sprint_t          |
            and $ARG ne qw|  base.sig_warn          |
            and $ARG ne qw|  base.route.add         |
            and $ARG ne qw|  base.format_error      |
            and $ARG ne qw|  base.context.list      |
            and $ARG ne qw|  base.clean_unicode     |
            and $ARG ne qw|  base.clean_up_caller   |
            and $ARG ne qw|  base.buffer.add_line   |
            and $ARG ne qw|  base.balanced-average  |
            and $ARG ne qw|  base.list.element.add  |
            and $ARG ne qw|  v7.handler.zenka_output             |
            and $ARG ne qw|  base.utf8.decode_clean              |
            and $ARG ne qw|  base.utf8.clean_not_valid           |
            and $ARG ne qw|  base.log.send_buffer_line           |
            and $ARG ne qw|  base.log.handler.log_reply          |
            and $ARG ne qw|  base.read_from_version_file         |
            and $ARG ne qw|  base.session.calc_cmd_stats         |
            and $ARG ne qw|  base.protocol-7.command.send.local  |
        ) {
            ++$purge_count
                and $data{'code'}{$ARG}{'status'} = qw| purged |
                and eval { undef &{ delete $code{$ARG} } }; #<-- improve [LLL]

            #  #[ devmod ]##
            #     and $code{$ARG} = eval "sub { print STDERR \"\n"
            #                      ." MISSING '$ARG'\n\n\" }";

            push( @zenka_commands, ${^CAPTURE}[0] )
                if $ARG =~ m|\.cmd\.(.+)$|;
            --$purge_count if $EVAL_ERROR;
        } elsif ( not exists $data{'base'}{'core_subs'}{$ARG} ) {
            ##  kept \ essential  ##
            $data{'code'}{$ARG}{'status'} = qw| leftover |;
        }
        }
        grep {m|^$code_name(\..+)?$|} keys %code;
    map {
        delete $data{'base'}{'cmd'}{$ARG};
        delete $data{'base'}{'commands'}{'cmd'}{$ARG};
    } @zenka_commands;
    return $purge_count;
}

##############################################################################

sub p7_parser__ellipse_center {

    my $str_param = shift;
    my $len_param = shift;
    die 'expected string and maximum length [>=5] parameters'
        if not defined $str_param
        or not defined $len_param
        or $len_param =~ m|^\d+$| and $len_param < 5;

    my $by_reference = ref($str_param) eq qw| SCALAR | ? 1 : 0;
    my $str_ref      = $by_reference ? $str_param          : \$str_param;
    my $str_len      = length($$str_ref);
    my $start_pos    = int( $len_param / 2 ) - 1;
    my $chars_cut    = $str_len - $len_param + 3;

    return 0                     if $by_reference and $str_len <= $len_param;
    return $str_param            if $str_len <= $len_param;
    return $str_len - $len_param if $by_reference;

    substr( $$str_ref, $start_pos, $chars_cut, '.,.' );
    return $$str_ref;
}

##############################################################################

sub p7_code__file_list {

    my $codedir_fh;
    $data{'base'}{'modules'}{'load_errors'} //= 0;
    if ( !opendir( $codedir_fh, $data{'system'}{'code_path'} ) ) {
        $data{'base'}{'modules'}{'load_errors'}++;
        $code{'log.error'}->(
            ': cannot open source code directory' . sprintf " '%s' [ %s ]",
            $data{'system'}{'code_path'},
            $code{'base.format_error'}->($OS_ERROR)
        );
        return undef;
    }
    my @subroutine_names = sort { length $a <=> length $b }
        sort grep { !m|^\.| } readdir($codedir_fh);
    closedir($codedir_fh);
    return @subroutine_names;
}

##############################################################################

sub p7_code__sort_filter {

    my @filtered_subroutines;
    my @subroutine_names = @ARG;
    my %subroutines      = map { $ARG => 0 } @subroutine_names;
    my $occurrence       = 0;

    ## unique filter ##
    my $subs_skipped = 0;
    my %sub_is_present;
    map {
        if ( not exists $sub_is_present{$ARG} ) {
            push( @filtered_subroutines, $ARG )
                and ++$sub_is_present{$ARG};
        } else {
            $subs_skipped++;
        }
    } @subroutine_names;

    $code{'log.devmod'}->(": :. skipped identical .: $subs_skipped ::")
        if $subs_skipped;    ## increase level when case addressed ## [LLL]

    ## .., ## [LLL] implement code dependency tree ..,

    return @filtered_subroutines;
}

##############################################################################

sub p7_httpc__remote_file {

    $data{'base'}{'warned'}{'http_src_deactivated'} //= FALSE;
    warn 'source loading over http has been temporarely deactivated'
        if !$data{'base'}{'warned'}{'http_src_deactivated'}++;

    return undef;    ## feature temporarely deactivated ##

    return undef if !( $data{'system'}{'use_http_source'} // TRUE );
    my $http_retries = $data{'system'}{'http_src_retries'} // 4;
    eval { use HTTP::Tiny } if !$data{'system'}{'http_reqs'};
    $EVAL_ERROR =~ s| ?\(\@INC contains:.+\n?$|| if $EVAL_ERROR;
    warn "<< 'HTTP::Tiny' pmod. not found"
        . " [ yet in cubelist ] [ $EVAL_ERROR ] >>"
        and return undef
        if $EVAL_ERROR;
    $data{'system'}{'http_reqs'}++;
    my $file_name = shift // '';
    my $base_urls = shift // ['https://nailara.network/sourcecode/'];
    warn 'expected http file name' and return undef
        if !length($file_name);
    warn 'expected array ref to base urls' and return undef
        if ref($base_urls) ne qw| ARRAY | or !@{$base_urls};
    ####
    $OUTPUT_AUTOFLUSH = TRUE;
    foreach my $http_base_url ( @{$base_urls} ) {
        my $abs_url = join( '/', $http_base_url, $file_name );
        $abs_url =~ s|//$file_name$|/$file_name|;
        my $h_res;
        my $retries      = $data{'system'}{'http_retries_total'} //= 0;
        my $retries_left = $http_retries;
        while ( $retries_left-- ) {
            my $r = $retries ? "[$retries\\$http_retries]" : '';
            ( my $msg_url = $abs_url ) =~ s|^(\w+)://|<$LAST_PAREN_MATCH> |;
            my $len
                = length( $data{'system'}{'zenka'}{'name'} )
                + length( $data{'system'}{'host'}{'hostname'} // '' );
            $len = 26 if $len < 27;

            my $w_len
                = 95 - $len
                - (
                      length( $data{'system'}{'node'}{'name'} )
                    + length( $data{'system'}{'zenka'}{'name'} ) );

            $code{'base.parser.ellipse_center'}->( \$msg_url, $w_len )
                if defined $msg_url;

            $msg_url =~ s| | : |;
            my $m_len    = length($msg_url);
            my $last_len = $data{'base'}{'httpc'}{'last_mlen'};
            $data{'base'}{'httpc'}{'last_mlen'} = length($msg_url) + 13;
            my $s     = ' ' x $last_len;
            my $m_str = "\r$s\r: $msg_url.,";
            print "\r$m_str\r"
                if $data{'system'}{'verbosity'}{'console'} == 1;
            $code{'log.devmod'}->(":$r: $msg_url")
                if $retries_left != $retries;
            my $h_obj = $data{'base'}{'httpc'}{'obj'}
                //= HTTP::Tiny->new( 'timeout' => 7 );
            $h_res = $h_obj->get($abs_url);
            my $h_code = $h_res->{'status'};

            if ( not $h_res->{'success'} ) {
                my $r_str = $EVAL_ERROR ? " < $EVAL_ERROR >" : '';
                goto skiplog_httpmsg;
                $code{'log.devmod'}->(
                    sprintf(
                        ":[ %d ] %s : [ %s ]%s",
                        $h_code, $abs_url, $h_res->{'reason'}, $r_str
                    )
                );
            skiplog_httpmsg:
                if ( $h_code == 404 or $h_code eq 599 ) {
                    $retries_left = 0;
                    $code{'log.noerr'}->( ":: aborting retries ["
                            . " after first $h_code code ] ::" );
                    return undef;
                } else {    ## client side rate limiting ## [???]
                    my $randomized_delay = 0.13 + rand(
                        0.777 * ++$data{'system'}{'http_retries_total'} );
                    $code{'base.sleep'}->($randomized_delay);
                }
                next;
            }
            if ( $h_code == 200 and length $h_res->{'content'} ) {
                return $h_res->{'content'};
            } else {
                warn "<< failed to acquire http file '$file_name' >>";
                return undef;
            }
        }
    }
    $OUTPUT_AUTOFLUSH = FALSE;
}

##############################################################################

sub p7_undef {undef}

##############################################################################

sub p7__dev__null { }

##############################################################################

sub p7_sig_warn {

    my $s_len;
    my $log_warning = TRUE;    ## true ##
    state $deep_recusrsion   //= 0;
    state $recent_warn_cnt   //= 0;
    state $last_warning_time //= $code{'base.time'}->(10);

    $s_len = $code{'base.log_hook'}->() if defined $code{'base.log_hook'};
    $s_len //= 0;
    my $spaces = ' ' x $s_len;
    if (@ARG) {
        my $c_lvl = 0;
        chomp( my @err = @ARG );

        foreach my $warn_line (@err) {

            $warn_line //= qw| :undef: |;

            $warn_line =~ s|([^[:print:]])
                           | sprintf("[%03d]",ord($LAST_PAREN_MATCH)) |aegx;
        }

        if ( index( $err[0], qw| :silent: |, 0 ) == 0 ) {
            $err[0] =~ s|^:silent:\s?||;
            ## silent warning mode [ to raise exceptions ] ##
            $log_warning = 0;    ##  silencing console output  ##
        }

        foreach my $warn_line (@err) {
            $warn_line = $code{'base.format_error'}->( $warn_line, -1 );
        }

        push( @err, $spaces ) if length $spaces;
        {
            if ( map {m|deep recursion |} @err ) {
                no warnings qw| recursion |;    # no follow-ups
                $deep_recusrsion++;             # remove offending routine #
                foreach my $c_lvl ( 1 .. 5 ) {
                    next
                        if $code{'base.caller'}->($c_lvl)
                        !~ m{\[(base\.(log.*|buffer.add_line)):\d+\]};
                    say ' < undefining > ', ${^CAPTURE}[0];
                    undef $code{ ${^CAPTURE}[0] };
                }
                my $msg = join( ' ',
                    ': FATAL ERROR :',
                    @err, $code{'base.caller'}->(3) );
                $code{'log.error'}->($msg);
                if ( $deep_recusrsion >= 5 ) {
                    $code{'log.error'}->(': terminating program .,');
                    exit('000113');
                }
            }
        }
        my @caller = caller;
        my ( $package, $filename, $line, $subroutine ) = @caller;

        $code{'base.clean_up_caller'}->( \$filename );    ## shorten ##

        if ( defined $data{'sig_warn_blacklist'} ) {    # <-- use array [LLL]
            return
                if defined $data{'sig_warn_blacklist'}{'package'}
                and $package eq $data{'sig_warn_blacklist'}{'package'}
                or defined $data{'sig_warn_blacklist'}{'pattern'}
                and join( ' ', @err )
                =~ $data{'sig_warn_blacklist'}{'pattern'};
        }    ## human readable way to stacktrace [eval] callers ? [LLL]
        map {
            $ARG =~ s| at $filename line $line[\.,].*$||;
            $ARG =~ s{, <GEN\d+>.*|GEN\d+$}{}g;
            $ARG =~ s|no success on eval ('\$code\{\S+)
                         |<< $LAST_PAREN_MATCH >>|x;
            $c_lvl = defined ${^CAPTURE}[0] ? -1 : ${^CAPTURE}[1] || 1
                if $ARG =~ s| *<\{(N)?C(\d{1,3})?\}>$||;
            ## no caller string : level = 0 ##
        } @err;
        if ($c_lvl) {    # <-- log parent caller instead ('<{C[level]}>')
            @caller = $c_lvl > -1 ? caller($c_lvl) : caller(1);
            ( $package, $filename, $line, $subroutine ) = @caller;
        }

        # special exception for zenka code evaluation [ base.init ]
        my $abs_filename = abs_path($filename);
        my $abs_ex_name
            = abs_path( $data{'system'}{'start'}{'exec_name'} );
        if (    defined $data{'system'}{'sub_name'}
            and defined $abs_ex_name
            and defined $abs_filename
            and $abs_filename eq $abs_ex_name
            and $data{'system'}{'sub_name'} eq qw| base.init | ) {
            my $l = 0;
            $filename = $data{'base'}{'eval_error'}{'name'}
                //= [ caller($l) ]->[1];
            $line = $data{'base'}{'eval_error'}{'line'}
                //= [ caller($l) ]->[2];
        }

        $code{'base.clean_up_caller'}->( \$filename );    ## shorten ##

        my $caller_str = sprintf qw| [%s:%d] |, $filename, $line;
        map {s| *\Q$caller_str\E$||g} @err;    # redundant caller clean-up #

        $caller_str = sprintf( '[ caller level too high : %03d ]', $c_lvl )
            if not length( join( '', $filename, $line ) );

        ## alternative handlers registered for filename:line ? ##
        my $match_param = "$filename:$line";    # <-- expand .., [LLL]
        if ( defined $data{'base'}{'warn-match-handler'}{$match_param} ) {
            my $cb_name
                = $data{'base'}{'warn-match-handler'}{$match_param};
            ( my $msg_str = join( ' ', @err ) ) =~ s{^\s+|\s+$}{}g;

            $log_warning
                = $code{$cb_name}->( $msg_str, $match_param, @caller )
                if defined $code{$cb_name};
        }
        ##
        if ($log_warning) {

            ##  parent caller exception for sprintf template warnings  ##
            ##
            if (    $caller_str =~ m{base.logt|base.sprint_t}
                and $err[0] =~ m| argument in sprintf| ) {
                $err[0] =~ s| argument in sprintf$| sprint_t parameter|;
                $caller_str = $code{'base.caller'}->(1);
                $caller_str = $code{'base.caller'}->(2)
                    if $caller_str =~ m|logt|;    ##  parent caller  ##
            }
            ##

            ##  seperate caller string to allow line wrapping  ##
            my $log_msg = join( ' ', qq|: warn :|, @err );
            if ( $log_msg =~ s| (\[[^:]+:\d+\])$|| ) {
                $caller_str = $LAST_PAREN_MATCH;
                $c_lvl      = 1;
            }
            if ( $c_lvl > -1 ) {
                my $max_len
                    = 67 - length $data{'system'}{'zenka'}{'name'};
                if ( length($log_msg) + length($caller_str) > $max_len ) {
                    $code{'log.error'}->($log_msg);
                    $code{'log.error'}->(":.    .: $caller_str");
                } else {
                    $code{'log.error'}
                        ->( join( ' ', $log_msg, $caller_str ) );
                }
            } else {
                $code{'log.error'}->($log_msg);
            }
        }
    }
    my $time = $code{'base.time'}->(10);
    if ( sprintf( qw| %0.7f |, $time - $last_warning_time <= 0.04707 ) ) {

        $code{'base.delay_warning'}    ##  slowing down with errors  ##
            ->( $time, $last_warning_time, $recent_warn_cnt )
            if $recent_warn_cnt++;

        $last_warning_time = $time;
    } else {
        $recent_warn_cnt = 0;
        undef $last_warning_time;
    }
    return TRUE;    ## true ##
}

##############################################################################

sub p7_delay_warning {

    my ( $time, $last_warning_time, $recent_warn_cnt ) = @ARG;
    my $delay_factor = sprintf( qw| %.07f |, $recent_warn_cnt / 13 );
    $delay_factor = 1 if $delay_factor > 1;
    my $log_delay = sprintf( qw| %.07f |,
        0.00007
            - ( $delay_factor * ( ( $time - $last_warning_time ) / 1300 ) ) );
    $log_delay = qw| 0 |       if $log_delay < 0;
    $log_delay = qw| 0.00007 | if $log_delay > 0.00007;
    $code{'base.sleep'}->($log_delay);
}

##############################################################################

sub p7_clean_up_caller {

    my $filename_sref = $ARG[0];

    my $was_scalar_ref = ref $filename_sref eq qw| SCALAR | ? 5 : 0;
    $filename_sref = \$ARG[0] if not $was_scalar_ref;

    if ( $filename_sref->$* eq qw| - | ) {    ## script came from stdin ? ##
        $filename_sref->$*
            = $PROTOCOL_SEVEN ? qw| Protocol-7 | : qw| <STDIN> |;
    }

    ## shorten for .pm mods ##
    $filename_sref->$* =~ s{^/usr/share/perl5/}{,../};
    $filename_sref->$* =~ s{^/usr/lib/[^/]+/perl5/\d+(\.\d+)+/}{,../};
    $filename_sref->$* =~ s{^.+/protocol-7/data/}{,../};
    $filename_sref->$* =~ s{^.+/perl\-base/}{,./perl-base/};

    ## return value when input not sref ##
    return $filename_sref->$* if not $was_scalar_ref;
}

##############################################################################

sub p7__log__name_template {

    my $lpw = shift // $data{'system'}{'zenka'}{'log_prefix_width'};
    if ( shift // FALSE ) {    ## highlight name and line [ bold \ ansi ] ##
        return sprintf(
            '%s%s.%s %s.%-*s %s.%s',
            $colors{'B02'},
            $colors{'p7_fg_0000'},
            $colors{'B00'} . $colors{'bold'},
            $data{'system'}{'node'}{'name'},
            $lpw,
            $data{'system'}{'zenka'}{'name'},
            $colors{'reset'} . $colors{'B02'} . $colors{'p7_fg_0000'},
            $colors{'B00'} . $colors{'bold'}
        );
    } else {                   ## regular log line output [ not .\7 line ] ##
        return sprintf(
            '%s%s. %s.%-*s .%s',
            $colors{'B02'}, $colors{'p7_fg_0000'},
            $data{'system'}{'node'}{'name'},
            $lpw, $data{'system'}{'zenka'}{'name'},
            $colors{'B00'}
        );
    }
}

##############################################################################

sub p7__log__format_name {

    my $hl = shift // FALSE;    ## highlight name and line [ bold \ ansi ] ##
    my $last_lpw = $data{'log'}{'lpw'}{'last'} // 0;
    my $lpw
        = $data{'system'}{'zenka'}{'log_prefix_width'}
        - length( $data{'system'}{'node'}{'name'} )
        - 1;

    if ($last_lpw) {
        my $lpw_delta = $lpw - $last_lpw;
        if ( $lpw_delta > 0 ) {    ## adjust in steps ##
            $lpw = ++$last_lpw;
        } elsif ( $lpw_delta != 0 ) {
            $lpw = --$last_lpw;
        }
    }

    $data{'log'}{'lpw'}{'last'} = $lpw;
    return $code{'log.name_template'}->( $lpw, $hl );
}

##############################################################################

sub p7__log__noerr {

    my $s_len;
    $s_len = $code{'base.log_hook'}->()
        if defined $code{'base.log_hook'};
    $s_len //= 1;    # <-- << ! >>
    my $spaces = ' ' x $s_len;
    while ( my $lmsg = shift @ARG ) {
        if ( defined $code{'base.log'}
            and $code{'base.log'} ne $code{'log.noerr'} ) {
            $code{'base.log'}->( 1, $lmsg );
        } else {
            if (defined $code{'base.log'}    ##  routine was purged  ##
                and $code{'base.log'} eq $code{'log.noerr'}
                ) {    ## setting emergenncy log levels ##
                $data{'system'}{'verbosity'}{'console'} //= 1;
                $data{'system'}{'verbosity'}{'console'} = 1
                    if $data{'system'}{'verbosity'}{'console'} < 1;
                $data{'system'}{'verbosity'}{'zenka_buffer'} //= 1;
                $data{'system'}{'verbosity'}{'zenka_buffer'} = 1
                    if $data{'system'}{'verbosity'}{'zenka_buffer'} < 1;
            }
            my $llvl = 1;
            if ( $lmsg =~ m|\-?\d+$| and @ARG ) {
                $llvl = $lmsg;
                $lmsg = shift @ARG;
            }
            my $color = $llvl < 1 ? qw| p7_fg_0002 |       : qw| p7_fg_0004 |;
            my $hl    = index( $lmsg, '.\\7', 0 ) == 0 ? 1 : 0;
            if (    $data{'system'}{'verbosity'}{'console'}
                and $llvl <= $data{'system'}{'verbosity'}{'console'} ) {
                say $code{'log.format_name'}->($hl), ' ',
                    $colors{$color}, $lmsg, $colors{'reset'},
                    $spaces;
            }
            ## early start-up buffer ##
            push(
                $data{'system'}{'start'}{'zenka-buffer'}->@*,
                join( ' ', $code{'base.anum_log_time'}->(), $llvl, $lmsg )
            ) if $llvl <= $data{'system'}{'verbosity'}{'zenka_buffer'};
        }
    }
}

##############################################################################

sub p7__log__error {

    my $error_color
        = $data{'system'}{'term'}{'colors'}{'stderr'}
        ? $colors{'bold'}
        : '';
    $code{'base.log_hook'}->() if defined $code{'base.log_hook'};
    if ( defined $code{'base.log'} ) {
        map {
            $code{'base.log'}->( 0, $ARG )
                if defined $code{'base.log'}    ##  still defined ?  ##
        } @ARG;
    } else {
        map {
            if ( defined $ARG ) {
                my $n_n = $data{'system'}{'node'}{'name'}  // '';
                my $a_n = $data{'system'}{'zenka'}{'name'} // '';
                my $s_len
                    = defined $code{'base.log_hook'}
                    ? $code{'base.log_hook'}->()
                    : 0;
                my $spaces = ' ' x $s_len;
                say &{ $code{'log.format_name'} }, ' ',
                    $colors{'p7_fg_0002'}, $ARG,
                    $spaces;

            } else {
                warn '<< error message not defined >> <{C1}>';
            }
        } @ARG;
        map {    ## early start-up buffer ##
            push(
                @{ $data{'system'}{'start'}{'zenka-buffer'} },
                join( ' ', $code{'base.anum_log_time'}->(), 0, $ARG )
            )
        } @ARG;
    }
}

##############################################################################

sub p7__log__devmod {

    $code{'base.log_hook'}->() if defined $code{'base.log_hook'};
    if ( defined $code{'base.log'} ) {
        map { $code{'base.log'}->( 2, $ARG ) } @ARG;
    } else {
        if ( $data{'system'}{'verbosity'}{'console'} > 1 ) {
            my $s_len;
            $s_len = $code{'base.log_hook'}->()
                if defined $code{'base.log_hook'};
            $s_len //= 0;
            my $spaces = ' ' x $s_len;
            map {
                say &{ $code{'log.format_name'} }, $colors{'p7_fg_0001'},
                    $ARG, $colors{'reset'},
                    $spaces
            } @ARG;
        }
        map {    ## early start-up buffer ##
            push(
                @{ $data{'system'}{'start'}{'zenka-buffer'} },
                join( ' ', $code{'base.anum_log_time'}->(), 2, $ARG )
            )
        } @ARG if $data{'system'}{'verbosity'}{'zenka_buffer'} > 1;
    }
}

##############################################################################

sub p7_handler__end_code {

    goto RESET_STDERR if not exists $data{'callbacks'}{'end_code'};

    my $callback_name;
    foreach $callback_name ( reverse @{ $data{'callbacks'}{'end_code'} } ) {
        if ( exists $code{$callback_name} ) {
            $code{'base.logs'}
                ->( 2, "calling end_code callback '%s'..,", $callback_name );
            $code{$callback_name}->();
        } else {
            $code{'base.logs'}->(
                0,
                "<<  referenced end_code callback "
                    . "'%s' does not exist >>",
                $callback_name
            );
        }
    }

RESET_STDERR:
    eval { print STDERR $colors{'reset'} }    ## [LLL] check 'output' mode ##
        if defined $colors{'reset'} and fileno(STDERR);
}

##############################################################################

sub p7_error_exit__inline_loading {

    my $err_reason_str = shift // 'REASON NOT DEFINED';
    my $line           = shift;
    my $err_line_num   = shift
        // $main::DATA_BLOCK_START + 1 + $INPUT_LINE_NUMBER;

    ( my $script_start_name = $data{'system'}{'start'}{'program_name'}
            // $PROGRAM_NAME ) =~ s|^.*/||;

    my $trunc_len = 27;
    substr( $line, $trunc_len, length($line) - $trunc_len, '.,' )
        if defined $line and length($line) > $trunc_len;

    my @err_reason = (
        ':: inline loading error ::',
        sprintf(
            ':: %s line %d ::%s',
            $script_start_name, $err_line_num,
            defined $line ? sprintf( " [ '%s' ]", $line ) : ''
        ),
        ':',
        sprintf( ':  %s', $err_reason_str ),
        ':',
        ':. ending init.,'
    );

    if ( defined $code{'log.error'} ) {
        map { $code{'log.error'}->($ARG) } ( ':', @err_reason );
        exit('0110');
    } else {
        die join '', map { sprintf "$ARG\n" } ( ':', @err_reason, );
    }
}

##############################################################################

sub p7_uncompress_subroutine_str {

    my $input_string_sref = shift;
    my $compression_type  = shift;

    my $output_data_str;
    $compression_type    ## auto-detect type ##
        //= $code{'base.detect_compression_format'}->($input_string_sref);

    state $method = qw| anyuncompress |;    ##[ anyuncompress | pipe ]##

    my $AnyUncompressError;
    if ( $method eq qw| anyuncompress | and not defined &anyuncompress ) {
        my $module_name = qw| IO::Uncompress::AnyUncompress |;
        eval sprintf 'use %s qw| anyuncompress $AnyUncompressError |',
            $module_name;
        if ( length $EVAL_ERROR or not defined &anyuncompress ) {
            my $err_str
                = defined $code{'base.format_error'}
                ? scalar $code{'base.format_error'}->( $EVAL_ERROR, -1 )
                : lcfirst($EVAL_ERROR);
            $err_str =~ s| at .+$||g;
            $code{'base.error_exit.inline_loading'}->(
                sprintf(
                    'cannot load perl module %s [ %s ]',
                    $module_name, $err_str
                )
            );
        }
    }
    ## module loaded ##

    my $success = FALSE;
    ##  decompress with format auto-detection  ##

    eval {
        $success
            = IO::Uncompress::AnyUncompress::anyuncompress(
            $input_string_sref => \$output_data_str );
    };

    if (    $success
        and not length $EVAL_ERROR
        and defined $output_data_str
        and length $input_string_sref->$* != length $output_data_str ) {

        return \$output_data_str;    ##  decompression completed  ##

    } else {
        my $err_str = $AnyUncompressError // $EVAL_ERROR;
        $err_str =~ s|^IO::Uncompress::AnyUncompress::anyuncompress ?||;
        if ( defined $code{'base.format_error'} ) {
            $err_str = $code{'base.format_error'}->( $err_str, -1 );
        }
        $err_str = 'unknown error reason' if not length $err_str;
        $err_str =~ s|^: ||;
        my @err_reason = (
            '::[ decompression error ]::',
            ':',
            sprintf( ":  method '%s' not successful", $method ),
            sprintf( ':  : %s : %s', $method, lcfirst($err_str) ),
            ':',
            ":. switching to 'pipe'-mode ..,"
        );
        my $caller_lvl = defined $code{'base.sig_warn'} ? ' <{NC}>' : "\n";
        map { warn sprintf '%s%s', $ARG, $caller_lvl } @err_reason;

        $method = qw| pipe |;    ##  trying next method  ##

        $output_data_str = undef;
    }

    if ( $method eq qw| pipe | ) {    ##  using external program call  ##

        state %uncompression_cmds = (
            qw| xz |      => qw| /usr/bin/xzcat |,
            qw| lzma |    => qw| /usr/bin/lzcat |,
            qw| gzip |    => qw|  /usr/bin/zcat |,
            qw| bzip2 |   => qw|     /bin/bzcat |,
            qw| unknown | => qw|  /usr/bin/ucat |
        );

        if ( not defined $uncompression_cmds{$compression_type} ) {
            $code{'base.error_exit.inline_loading'}->(
                sprintf( "no command known for uncompression mode '%s'",
                    $compression_type )
            );
        }
        my $decomp_cmd = $uncompression_cmds{$compression_type};
        if ( not -e $decomp_cmd or not -x $decomp_cmd ) {
            $code{'base.error_exit.inline_loading'}
                ->( sprintf( "no executable '%s' found", $decomp_cmd ) );
        }
        my $pipe_in_fh;
        my $pipe_out_fh;

        eval 'use IPC::Open3 qw| open3 |' if not defined &open3;
        die sprintf ': cannot load IPC::Open3 : ' . lcfirst($EVAL_ERROR)
            if length $EVAL_ERROR;

        my $pid = open3( $pipe_in_fh, $pipe_out_fh, undef, qw| xzcat | )
            or die sprintf ': xzcat : %s', lcfirst($OS_ERROR);

        print {$pipe_in_fh} $input_string_sref->$*;
        close($pipe_in_fh);
        my $read_size        = 7 * 1024;
        my $total_bytes_read = 0;
        my $bytes_read;
        while (
            $bytes_read = sysread(
                $pipe_out_fh, $output_data_str,
                $read_size,   length( $output_data_str // '' )
            )
            and defined $bytes_read
            and $bytes_read != -1
        ) {
            $total_bytes_read += $bytes_read if defined $bytes_read;
        }

        ## checking errors ##
        my $err_reason_str;
        my $tail_size = 57;
        $err_reason_str = 'error while uncompressing subroutine in pipe-mode'
            if $total_bytes_read == 0
            or not defined $output_data_str
            or not length $output_data_str
            or length $output_data_str == length $input_string_sref->$*;
        ( my $xcatname = $decomp_cmd ) =~ s|^.*/||g;
        $err_reason_str
            = sprintf( '%s : %s', $xcatname, lc $LAST_PAREN_MATCH )
            if substr( $output_data_str, -$tail_size, $tail_size )
            =~ m|($xcatname): \(stdin\): ([\w ]+)\n*$|;
        $err_reason_str //= 'decompression output equals input'
            if length $output_data_str == length $input_string_sref->$*
            and $output_data_str eq $input_string_sref->$*;

        $code{'base.error_exit.inline_loading'}
            ->( $err_reason_str, $decomp_cmd )
            if defined $err_reason_str;

        return \$output_data_str;    ##  decompression completed  ##
    }
}

##############################################################################

sub p7_detect_compression_format {

    my $input_string_sref = shift;

    my $compression_type = qw| unknown |;

    eval 'use IPC::Open3 qw| open3 |' if not defined &open3;
    die sprintf ': cannot load IPC::Open3 : ' . lcfirst($EVAL_ERROR)
        if length $EVAL_ERROR;

    my $pipe_in_fh;
    my $pipe_out_fh;
    my $pid = open3( $pipe_in_fh, $pipe_out_fh, undef, qw| /usr/bin/file - | )
        or $code{'base.error_exit.inline_loading'}
        ->( sprintf ': /usr/bin/file : %s', lcfirst($OS_ERROR) );

    print {$pipe_in_fh} $input_string_sref->$*;
    close($pipe_in_fh);

    my $output_data_str  = '';
    my $read_size        = 7 * 1024;
    my $total_bytes_read = 0;
    my $bytes_read;
    while (
        $bytes_read = sysread(
            $pipe_out_fh, $output_data_str,
            $read_size,   length( $output_data_str // '' )
        )
        and defined $bytes_read
        and $bytes_read != -1
    ) {
        $total_bytes_read += $bytes_read if defined $bytes_read;
    }
    if ($total_bytes_read) {
        $compression_type = lc( ${^CAPTURE}[0] )
            if $output_data_str =~ m|(\S+) compressed data$|;
    }
    return $compression_type;    ##  detected type or 'unknown'  ##
}

##############################################################################

sub p7_load_inline_subroutines {

    my $sub_append_mode = shift // qw| append |;    ## [ append | replace ] ##
    my $data_block_filehandle = shift;    ## custom DATA fh provided ##

    ## used for reporting write protect errors ##
    my $prog_name = defined $data_block_filehandle ? 'SUB_FH' : $RealScript;

    ## lock Protocol-7 file to not be modified while reading <DATA> ##
    ## my $lock_during_read = TRUE             ## true ##

    my $lock_during_read = FALSE;

    if ( not defined $data_block_filehandle and fileno(DATA) ) {
        ## fh to script with offset ##
        $data_block_filehandle = IO::Handle->new(); ## does not work for STDIN
        $data_block_filehandle->fdopen( fileno(DATA), qw| r | );

    } elsif ( not defined $data_block_filehandle ) {
        $data_block_filehandle = *STDIN{IO};        ##  pipe mode  ##
    }

    ##  inline code loader and parser state  ##
    ##
    my $loader_state = $data{'base.inline_subs'} //= {
        qw|   loading-iteration    | => -1,    ## start at 0 ##
        qw|  initial-p7-code-refs  | => {},    ## backup in stdin mode ##
    };

    ## STDIN is not seekable ##
    $loader_state->{'seekable-data-fh'} = seek( $data_block_filehandle, 0, 1 )
        ? TRUE      ## true ##
        : FALSE;    ##  false  ##

    $loader_state->{'stdin-data-block-mode'}
        = $data_block_filehandle == *STDIN{IO}
        ? TRUE      ## true ##
        : FALSE;    ##  false  ##

    ##  write protect fh while reading from <DATA> block  ##
    ##
    my $data_fh_stat;
    $loader_state->{'fh-write-protected'} = FALSE;
    goto DO_NOT_WRITE_PROTECT_DATA_FH    ##  skip chmod if not able to  ##
        if not $lock_during_read
        or $loader_state->{'stdin-data-block-mode'}
        or not $data_fh_stat = stat($data_block_filehandle)
        or not $UID == 0 and not $data_fh_stat->cando( S_IWUSR(), 1 )  ## EUID
        and $data_fh_stat->uid != $EUID;

    ## backing up file mode ##
    $loader_state->{'start-file-mode'} = sprintf '%#o',
        $data_fh_stat->mode & 07777;
    $loader_state->{'read-only-fh-mode'} = sprintf '%#o',
        oct( $loader_state->{'start-file-mode'} ) & 0555;

    goto DO_NOT_WRITE_PROTECT_DATA_FH ## nothing to do as already read-only ##
        if $loader_state->{'start-file-mode'} eq
        $loader_state->{'read-only-fh-mode'};

    ## changing permissions to read only ##
    if (chmod(
            oct( $loader_state->{'read-only-fh-mode'} ),
            $data_block_filehandle
        )
    ) {
        $loader_state->{'fh-write-protected'} = TRUE;    ## true ##

        $main::RESTORE_FH_ON_ERR    = $data_block_filehandle;
        $main::RESTORE_PERMS_ON_ERR = $loader_state->{'start-file-mode'};

        END {    ##  restore permissions in error case  ##
            if ( defined $main::RESTORE_PERMS_ON_ERR
                and $main::RESTORE_PERMS_ON_ERR ) {
                chmod(
                    oct($main::RESTORE_PERMS_ON_ERR),
                    $main::RESTORE_FH_ON_ERR
                    )
                    or warn sprintf 'chmod Protocol-7 : %s',
                    lcfirst $OS_ERROR;
            }
        }

    } else {
        warn sprintf 'chmod %s : %s', $prog_name, lcfirst $OS_ERROR;
    }
    ##
DO_NOT_WRITE_PROTECT_DATA_FH:

    $loader_state->{'data-block-start-pos-in-bytes'}
        //= tell($data_block_filehandle);

    $loader_state->{'data-input-start-line'}
        = $data_block_filehandle->input_line_number;

    if ( $loader_state->{'seekable-data-fh'} ) {

        ##  finding DATA position ourselves [ might have changed ]  ##
        seek( $data_block_filehandle, 0, 0 );    ## reset to script start ##
        IO::Handle->input_record_separator(undef);

        my $start_pattern = "\n__DATA__\n";
        my $data_start_pos
            = index( $data_block_filehandle->getline, $start_pattern, 0 );
        $data_start_pos += length $start_pattern if $data_start_pos >= 0;

        ##  whitespaces in __DATA__ line ?  ##
        if ( $data_start_pos == -1 ) {
            seek( $data_block_filehandle, 0, 0 );  ## reset to script start ##
            if ( $data_block_filehandle->getline =~ m|(\n *__DATA__ *\n)| ) {
                $data_start_pos = $+[0];           ## pattern match end pos ##
            }
        }
        ## allow for external files without ? ## [LLL]
        if ( $data_start_pos == -1 ) {
            $code{'base.error_exit.inline_loading'}
                ->('did not find a __DATA__ block marker');
        } else {
            $loader_state->{'data-block-start-pos-in-bytes'}
                = $data_start_pos;
            undef $data_start_pos;
        }

        ## resetting to DATA block start ##
        seek( $data_block_filehandle,
            $loader_state->{'data-block-start-pos-in-bytes'}, 0 );
        IO::Handle->input_record_separator("\n");

        $loader_state->{'total-data-lines'}
            = scalar [ $data_block_filehandle->getlines ]->@*;

        $loader_state->{'data-block-end-position-bytes'}
            = tell($data_block_filehandle);

        ####
        seek( $data_block_filehandle, 0, 0 );    ## reset to script start ##
        $loader_state->{'total-script-lines'}
            = scalar [ $data_block_filehandle->getlines ]->@*;

        $loader_state->{'data-block-start-line'}
            = $loader_state->{'total-script-lines'}
            - $loader_state->{'total-data-lines'};

        ## globalizing for error handler ##
        $main::DATA_BLOCK_START = --$loader_state->{'data-block-start-line'};

        $loader_state->{'error-line-offset'}
            = $loader_state->{'data-block-start-line'}
            + $loader_state->{'data-input-start-line'};

        ##  restore to data block start  ##
        seek( $data_block_filehandle,
            $loader_state->{'data-block-start-pos-in-bytes'}, 0 );

        $INPUT_LINE_NUMBER = $loader_state->{'data-input-start-line'};

    } else {    ## take DATA start position from CHECK block at script end ##
        $loader_state->{'data-block-start-line'} = $main::DATA_BLOCK_START;
    }

    my $subroutine;
    my $subsrc_linenum;
    my $sub_source_line;
    my $source_encoding;
    my $prev_src_line;
    my $loaded_routines = 0;
    my $src_comp;    ## within BASE32 ##
    $INPUT_LINE_NUMBER = 0;

    $data_block_filehandle->clearerr;

    while ( my $line = $data_block_filehandle->getline ) {
        $code{'base.error_exit.inline_loading'}->(
            sprintf 'DATA block read error [ line %d ]',
            $INPUT_LINE_NUMBER
        ) if not defined $line;
        chomp($line);

        my $end_of_subsrc = FALSE;
        ##  skipping empty and comment lines  ##
        next if not length $line or $line =~ m|^\s*[#\n]|;

        if ( $line !~ m|^.:\[ ([\w\d\-\_\.]+) \]:.$| ) {
            if ( not defined $subroutine ) {
                $code{'base.error_exit.inline_loading'}
                    ->( 'expected inline subroutine header', $line );
            } else {    ## line of existing subroutine ##
                next
                    if not defined $sub_source_line
                    and not defined $subsrc_linenum
                    and $line eq ':';
                $subsrc_linenum //= 0;

                if (not defined $source_encoding       ## first BASE32 line ##
                    and $line =~ m|^: [02-9A-Z]{76}|   ## 0 prefix padding
                ) {
                    substr( $line, 0, 2, '' );         ## remove prefix ##

                    $source_encoding = qw| BASE32 |;
                    if ( index( $line, qw| 7U3XU |, 0 ) == 0 ) {
                        $src_comp = qw| xz |;
                    } elsif ( index( $line, qw| D6FQQ |, 0 ) == 0 ) {
                        $src_comp = qw| gzip |;
                    } elsif (                          ## >:] ##
                        index( $line, qw| EMRSAPR2LUQCGIYK |, 0 ) == 0
                    ) {
                        $src_comp = qw| none |;
                    } else {
                        $code{'base.error_exit.inline_loading'}
                            ->( 'unknown compression or src header', $line );
                    }
                } elsif ( not defined $source_encoding
                    and index( $line, ': ## >:] ##', 0 ) == 0 ) {
                    substr( $line, 0, 2, '' );         ## remove prefix ##
                    $source_encoding = qw| plain |;
                } elsif ( not defined $source_encoding ) {
                    $code{'base.error_exit.inline_loading'}
                        ->( 'unknown encoding or src header', $line );
                } elsif ( index( $line, qw| : |, 0 ) == -1 ) {
                    $code{'base.error_exit.inline_loading'}
                        ->( 'inline source format error', $line );
                } elsif ( index( $line, qw| :. |, 0 ) == -1 ) {
                    substr( $line, 0, 2, '' );         ## remove prefix ##
                } else {
                    ## correction of encoding ? ##
                    if ( not length $prev_src_line ) {
                        $source_encoding = qw| plain |;
                    } elsif ( $source_encoding eq qw| plain | ) {
                        $code{'base.error_exit.inline_loading'}->(
                            'end of [ plain ] sub src format not valid',
                            $prev_src_line
                        );
                    } elsif ( $prev_src_line
                        !~ m|<([2-9A-Z]{52}):((\d+):)?((\d+):)?(\d+)>| ) {
                        $code{'base.error_exit.inline_loading'}->(
                            'not valid [BASE32] sub src checksum format',
                            $prev_src_line
                        );
                    } else {
                        $loader_state->{'sub-src-chksum'} = ${^CAPTURE}[0];
                        $loader_state->{'sub-src-lines'}  = ${^CAPTURE}[2]
                            if defined ${^CAPTURE}[2]
                            and length ${^CAPTURE}[2];
                        $loader_state->{'sub-src-word-count'} = ${^CAPTURE}[4]
                            if defined ${^CAPTURE}[4]
                            and length ${^CAPTURE}[4];
                        $loader_state->{'sub-src-bytes'} = ${^CAPTURE}[5]
                            if defined ${^CAPTURE}[5]
                            and length ${^CAPTURE}[5];
                    }

                    $end_of_subsrc = TRUE;    ##  subroutine complete  ##
                }

                if ( defined $prev_src_line and not $end_of_subsrc ) {
                    $subsrc_linenum++;

                    ### appending to sub source string ###

                    if ( $source_encoding ne qw| BASE32 | ) {

                        $sub_source_line    ##  plain sourcecode  ##
                            .= sprintf( "%s\n", $prev_src_line );

                    } else {    ##  encoded \ compressed sourcecode  ##
                        $sub_source_line .= $prev_src_line;
                    }

                    ###

                } elsif ($end_of_subsrc) {
                    if ( $source_encoding eq qw| BASE32 | ) {
                        $sub_source_line =~ s|[01]||g;

                        ## load module first if not done ##
                        $code{'base.load_B32_routines'}->()
                            if not defined &decode_b32r;

                        my $srcstr_decoded
                            = eval { decode_b32r($sub_source_line) };

                        if ( not defined $srcstr_decoded
                            or length $EVAL_ERROR ) {

                            my $err_reason_str
                                = defined &decode_b32r
                                ? 'need Crypt::Misc module'
                                : sprintf( 'inline-subroutine : %s',
                                $subroutine );

                            $code{'base.error_exit.inline_loading'}->(
                                sprintf( 'BASE32 decoding error [ %s ]',
                                    $err_reason_str ),
                                $sub_source_line
                            );
                        }
                        if ( $src_comp ne qw| none | ) {

                            my $decomp_buffer_sref
                                = $code{'base.uncompress_subroutine_str'}
                                ->( \$srcstr_decoded, $src_comp );

                            $code{'base.error_exit.inline_loading'}
                                ->( 'decompression error', $subroutine )
                                if not defined $decomp_buffer_sref->$*
                                or not length $decomp_buffer_sref->$*;

                            ### validate checksum ###
                            $code{'base.error_exit.inline_loading'}->(
                                'subroutine chksum not present', $subroutine
                                )
                                if not
                                defined $loader_state->{'sub-src-chksum'};

                            ##  decoded subroutine number of bytes  ##
                            $code{'base.error_exit.inline_loading'}->(
                                sprintf(
                                    'decoded subroutine size mismatch '
                                        . '[%d!=%d]',
                                    length $decomp_buffer_sref->$*,
                                    $loader_state->{'sub-src-bytes'}
                                ),
                                $subroutine
                                )
                                if length $decomp_buffer_sref->$*
                                != $loader_state->{'sub-src-bytes'};

                            ## subroutine word count ##
                            my $word_count = scalar( split m|\s+|,
                                $decomp_buffer_sref->$* );
                            $code{'base.error_exit.inline_loading'}->(
                                sprintf(
                                    'subroutine word-count mismatch'
                                        . ' [ %d != %d ]',
                                    $word_count,
                                    $loader_state->{'sub-src-word-count'}
                                ),
                                $subroutine
                                )
                                if
                                defined $loader_state->{'sub-src-word-count'}
                                and $word_count
                                != $loader_state->{'sub-src-word-count'};

                            ## subroutine line count ##
                            my $line_count = scalar( split "\n",
                                $decomp_buffer_sref->$* );
                            $code{'base.error_exit.inline_loading'}->(
                                sprintf(
                                    'subroutine has wrong number of lines'
                                        . ' [ %d != %d ]',
                                    $line_count,
                                    $loader_state->{'sub-src-lines'}
                                ),
                                $subroutine
                                )
                                if defined $loader_state->{'sub-src-lines'}
                                and $line_count
                                != $loader_state->{'sub-src-lines'};

                            ##  BMW chksum  ##
                            my $sub_bmw_chksum = eval {
                                encode_b32r(
                                    Digest::BMW::bmw_256(
                                        $decomp_buffer_sref->$*
                                    )
                                );
                            };
                            $code{'base.error_exit.inline_loading'}
                                ->( 'chksum calculation failed', $subroutine )
                                if not defined $sub_bmw_chksum
                                or not length $sub_bmw_chksum
                                or length $EVAL_ERROR;

                            $code{'base.error_exit.inline_loading'}->(
                                'subroutine chksum mismatch', $subroutine
                                )
                                if $sub_bmw_chksum ne
                                $loader_state->{'sub-src-chksum'};

                            ##  verifified  ##
                            $sub_source_line = $decomp_buffer_sref->$*;

                        }
                    }
                    $EVAL_ERROR = '';

                    ### compiling subroutine into %code reference ###

                    my $sub_cref = eval sprintf "sub {\n%s\n}",
                        $sub_source_line;

                    if ( ref $sub_cref ne qw| CODE |
                        or length $EVAL_ERROR ) {

                        my $data_start_lnum
                            = $loader_state->{'data-block-start-line'};

                        my $s_lnum = 0;
                        $s_lnum = $LAST_PAREN_MATCH
                            if $EVAL_ERROR =~ m| at \(eval \d+\) line (\d+),|;

                        chomp $sub_source_line;
                        my @lines = $sub_source_line =~ m|(\n)|g;

                        my $sub_end_line =    ##  exact end us sub code  ##
                            $data_start_lnum + $INPUT_LINE_NUMBER - 1;
                        ## error location from end ##
                        my $line_offset = scalar @lines - $s_lnum;
                        my $abs_err_pos = $sub_end_line - $line_offset;
                        undef @lines;

                        my $err_str
                            = defined $code{'base.format_error'}
                            ? scalar $code{'base.format_error'}
                            ->( $EVAL_ERROR, -1 )
                            : lcfirst($EVAL_ERROR);
                        $err_str =~ s|"|'|g;
                        $err_str =~ s|at \(eval \d+\) line \d, ||g;
                        my $lnum;    ## another error line number ##
                        $lnum = ${^CAPTURE}[0]
                            if $err_str =~ s| \<DATA\> line (\d+)\.$||g;
                        ## from <DATA> block ##
                        $abs_err_pos = $data_start_lnum + $lnum
                            if $data_start_lnum + $lnum
                            < $abs_err_pos;    ##  adjusting backward  ##

                        $code{'base.error_exit.inline_loading'}->(
                            $err_str // 'subroutine was not compiled',
                            sprintf( '%s : %d', $subroutine, $s_lnum ),
                            $abs_err_pos
                        );

                    } else {

                        ## registering with compilation time ##
                        $data{'base'}{'inline_subs'}{'sub-name'}{$subroutine}
                            = { 'loaded' => $code{'base.time'}->(5) };

                        ## collect them first ? ## [LLL]
                        $code{$subroutine} = $sub_cref;
                        $loaded_routines++;
                    }
                    ## resetting parameters ##
                    $src_comp        = undef;
                    $subroutine      = undef;
                    $prev_src_line   = undef;
                    $subsrc_linenum  = undef;
                    $sub_source_line = undef;
                    $source_encoding = undef;
                }
            }
        } elsif ( not defined $subroutine ) {
            $subroutine = $LAST_PAREN_MATCH;    ## start of new subroutine ##
            $line       = '';                   ## forgetting header line ##
        } else {
            $code{'base.error_exit.inline_loading'}
                ->( 'encountered not expected sub header str', $line );
        }
        $prev_src_line = $line if defined $subroutine;
    }

    if ( $loader_state->{'seekable-data-fh'} ) {
        ##  restore to data block start  ##
        seek( $data_block_filehandle,
            $loader_state->{'data-block-start-pos-in-bytes'}, 0 );
        $INPUT_LINE_NUMBER = $loader_state->{'data-input-start-line'};
        $data_block_filehandle->clearerr;
    }

    ## restoring permissions from backuped mode ##
    if ( $loader_state->{'fh-write-protected'} ) {
        if (chmod(
                oct( $loader_state->{'start-file-mode'} ),
                $data_block_filehandle
            )
        ) {
            undef $main::RESTORE_FH_ON_ERR;    ## cancel END block restore ##
            undef $main::RESTORE_PERMS_ON_ERR;
        } else {
            warn sprintf 'chmod %s : %s', $prog_name, lcfirst $OS_ERROR;
        }
    }

    $data{'base.inline_subs'}->{'loading-iteration'}++;

    return $loaded_routines;
}

##############################################################################

END {
    defined $code{'base.handler.end_code'}
        && $code{'base.handler.end_code'}->();
}

## keep CHECK for error handling in STDIN mode ##
##
CHECK { $main::DATA_BLOCK_START = __LINE__ + 1 }
__DATA__

                   ##                                 ##
                   ##  PROTOCOL 7 INLINE SUBROUTINES  ##
                   ##                                 ##

.:[ base.parser.pattern_split ]:.
:
: 7U3XUWC2AAAAJZWWWRDAEABBAELAAAAAOQX6LI7ABQPQHRK5AA6YFAAZDWMSBFWVEHLYALS3LYPP
: TNCDSKUOVCA3RHVXWMEQCJFNV4Y3QIUCBPSLM3E4NLWUJB3DFZHWQYRFHXJHIFFWBPCQ5FEPNROV
: 3KLH6AFBH47QJD45WD2BD3ETW3XT7AVK7UXJQHKHFGNR5T4T5UV5Y4NYEXVLFLMFD3JGS66NI5JR
: SHJRYMZSQPTRVCN2CX3624WWM726HZKKIOH5DPL3T6U3FXE7H4ZI46Y7A7B5WGPXGPLAONZCUSN4
: LQPPHXXQ3BKBTFGV52QQAHEDUUTTOONYZAFPOTEONEVGVS6TITNSPLYHG55C2EVM2KOCNVELSFD4
: RLIDDDTWA2KTHNKV7VEPHK3WMEBXRDHY4HWHTNMMGVE5Y3WXRUSVWKCJTNEENXTJ3KBMWTSXUX5H
: SYGIJQM6SGTAHOUPVJYUUVPXDWD3QQSNBKNAWZLUB7O3N4VNTZEMIXI6PRJ6M2FLGQD4IJ2ISRGW
: CS5EK7DWJ6XE4BMWASOXSPXXMG5OLFFTZEZ7P2XCG5CLYY5XNQWYWLWGWUOOF3UFFSCXXBSWPSZI
: 4ZTSJC542IBDGG5OTYTXWC3VPPGFMZLX63DBZ26RJNLTFPOJFA4FX6SAXJY27ZRJ6L6KJ2GTMMCD
: DS2OXQ62E55SWQH6EPUI5MLIMQTB7TOCBUQBXHV3YISK55RPUZX34XO4725W6EH7YEND53BOFJSL
: WITAREEHUXPE6FVTS5XD2REGYP5WQRCQXP4GIMYCLBKW6QKWPXITBN3YN2UUDW4KSIMPY3JRTH7Q
: YVFOMLAFUSF5TJH2PQTHXWJ46BYEJQ5FPDNCFV3OTOOUTHZGQSMYJMCXWBJ374JZSTNMXKEQJFR2
: JA5ED44SSU6VB7T2XLVGZ5M4KYGWFH7OM3BFQEL6PFVG7C3VIFLQJH7PRBVVATX5YUDUP4AWQ6CT
: PZ7D4D2MEGQH6ODZZXW72UJEU7XQ5OBSTRJP7RK3UTKCFARPF7QQMJ7YQ4AM4HX253ET2HLVXNHQ
: NYFGVXJ5HB7P4P24YHDDUVNE3Q44OEC3QS6J7L2HYNMNVACMIRIGSZREF57J6CJWMZXVWO3JKUGT
: 2GRA5OT2Y6FKCVLYYDRFSJLONTKYUNPVHKZ7YEWLNF3GVO3UZ2H7GOGCAI62XFYIDMJAXYSJJA6D
: 4QKJOAMQNU6HD2OVIOAHHJJ5AWDTKHGWPP43ZVTTSEVQ72ZSHGOBE77FXP7TQXGOGQ54XYUDDWQQ
: DIMPZI5DVFVZ5GUDNQGQ7EJINWIAOGSTXDIIF7NMJRKJT745PYRE5G6ECIU4MNAR355ILQ6W4OAS
: UH6DDITDK45TBWCGDISBSWX4UKA4MZ3MZUVZP4DJMSZAFVJZEYLEP45GFDARVWLJJWDLU7QC6I45
: DFLZ7NEVZ4TC5R2BW3MUZGV2TI4KDOM3FUNTK4VIWO3O23ESOENPG5VX2NDI4SKZAB3T5QQNDGAK
: SVPYCESPOQ5YMCBBVE5IFGZUMGHNYNGRYO3ZS6XD4ZAZDHGJBWGFGDM4I6PFMXM4YAY7LRI6SQAA
: 0000000000AAAA4ZWC33DGVDCDOAAB4ED2AGAAAATSWM7TWHCGP6YCAAAAAAAELFNA0000000000
:
: <PXU4LI6PAGTEUFVZANWFGP3KACXZ3N6CMQO2IT5Z7FOMFYKBJCEQ:0069:000247:000003104>
:.

.:[ base.protocol-7.source-key ]:.
:
: ## >:] ##
:
: qw| VM2RPWTXVNL4WGX7GEZM3CUO76MQ3MFYCDYX6XO3565637OOKFJA |
:
:.

#,,..,..,,,..,...,,,.,,,,,...,..,,,..,.,.,..,,..,,...,...,,..,..,,.,.,..,,.,.,
#FOKX3LMNZLZNDRJQTTDOSSGTQOCU5522XP4R2IDAATEDYJWSYC77NFKBN26AHJ3MXDHZWPHSCIPGA
#\\\|7SWTP7OWPRBL73X2AFZS5ULZVMPK6TK3PF3PTOZHLNJA7CAC7FK \ / AMOS7 \ YOURUM ::
#\[7]VKDW5AGYPXWN7BL4JUHXRDNBJ4ZGXHGLW4QZL3LJ4PNL7QWTEIAY 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
