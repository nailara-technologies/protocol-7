#!/usr/bin/perl
use v5.24;
use strict;
use English;
use warnings;
use Term::ReadLine;
use SigAction::SetCallBack;
use Time::HiRes qw| sleep |;

my $term = new Term::ReadLine('[ version control commit terminal ]');
$term->ornaments('mh,md');    # ,me;
$term->enableUTF8();
$term->MinLine(undef);

no warnings 'once';
$readline::rl_completion_function = "main::rl_filename_list_lcl";
use warnings 'once';

$| = 1;

( my $x, my $y ) = term_size();
my $y_pos = $y > 2 ? 2 : 1;

my $reset      = "\e[0m";
my $clear_all  = "\e[2J";
my $clear_upw  = "\e[1J";
my $clear_down = "\e[0J";
my $nailara_bg = "\e[48;2;9;5;41m";
my $blacklight = "\e[38;2;68;39;172m";

map { $SIG{$ARG} = \&exit } qw| INT TERM HUP |;

my $message;

my $min_len   = 13;
my $max_len   = 76;
my $last_line = '';
my $msg_delay = 0.7;
my $prompt    = join( '', "\e[${y_pos}H", ' :. ' );

clear();

while ( !length($message) ) {

    override_signals();
    print blacklight_line();
    my $line = $term->readline($prompt);

    $term->add_history($line) if $line ne $last_line;
    my $line_length = length($line);
    if ( $line_length < $min_len or $line_length > $max_len ) {
        clear();
        if ($line_length) {
            print blacklight_line()
                . "\r :.   .:[ len :. $line_length .:"
                . " $min_len .:. $max_len ]:."
                . "\r :. ";
            sleep $msg_delay;
            clear();
        }
    } else {
        my $return_code = system( qw| harmony -q |, $line );
        $return_code = $return_code >> 8 if $return_code > 0;
        die "$reset:\n:: harmony incovation error ::"
            . " $return_code :: \l$OS_ERROR ::\n\n"
            if $return_code != 0 and $return_code != 202;
        $message = $line if $return_code == 0;

        if ( $return_code == 202 ) {
            clear();
            print blacklight_line()
                . "\r :.   .:[ message not in harmony ]:."
                . "\r :. ";
            sleep $msg_delay;
            clear();

        }

    }
    $last_line = $line;
}
print $reset and clear();

exec( qw| git cim |, $message );

exit(4);

sub term_size {

    my $handle = shift // *STDIN;    ## use *STDOUT for pipe detection ##

    return undef if not -t $handle;
    state $size       = "\0" x 8;
    state $TIOCGWINSZ = 21523;

    ioctl( $handle, $TIOCGWINSZ, $size ) or return undef;
    my $size_aref
        = [ unpack 'S!S!S!S!', $size ];    ## <-- [<y>,<x>,<y-px>,<x-px>]
    return ( $size_aref->[1], $size_aref->[0] );

}

sub blacklight_line {
    ( $x, $y ) = term_size();

    if ( $y <= 1 ) {
        $y_pos = 1;
        my $s = $x <= 27 ? '' : ' ' x int( ( $x - 27 ) / 2 );
        print
            "\r$nailara_bg$clear_all$blacklight$s<<[ increase term-width ]>>\r"
            and sleep 1.2
            if $x < 47;
        return join( '', $blacklight, $nailara_bg, $clear_all );
    } else {
        $y_pos = 2;
        return join( '',
            "\e[${y_pos}H", $reset,      $clear_upw,
            $clear_down,    $nailara_bg, ' ' x $x,
            "\e[${y_pos}H", $nailara_bg, $blacklight );
    }
}

sub clear { print "\e[37m\e[H$clear_all" }

sub exit_term {
    print blacklight_line() . " :: commit aborted :: $reset\n\n";
    CORE::exit(4);
}

sub override_signals {
    map { SigAction::SetCallBack->sig_registry( $ARG, \&readline_signals ) }
        qw| INT TERM HUP |;
}

sub restore_signals {
    map { $SIG{$ARG} = \&parent_exit } qw| INT TERM HUP |;
}

sub readline_signals {
    my $sig_name = shift;
    $term->free_line_state;
    $term->cleanup_after_signal;
    exit_term();
}

#.............................................................................
#AHXDSUH5SALJNFQLJWLNXUHCWVBT4AEZVRRL5MBSVBPER2OWFLJKPZBNVRUSOVPZ7KHJ7673MAC3S
#::: JMP5YFDCHIA2VVDFDABIME6ZI7FRZ4INU5QGGOKK4KEXRPMSKKU :::: NAILARA AMOS :::
# :: VORXYZMQDJBH75ITSDMT2L7QDAJIPJLR7A42CC5IGIZPN6RJUQCI :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
