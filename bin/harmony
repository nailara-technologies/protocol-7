#!/usr/bin/perl

use v5.24;
use strict;
use English;
use warnings;
use Getopt::Std;
use Math::BigFloat;
use Term::ANSIColor;
use Digest::Elf qw| elf |;

getopts( 'canqvd:A:', \my %mode );

$mode{'d'} //= 0;   ## <-- divisor [ -d <n> ] : check result instead of input ##

my @asc_dec = qw| asc-dec -q |;

die ":\n:: divisor not valid [ expected numerical ]\n\n"
    if $mode{'d'} =~ m|^\-d(\d+(\.\d+)?)$|;

$mode{'q'} = 1 if $mode{'v'};

my $nailara_bg = color('on_r09g05b41');
my $nailara_fg = color('r38g46b153');
my $blacklight = color('r68g39b172');
my $green      = color('r71g195b6');
my $blink      = "\e[6m";
my $reset      = "\c[[m";

my %col = (
    'str' => $nailara_bg . $nailara_fg,
    'bg'  => $nailara_bg,
    'fg'  => $nailara_fg,
    'r'   => $reset,
    'm_y' => $nailara_bg . $blacklight,
    'm_n' => $nailara_bg . $green,
    'y'   => $blink . $blacklight,
    'n'   => $green,
    'b'   => $blacklight,
);

my $check_string = join( ' ', @ARGV );
my $elf_checksum = $mode{'n'} ? $check_string : elf($check_string);

my $accuracy = 13;

Math::BigFloat->round_mode('trunc');
Math::BigFloat->accuracy($accuracy);

if ( $mode{'d'} != 0 ) {
    $elf_checksum
        = Math::BigFloat->new($elf_checksum)->bdiv( $mode{'d'}, $accuracy );
    $check_string = $elf_checksum;
}

Math::BigFloat->accuracy( $accuracy + length($elf_checksum) );

my $false = '230769';    ## <-- # ःE ## FALSE ##
my $true  = '846153';    ## <-- #  ℍ5 ##  TRUE ##

my $calc     = Math::BigFloat->new($elf_checksum);
my $calc_str = $calc->bdiv( 13, $accuracy + length($elf_checksum) );

$calc_str = sprintf( '%0.7f', $calc_str )
    if $calc_str !~ m|\.(\d+)|
    or length($1) < $accuracy;

my $res_copy = $calc_str;

my $line_str = "< $calc_str >";
my $dot_pos  = index( $line_str, '.' ) - 1;
$dot_pos = length($calc_str) if $dot_pos < -1;
my $space_1 = ' ' x ( $dot_pos + 7 );

my $sp_0_len = 37 - length($check_string);
$sp_0_len = 5 if $sp_0_len < 5;

my $space_0 = ' ' x $sp_0_len;

$line_str =~ s{(*plb:\.)(\d*?)($true|0000+ )}
              {$1$col{'m_y'}$2$col{'r'}$col{'b'}}
    or $line_str =~ s{(*plb:\.)(\d*?)($false)}
                     {$1$col{'m_n'}$2$col{'r'}$col{'b'}};

my $return_code = 1;
$calc_str =~ s|^\d+\.||;
my $result = '< ? >';
if ( $calc_str =~ m|($true(*nla:\d+\.))| or $calc_str =~ m|0000+$| ) {
    $result = "$col{n}>:] $col{b} [ $col{y}true $col{'b'}>:]$col{r}$col{b} ]";
    $return_code = 0;
} elsif ( $calc_str =~ m|$false| ) {
    $result = "$col{fg}>:| $col{b} [ $col{'n'}not true$col{b} ]";
}

my $q = $mode{'n'} ? '' : "$col{'b'}'$col{'r'}";
print "\n$space_0$q$col{'str'}$check_string$col{'r'}$q $col{fg} === $col{r}"
    . " $result\n\n$space_1$line_str\n$col{r}\n"
    if not $mode{'q'};

say $res_copy if $mode{'v'};

if ( not $mode{'q'} and ( $return_code == 0 or $mode{'a'} ) ) {

    ( my $code = $mode{'c'} ? $check_string : $res_copy ) =~ s'(\.\d+$|\D+)''g;
    die ":\n:: check-string not numerical ['$code']\n\n" if $code !~ m|^\d+$|;
    ##
    if ( defined $mode{'A'} ) { ## -A'<param>' : asc-dec pass through parameters
        my $passthrough_params = join( ' ', split( ' +', $mode{'A'} ) );
        $passthrough_params = "-$passthrough_params"
            if $passthrough_params !~ m|^-|;
        ####
        system( @asc_dec, split( ' +', $passthrough_params ), $code );
    } else {
        ####
        push( @asc_dec, qw| -s0 | ) if $return_code == 1; ## no delay on 'false'
        system( @asc_dec, $code );
    }
    ##
    say $col{'b'} . '.. .,' . $col{'r'};
}

exit($return_code);

# ______________________________________________________________________________
#\\HVFSMSEA43LX4IRDICGOF5GROIYE5GNBKBCTE4UB47MWDBAV6E4WOB762PEEV7VT5K4K2E4I7O2GU
# \\ LKL7EQSB4PSXMXG44MX5I2DKP4GQT34CTFHS2QAZ4LFJI3BAUSM5 \\// C25519-BASE-32 //
#  \\// UVDONVVCLSKAVDKCGDZGXA46CUETEI3MNFWZRA7AU72F2JLIYCQ \\ CODE SIGNATURE \\
#   ````````````````````````````````````````````````````````````````````````````
