#!/usr/bin/perl

use strict;
use warnings;

use Math::BigFloat;
use Digest::Elf qw| elf |;

my $divisor = 0; ## <-- if set, divide result and check outcome instead of it .,
$divisor = $1
    if @ARGV > 1
    and $ARGV[0] =~ m|^\-d(\d+(\.\d+)?)$|
    and shift @ARGV;

my $quiet = ( @ARGV > 1 and $ARGV[0] eq '-q' and shift @ARGV ) ? 1 : 0;

my $numeric
    = (     @ARGV == 2
        and $ARGV[0] eq '-n'
        and $ARGV[1] =~ m|^\d+(\.\d+)?$|
        and shift @ARGV ) ? 1 : 0; ## <-- treat as number, not als hashed string

my %ANSI = (
    'str'     => "\c[[1m",
    'reset'   => "\c[[m",
    'match_y' => "\c[[34m",
    'match_n' => "\c[[33m",
    'color_y' => "\c[[6m\c[[34m",
    'color_n' => "\c[[6m\c[[1m",
);

my $check_string = join( ' ', @ARGV );
my $elf_checksum = $numeric ? $check_string : elf($check_string);

my $accuracy = 13;

Math::BigFloat->round_mode('trunc');
Math::BigFloat->accuracy($accuracy);

if ( $divisor != 0 ) {
    $elf_checksum
        = Math::BigFloat->new($elf_checksum)->bdiv( $divisor, $accuracy );
    $check_string = $elf_checksum;
}

Math::BigFloat->accuracy( $accuracy + length($elf_checksum) );

my $false = '230769';    ## <-- # ःE ## FALSE ##
my $true  = '846153';    ## <-- #  ℍ5 ##  TRUE ##

my $calc     = Math::BigFloat->new($elf_checksum);
my $calc_str = $calc->bdiv( 13, $accuracy + length($elf_checksum) );

$calc_str = sprintf( '%0.7f', $calc_str )
    if $calc_str !~ m|\.(\d+)|
    or length($1) < $accuracy;

my $line_str = "\n < $calc_str > ";
my $dot_pos  = index( $line_str, '.' ) - 1;
$dot_pos = length($calc_str) if $dot_pos < -1;
my $space = ' ' x $dot_pos;

$line_str =~ s{(*plb:\.)(\d*?)($true|0000+ )}
        {$1$ANSI{'match_y'}$2$ANSI{'reset'}}
    or $line_str =~ s{(*plb:\.)(\d*?)($false)}
        {$1$ANSI{'match_n'}$2$ANSI{'reset'}};

my $return_code = 1;
$calc_str =~ s|^\d+\.||;
my $result = '< ? >';
if ( $calc_str =~ m|($true(*nla:\d+\.))| or $calc_str =~ m|0000+$| ) {
    $result      = ">:]  [ is $ANSI{'color_y'}harmonic$ANSI{'reset'} =) ]";
    $return_code = 0;
} elsif ( $calc_str =~ m|$false| ) {
    $result = ">:|  [ $ANSI{'color_n'}not$ANSI{'reset'} harmonic. ]";
}
my $q = $numeric ? '' : "'";
print "\n$space $q$ANSI{'str'}$check_string$ANSI{'reset'}$q  ==="
    . "  $result\n$line_str\n\n"
    if not $quiet;

exit($return_code);

# ______________________________________________________________________________
#\\534FTEU3AZHCTNZPBYSQ5HPWR4LPX2LG43C3EDI6LK7ESV5ISI5SI3QKEJ754BWF52TVI4NDY5PRW
# \\ S5A7DTYLQNYI5OKTU6PMHP7YYA533YEZM4OVTMZ63JESVIVJRSNJ \\// C25519-BASE-32 //
#  \\// 5P4C7F2VRFEEUQGK6EDMU7W6GUVGKACBDOPJDPMNQYLDFKKQMCI \\ CODE SIGNATURE \\
#   ````````````````````````````````````````````````````````````````````````````
