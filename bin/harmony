#!/usr/bin/perl
use v5.24;
use strict;
use English;
use warnings;
use Getopt::Std;
use Math::BigFloat;
use Term::ANSIColor;
use Digest::Elf qw| elf |;
binmode( STDOUT, ':encoding(UTF-8)' );

no warnings 'experimental';

getopts( 'DcanhqvBl:d:A:T:Zz', \my %mode );

$mode{'A'} //= "-r4.2 -e -d$mode{z} -S"
    if $mode{'Z'}
    and defined $mode{'T'}
    and $mode{'T'} eq 'R';
$mode{'z'}
    //= 8;    ## <-- digit read size override for 'asc-dec' fullscreen mode
$mode{'A'} //= "-r4.2 -d$mode{z} -S"
    if $mode{'Z'};    ## -Z is 'full-screen' mode
$mode{'T'} //= rand(2) % 2 ? '851' : '857' if $mode{'Z'};   ## <-- full-screen
$mode{'T'} //= qw|    MS-ICELAND    |;  ## <-- 'asc-dec' table [ when in use ]
$mode{'l'} //= 50;                      ## <-- blue midnight wish entropy size
$mode{'d'} //= 0; ## <-- divisor [ -d <n> ] : check result instead of input ##
$mode{'B'} = !$mode{'B'};    ## BMW mode enabled by default

my @asc_dec = qw| asc-dec -q |;

die ":\n:: divisor not valid [ expected numerical ]\n\n"
    if $mode{'d'} =~ m|^\-d(\d+(\.\d+)?)$|;

$mode{'h'} = 1 if !$mode{'S'};
$mode{'q'} = 1 if $mode{'v'};

my $nailara_bg = color('on_r09g05b41');
my $nailara_fg = color('r38g46b153');
my $blacklight = color('r68g39b172');
my $green      = color('r71g195b6');
my $blink      = "\e[6m";
my $reset      = "\c[[m";

my %col = (
    'str' => $nailara_bg . $nailara_fg,
    'bg'  => $nailara_bg,
    'fg'  => $nailara_fg,
    'r'   => $reset,
    'm_y' => $nailara_bg . $green,
    'm_n' => $nailara_bg . $green,
    'y'   => $blink . $blacklight,
    'n'   => $green,
    'b'   => $blacklight,
);

my $check_string
    = Encode::decode_utf8( join( ' ', @ARGV ), 8 );    # [8:LEAVE_SRC]
my $elf_checksum = $mode{'n'} ? $check_string : sprintf "%09d",
    elf($check_string);

my $bmw_checksum;
chomp( $bmw_checksum = qx| bmw -d -$mode{'l'} '$check_string' | )
    if $mode{'B'};

my $accuracy = 17;

Math::BigFloat->round_mode('trunc');
Math::BigFloat->accuracy($accuracy);

if ( $mode{'d'} != 0 ) {
    $elf_checksum
        = Math::BigFloat->new($elf_checksum)->bdiv( $mode{'d'}, $accuracy );
    $check_string = $elf_checksum;
}

Math::BigFloat->accuracy( $accuracy + length($elf_checksum) );

my $false = '076923';    ## <-- #   ǽ ## FALSE ##
my $true  = '461538';    ## <-- #  ǍȚ ##  TRUE ##

our $assertion = { 'false' => $false, 'true' => $true };

my $calc     = Math::BigFloat->new($elf_checksum);
my $calc_str = $calc->bdiv( 13, $accuracy + length($elf_checksum) );

$calc_str = sprintf( '%0.18f', $calc_str )
    if $calc_str !~ m|\.(\d+)|
    or length($1) < $accuracy;

my $res_copy = $calc_str;

my $line_str = "< $calc_str >";
my $dot_pos  = index( $line_str, '.' ) - 1;
$dot_pos = length($calc_str) if $dot_pos < -1;
my $space_1 = ' ' x ( $dot_pos + 7 );

my $sp_0_len = 37 - length($check_string);
$sp_0_len = 5 if $sp_0_len < 5;

my $space_0 = ' ' x $sp_0_len;

$line_str =~ s{(*plb:\.)(\d*?)($true|0000+ )}
              {$1$col{'m_y'}$2$col{'r'}$col{'b'}}
    or $line_str =~ s{(*plb:\.)(\d*?)($false)}
                     {$1$col{'m_n'}$2$col{'r'}$col{'b'}};

my $return_code = 1;
$calc_str =~ s|^\d+\.||;
my $result = '< ? >';
if ( $calc_str =~ m|($true(*nla:\d+\.))| or $calc_str =~ m|0000+$| ) {
    $result = "$col{n}>:] $col{b} [ $col{y}true $col{'b'}>:]$col{r}$col{b} ]";
    $return_code = 0;
} elsif ( $calc_str =~ m|$false| ) {
    $result = "$col{fg}>:| $col{b} [ $col{'n'}not true$col{b} ]";
}

$col{'str'} = $green if $return_code == 0;

my $q = $mode{'n'} ? '' : "$col{'b'}'$col{'r'}";
print "\n$space_0$q$col{'str'}$check_string$col{'r'}$q $col{fg} === $col{r}"
    . " $result\n\n$space_1$line_str\n$col{r}\n"
    if not $mode{'q'};

my $status = $return_code == 0 ? 'true' : 'false';

display_result( $status, $res_copy, $mode{'T'}, $bmw_checksum );

say $res_copy if $mode{'v'};

exit($return_code);

sub display_result {

    my $status = shift;    ## [ true | false ]

    ( my $result = shift ) =~ s{\.(\d+)?$|\D+}{}g;
    my $sub_zulum = $LAST_PAREN_MATCH;

    my $table_name = shift // '857';

    my $display = shift;
    if ( defined $display ) {
        $display =~ s{\.(\d+)?$|\D+}{}g;
        $result = $display if length($display);
    }

    my $offset
        = $sub_zulum =~ m|0{6,}$|
        ? 0
        : index( $sub_zulum, $assertion->{$status} );

    my $shift_mode = 'right';    ## [ left | right ] ##

    my $result_1_0;
    my $result_1_1;

    my $s_len         = 1 + length($result) % 3;
    my $change_offset = scalar( length($result) % 3 ? 1 : 0 );

    # say "< offset > $offset";
    # say "<  s-len > $s_len";
    # say "< assert > $change_offset";
    # say '';
    # say "< res-0000.0 > '$result'\n\n";

    if ( $shift_mode eq 'left' ) {
        $result_1_0 = substr( $result, $offset, length($result) - $s_len );
        $result_1_1 = substr( $result, 0,       $offset );
    } elsif ( $shift_mode eq 'right' ) {
        $result_1_0 = substr( $result, -$offset, $offset );
        $result_1_1 = substr( $result, 0,        length($result) - $offset );
    }    # else [ 'none' ]

    # say "< res-0010 > '$result_1_0'\n";
    # say "< res-0110 > '$result_1_1'\n";
    # say '';

    $result = join( '', $result_1_0, $result_1_1 );

    # say "< res-0000.1 > '$result'";

    if ( not $mode{'q'} ) {

        @asc_dec = ( qw|asc-dec -q -r0 -C|, $table_name );

        push( @asc_dec, qw| -s0 | ) if $status ne 'true';

        my @exec_args;

        $check_string =~ s'(\.\d+$|\D+)''g if $mode{'c'};

        ( my $code = $mode{'c'} ? $check_string : $result );
        die ":\n:: check-string not numerical ['$code']\n\n"
            if $code !~ m|^\d+$|;
        ##
        if ( defined $mode{'A'} )
        {    ## -A'<param>' : asc-dec pass through parameter
            my $passthrough_params = join( ' ', split( ' +', $mode{'A'} ) );
            $passthrough_params = "-$passthrough_params"
                if $passthrough_params !~ m|^-|;
            ####
            @exec_args
                = ( @asc_dec, split( ' +', $passthrough_params ), $code );
        } else {
            ####
            push( @asc_dec, qw| -s0 | )
                if $return_code == 1;    ## no delay on false
            @exec_args = ( @asc_dec, $code );
        }

        say "< exec-args > " . join( ' ', @exec_args ) if $mode{'D'};
        system(@exec_args);

        say $col{'b'} . '.. .,' . $col{'r'};
    }

}

## [ NOTES ]
# 2 : îŤΛLΛL
# 0 : ʘɧƀɧƀf�ʘɧƀɧƀf�ʘɧƀɧƀf

#.............................................................................
#HHVRQG4HXH4IGKWJQ3GKLSGREKJCPYBKTXHGSUGMDI3CCU4JBNMCLKGWWSBMPGF7PF4X4CAIGKOJG
#::: 4GAVKEM6BUSILLJ7XRJPPYTCZMK3JT6F7YRIZZYU3VEZBFUNK5O :::: NAILARA AMOS :::
# :: Q4XIPXVRZQCU4LNGLR3NF25Z3L73KS7766PX6AHK5QOH4IQB2GAQ :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
