#!/usr/bin/perl

use v5.24;
use strict;
use English;
use warnings;
use Getopt::Std;
use Math::BigFloat;
use Term::ANSIColor;
use Digest::Elf qw| elf |;

getopts( 'qvd:A:', \my %mode );

$mode{'d'} //= 0;   ## <-- divisor [ -d <n> ] : check result instead of input ##

my @asc_dec = qw| asc-dec -q -C cp10007 -u6 -r0 |;

die ":\n:: divisor not valid [ expected numerical ]\n\n"
    if $mode{'d'} =~ m|^\-d(\d+(\.\d+)?)$|;

my $numeric
    = (     @ARGV == 2
        and $ARGV[0] eq '-n'
        and $ARGV[1] =~ m|^\d+(\.\d+)?$|
        and shift @ARGV ) ? 1 : 0; ## <-- treat as number, not als hashed string

$mode{'q'} = 1 if $mode{'v'};

my $nailara_bg = color('on_r09g05b41');
my $nailara_fg = color('r38g46b153');
my $blacklight = color('r68g39b172');
my $green      = color('r71g195b6');
my $blink      = "\e[6m";
my $reset      = "\c[[m";

my %col = (
    'str' => $nailara_bg . $nailara_fg,
    'bg'  => $nailara_bg,
    'fg'  => $nailara_fg,
    'r'   => $reset,
    'm_y' => $nailara_bg . $blacklight,
    'm_n' => $nailara_bg . $green,
    'y'   => $blink . $blacklight,
    'n'   => $green,
    'b'   => $blacklight,
);

my $check_string = join( ' ', @ARGV );
my $elf_checksum = $numeric ? $check_string : elf($check_string);

my $accuracy = 13;

Math::BigFloat->round_mode('trunc');
Math::BigFloat->accuracy($accuracy);

if ( $mode{'d'} != 0 ) {
    $elf_checksum
        = Math::BigFloat->new($elf_checksum)->bdiv( $mode{'d'}, $accuracy );
    $check_string = $elf_checksum;
}

Math::BigFloat->accuracy( $accuracy + length($elf_checksum) );

my $false = '230769';    ## <-- # ःE ## FALSE ##
my $true  = '846153';    ## <-- #  ℍ5 ##  TRUE ##

my $calc     = Math::BigFloat->new($elf_checksum);
my $calc_str = $calc->bdiv( 13, $accuracy + length($elf_checksum) );

$calc_str = sprintf( '%0.7f', $calc_str )
    if $calc_str !~ m|\.(\d+)|
    or length($1) < $accuracy;

my $res_copy = $calc_str;

my $line_str = "\n < $calc_str > ";
my $dot_pos  = index( $line_str, '.' ) - 1;
$dot_pos = length($calc_str) if $dot_pos < -1;
my $space = ' ' x $dot_pos;

$line_str =~ s{(*plb:\.)(\d*?)($true|0000+ )}
              {$1$col{'m_y'}$2$col{'r'}$col{'b'}}
    or $line_str =~ s{(*plb:\.)(\d*?)($false)}
                     {$1$col{'m_n'}$2$col{'r'}$col{'b'}};

my $return_code = 1;
$calc_str =~ s|^\d+\.||;
my $result = '< ? >';
if ( $calc_str =~ m|($true(*nla:\d+\.))| or $calc_str =~ m|0000+$| ) {
    $result = "$col{n}>:]$col{b} "
        . " [ $col{y}true $col{r}$col{fg}=)$col{b} ]";
    $return_code = 0;
} elsif ( $calc_str =~ m|$false| ) {
    $result = "$col{fg}>:| $col{b} [ $col{'n'}not true$col{b} ]";
}

my $q = $numeric ? '' : "$col{'b'}'$col{'r'}";
print "\n$space $q$col{'str'}$check_string$col{'r'}$q  $col{fg}===$col{r}"
    . "  $result\n$line_str\n$col{r}\n"
    if not $mode{'q'};

say $res_copy if $mode{'v'};

if ( not $mode{'q'} ) {
    if ( defined $mode{'A'} ) {
        system( @asc_dec, split( ' ', $mode{'A'} ), $res_copy );
    } else {
        push(@asc_dec,qw| -s0 |) if $return_code == 1;
        system( @asc_dec, $res_copy );
    }
    say $col{'b'} . '.. .,' . $col{'r'};
}

exit($return_code);

# ______________________________________________________________________________
#\\C2Q5OBYTSJZ56S2Z5BXBZ6UTUVBYIRLQCMZFANYB472RV2XQKOFTXWQM2V5HU7ZTIHUNTAU4AVBII
# \\ NNBEHHRTATOEAVWD7MLVUUWTBTCOXBDM4NQJQ6KBRYTGTZQNWON5 \\// C25519-BASE-32 //
#  \\// 2LWUJ2T4OG7WAP2RKS5YN7OW3PBPCK5FUP55A6PDKY2Q3O6G6BQ \\ CODE SIGNATURE \\
#   ````````````````````````````````````````````````````````````````````````````
