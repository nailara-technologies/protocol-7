#!/usr/bin/perl

use v5.24;
use strict;
use English;
use warnings;
use Getopt::Std;
use Math::BigFloat;
use Term::ANSIColor;
use Digest::Elf qw| elf |;

getopts( 'nqvd:A:', \my %mode );

$mode{'d'} //= 0;   ## <-- divisor [ -d <n> ] : check result instead of input ##

my @asc_dec = qw| asc-dec -q -C cp10007 -u6 -r0 |;

die ":\n:: divisor not valid [ expected numerical ]\n\n"
    if $mode{'d'} =~ m|^\-d(\d+(\.\d+)?)$|;

$mode{'q'} = 1 if $mode{'v'};

my $nailara_bg = color('on_r09g05b41');
my $nailara_fg = color('r38g46b153');
my $blacklight = color('r68g39b172');
my $green      = color('r71g195b6');
my $blink      = "\e[6m";
my $reset      = "\c[[m";

my %col = (
    'str' => $nailara_bg . $nailara_fg,
    'bg'  => $nailara_bg,
    'fg'  => $nailara_fg,
    'r'   => $reset,
    'm_y' => $nailara_bg . $blacklight,
    'm_n' => $nailara_bg . $green,
    'y'   => $blink . $blacklight,
    'n'   => $green,
    'b'   => $blacklight,
);

my $check_string = join( ' ', @ARGV );
my $elf_checksum = $mode{'n'} ? $check_string : elf($check_string);

my $accuracy = 13;

Math::BigFloat->round_mode('trunc');
Math::BigFloat->accuracy($accuracy);

if ( $mode{'d'} != 0 ) {
    $elf_checksum
        = Math::BigFloat->new($elf_checksum)->bdiv( $mode{'d'}, $accuracy );
    $check_string = $elf_checksum;
}

Math::BigFloat->accuracy( $accuracy + length($elf_checksum) );

my $false = '230769';    ## <-- # ःE ## FALSE ##
my $true  = '846153';    ## <-- #  ℍ5 ##  TRUE ##

my $calc     = Math::BigFloat->new($elf_checksum);
my $calc_str = $calc->bdiv( 13, $accuracy + length($elf_checksum) );

$calc_str = sprintf( '%0.7f', $calc_str )
    if $calc_str !~ m|\.(\d+)|
    or length($1) < $accuracy;

my $res_copy = $calc_str;

my $line_str = "< $calc_str >";
my $dot_pos  = index( $line_str, '.' ) - 1;
$dot_pos = length($calc_str) if $dot_pos < -1;
my $space_1 = ' ' x ( $dot_pos + 7 );

my $sp_0_len = 37 - length($check_string);
$sp_0_len = 5 if $sp_0_len < 5;

my $space_0  = ' ' x $sp_0_len;

$line_str =~ s{(*plb:\.)(\d*?)($true|0000+ )}
              {$1$col{'m_y'}$2$col{'r'}$col{'b'}}
    or $line_str =~ s{(*plb:\.)(\d*?)($false)}
                     {$1$col{'m_n'}$2$col{'r'}$col{'b'}};

my $return_code = 1;
$calc_str =~ s|^\d+\.||;
my $result = '< ? >';
if ( $calc_str =~ m|($true(*nla:\d+\.))| or $calc_str =~ m|0000+$| ) {
    $result = "$col{n}>:] $col{b} [ $col{y}true $col{'b'}>:]$col{r}$col{b} ]";
    $return_code = 0;
} elsif ( $calc_str =~ m|$false| ) {
    $result = "$col{fg}>:| $col{b} [ $col{'n'}not true$col{b} ]";
}

my $q = $mode{'n'} ? '' : "$col{'b'}'$col{'r'}";
print "\n$space_0$q$col{'str'}$check_string$col{'r'}$q $col{fg} === $col{r}"
    . " $result\n\n$space_1$line_str\n$col{r}\n"
    if not $mode{'q'};

say $res_copy if $mode{'v'};

if ( not $mode{'q'} ) {
    if ( defined $mode{'A'} ) {
        system( @asc_dec, split( ' ', $mode{'A'} ), $res_copy );
    } else {
        push( @asc_dec, qw| -s0 | ) if $return_code == 1;
        system( @asc_dec, $res_copy );
    }
    say $col{'b'} . '.. .,' . $col{'r'};
}

exit($return_code);

# ______________________________________________________________________________
#\\2SAJJDYPXBZKYQF7MOX4APHDZNSNCQA6Z254ALZBYWSTPP4G5Z7473FSGQAQHBQMIH5ESEBGI7BRA
# \\ 6OG6PQ27CTJBK3L6UBY7INOP2FLTDQAHPLB7ACCLR6TYVO6YNJFS \\// C25519-BASE-32 //
#  \\// GYHQ4N6SWQEJSV5TFYQIY362UUJIWDDTTMR74UHPP4UJWMQF2DQ \\ CODE SIGNATURE \\
#   ````````````````````````````````````````````````````````````````````````````
