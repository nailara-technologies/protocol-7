#!/usr/bin/perl
use v5.24;
use strict;
use English;
use warnings;
use Digest::Elf;
use Getopt::Std;
use Math::BigFloat;
use IPC::System::Simple qw| capturex |;
binmode( STDOUT, ':encoding(UTF-8)' );

getopts( 'VNDcanhqvBl:d:A:T:Zz', \my %option );

no warnings 'experimental';

my $false = '076923'; ##  <--  LΛ == FALSE   ## [      1 / 13 =     [0.]076923.]
##                                                                      ^^^^^^
my $true = '461538';  ##  <--  ǍȚ == TRUE    ## [ 230769 / 13 = [17751.]461538.]
##                                                ^^^^^^                ^^^^^^
##                                       result rolls over with divided number

## [ NOTES ]
#
## MAYA [0]910 Ύ [4] [0]511 ǿ [0]932 Τ [0]076 L [0]923 Λ
## MAYA [0]910 Ύ [4] [0]511 ǿ [0]932 Τ [0]461 Ǎ [0]538 Ț
#
## (˃˫
#
##         Azurum : 0010 :   light    :  male  :. [0]040 :: (
##          Zulum : 0000 :    dark    : female .: [0]707 :: ˃
## [ 7 ] Septioum : 0110 : blacklight :  party :: [0]747 :: ˫

our $assertion = { 'false' => $false, 'true' => $true };

$option{'A'} //= "-r4.2 -e -d$option{z} -S"
    if $option{'Z'}
    and defined $option{'T'}
    and $option{'T'} eq 'R';
$option{'z'}
    //= 8;    ## <-- digit read size override for 'asc-enc' fullscreen mode
$option{'A'} //= "-r4.2 -d$option{z} -S"
    if $option{'Z'};    ## -Z is 'full-screen' mode
$option{'T'} //= rand(2) % 2 ? '851' : '857' if $option{'Z'}; ## <-- full-screen
$option{'T'} //= qw| 17 |;    ## <-- 'asc-enc' table [ when in use ]
$option{'l'} //= 50;          ## <-- blue midnight wish entropy size
$option{'d'} //= 0; ## <-- divisor [ -d <n> ] : check result instead of input ##
$option{'B'} = !$option{'B'};    ## BMW mode enabled by default

my @asc_enc = qw| asc-enc -q |;

die ":\n:: divisor not valid [ expected numerical ]\n\n"
    if $option{'d'} =~ m|^\-d(\d+(\.\d+)?)$|;

$option{'h'} = 1 if !$option{'S'};
$option{'q'} = 1 if $option{'v'} or $option{'V'};

my $nailara_bg  = "\e[48;2;9;5;41m";
my $blacklight  = "\e[38;2;68;39;172m";
my $nailara_fg  = "\e[38;2;38;46;153m";
my $error_color = "\e[38;2;197;141;7m";
my $neon_green  = "\e[38;2;71;195;6m";
my $blink       = "\e[6m";
my $bold        = "\e[1m";
my $reset       = "\e[0m";

# my $reset     = "\c[[m";

$SIG{'INT'} = sub { print "\b\b"; int_exit() };

my %col = (
    'str' => $nailara_bg . $nailara_fg,
    'bg'  => $nailara_bg,
    'fg'  => $nailara_fg,
    'r'   => $reset,
    'm_y' => $nailara_bg . $neon_green,
    'm_n' => $nailara_bg . $neon_green,
    'y'   => $blink . $blacklight,
    'n'   => $neon_green,
    'b'   => $blacklight,
);

my $check_string = Encode::decode_utf8( join( ' ', @ARGV ), 8 ); # [8:LEAVE_SRC]
my $elf_checksum = $option{'n'} ? $check_string : elf_checksum($check_string);

my $bmw_checksum;
eval {
    chomp( $bmw_checksum
            = capturex( qw| bmw -d |, "-$option{'l'}", $check_string ) );
} if $option{'B'};

my $accuracy = 17;

Math::BigFloat->round_mode('trunc');
Math::BigFloat->accuracy($accuracy);

if ( $option{'d'} != 0 ) {
    $elf_checksum
        = Math::BigFloat->new($elf_checksum)->bdiv( $option{'d'}, $accuracy );
    $check_string = $elf_checksum;
}

Math::BigFloat->accuracy( $accuracy + length($elf_checksum) );

my $calc     = Math::BigFloat->new($elf_checksum);
my $calc_str = $calc->bdiv( 13, $accuracy + length($elf_checksum) );

$calc_str = sprintf( '%0.18f', $calc_str )
    if $calc_str !~ m|\.(\d+)|
    or length($1) < $accuracy;

my $res_copy = $calc_str;

my $line_str = "< $calc_str >";
my $dot_pos  = index( $line_str, '.' ) - 1;
$dot_pos = length($calc_str) if $dot_pos < -1;
my $space_1 = ' ' x ( $dot_pos + 7 );

my $sp_0_len = 37 - length($check_string);
$sp_0_len = 5 if $sp_0_len < 5;

my $space_0 = ' ' x $sp_0_len;

$line_str =~ s{(*plb:\.)(\d*?)($true|0000+ )}
              {$1$col{'m_y'}$2$col{'r'}$col{'b'}}
    or $line_str =~ s{(*plb:\.)(\d*?)($false)}
                     {$1$col{'m_n'}$2$col{'r'}$col{'b'}};

my $return_code = 1;
$calc_str =~ s|^\d+\.||;
my $result = '< ? >';
if ( $calc_str =~ m|($true(*nla:\d+\.))| or $calc_str =~ m|0000+$| ) {
    $result = "$col{n}>:] $col{b} [ $col{y}true $col{'b'}>:]$col{r}$col{b} ]";
    $return_code = 0;
} elsif ( $calc_str =~ m|$false| ) {
    $result = "$col{fg}>:| $col{b} [ $col{'n'}not true$col{b} ]";
}

$col{'str'} = $neon_green if $return_code == 0;

my $q = $option{'n'} ? '' : "$col{'b'}'$col{'r'}";
print "\n$space_0$q$col{'str'}$check_string$col{'r'}$q $col{fg} === $col{r}"
    . " $result\n\n$space_1$line_str\n$col{r}\n"
    if not $option{'q'} and not $option{'N'};

my $status = $return_code == 0 ? 'true' : 'false';

( my $num_val = $res_copy ) =~ s{\.(\d+)?$|\D+}{}g;

if ( not $option{'q'} ) {
    display_result( $status, $res_copy, $option{'T'}, $bmw_checksum );
}

if ( $option{'v'} ) {    ## entire division by 13 result ##
    say $res_copy;
} elsif ( $option{'V'} ) {    ## first result part ##
    say $num_val;
}

exit($return_code);

sub display_result {

    my $status = shift;    ## [ true | false ]

    ( my $result = shift ) =~ s{\.(\d+)?$|\D+}{}g;
    my $sub_zulum = $LAST_PAREN_MATCH;

    my $table_name = shift // '857';

    my $display = shift;
    if ( defined $display ) {
        $display =~ s{\.(\d+)?$|\D+}{}g;
        $result = $display if length($display);
    }

    my $offset
        = $sub_zulum =~ m|0{6,}$|
        ? 0
        : index( $sub_zulum, $assertion->{$status} );

    my $shift_mode = 'right';    ## [ left | right ] ##

    my $result_1_0;
    my $result_1_1;

    my $s_len         = 1 + length($result) % 3;
    my $change_offset = scalar( length($result) % 3 ? 1 : 0 );

    # say "< offset > $offset";
    # say "<  s-len > $s_len";
    # say "< assert > $change_offset";
    # say '';
    # say "< res-0000.0 > '$result'\n\n";

    if ( $shift_mode eq 'left' ) {
        $result_1_0 = substr( $result, $offset, length($result) - $s_len );
        $result_1_1 = substr( $result, 0,       $offset );
    } elsif ( $shift_mode eq 'right' ) {
        $result_1_0 = substr( $result, -$offset, $offset );
        $result_1_1 = substr( $result, 0,        length($result) - $offset );
    }    # else [ 'none' ]

    # say "< res-0010 > '$result_1_0'\n";
    # say "< res-0110 > '$result_1_1'\n";
    # say '';

    $result = join( '', $result_1_0, $result_1_1 );

    # say "< res-0000.1 > '$result'";

    @asc_enc = ( qw|asc-enc -q -r0 -C|, $table_name );

    push( @asc_enc, qw| -s0 | ) if $status ne 'true';

    push( @asc_enc, qw| -d4 | );

    my @exec_args;

    $check_string =~ s'(\.\d+$|\D+)''g if $option{'c'};

    ( my $code = $option{'c'} ? $check_string : $result );
    die ":\n:: check-string not numerical ['$code']\n\n"
        if $code !~ m|^\d+$|;
    ##
    if ( defined $option{'A'} )
    {    ## -A'<param>' : asc-enc pass through parameter
        my $passthrough_params = join( ' ', split( ' +', $option{'A'} ) );
        $passthrough_params = "-$passthrough_params"
            if $passthrough_params !~ m|^-|;
        ####
        @exec_args = ( @asc_enc, split( ' +', $passthrough_params ), $code );
    } else {
        ####
        push( @asc_enc, qw| -s0 | ) if $return_code == 1;    ## false. no delay
        @exec_args = ( @asc_enc, $code );
    }

    say "< exec-args > " . join( ' ', @exec_args ) if $option{'D'};

    ##########################################
    int_exit() if system(@exec_args) >> 8 == 4;
    ##########################################

    return if $status eq 'false';

    my $assertion_result = system( $PROGRAM_NAME, '-q', $num_val ) >> 8;
    if ( $assertion_result == 0 ) {    ##  deeper truth .,
        int_exit() if system( $PROGRAM_NAME, '-N', $num_val ) >> 8 == 4;
    } elsif ( $assertion_result == 4 ) {
        int_exit();
    } else {
        say $col{'b'} . ':.,' . $col{'r'} . "\n";
    }
}

sub elf_checksum {
    my $input    = shift // '';
    my $checksum = '000000000';
    return $checksum                     if not length($input);
    $checksum = Digest::Elf::elf($input) if length($input) <= 47;
    chomp( $checksum = capturex( 'elf', $input ) )
        if length($input) > 47
        or length($checksum) > 9;
    return sprintf( "%09d", $checksum );
}

sub int_exit { print $reset; exit(4) }

## [ NOTES ]
# 0 : ǍȚ <-- true
# 1 : ΛL <-- false

#.............................................................................
#3ZC23CD3LNWBZM6VIQXOHMCHXS6N6QSX4SCHNYXSZDUR3XVQWK42OINDVT6S6VVLNKOEVXQ2H4YZA
#::: LEI4O3MN7BUR7CQMD7BEUDTNSIICBIJOVVMQRKO7BQNIE63GNF2 :::: NAILARA AMOS :::
# :: PXCH5C3VK7RZ4ULOY2SYVPLXIUWWG3XF6V74CQZ4UBVQRAVCHKBY :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
