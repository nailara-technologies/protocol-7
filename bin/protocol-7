#!/usr/bin/env -S perl -C31
use v5.28.0;
use strict;
use warnings;
use English;

# globals
our %code;
our %data;
our %KEYS;
our %ANSI;
our $SUB_NAME;

prepare_subs();

&{ $code{'base.init_exec'} };

$code{'base.load_code'}->('base');

my $zenkaname;

if ( $PROGRAM_NAME =~ m|^.*protocol-7\.| ) {
    $zenkaname = lc($PROGRAM_NAME);
    $zenkaname =~ s|^.*protocol-7\.||g;
} elsif ( defined $ARGV[0] and $ARGV[0] =~ m|^([^\-].*)| ) {
    $zenkaname = $LAST_PAREN_MATCH;
    shift(@ARGV);
}

( $zenkaname, @ARGV ) = ( split( m| +|, $zenkaname ), @ARGV )
    if defined $zenkaname and index( $zenkaname, ' ' ) != -1;

( $data{'system'}{'args'} = join( ' ', @ARGV ) )
    =~ s| *-[v]+h?z?d?( *)|$LAST_PAREN_MATCH|;

if ( defined $zenkaname and $zenkaname ne '' ) {
    if ( $data{'system'}{'startup_initcode'} ) {
        $data{'startup'}{'init_code'} = [];
        $code{'log.noerr'}->('< awaiting init-code on stdin');
        while (<STDIN>) {
            push( @{ $data{'startup'}{'init_code'} }, $ARG );
        }
        my $lines = @{ $data{'startup'}{'init_code'} };
        my $s     = $lines != 1 ? 's' : '';
        $code{'log.noerr'}->("> read $lines line$s of init-code");
    }
    my $node_name = $data{'system'}{'node'}{'name'};

    $code{'base.init'}->( join( '.', $node_name, $zenkaname ) );

} else {
    if ( !@ARGV or not defined $data{'system'}{'zenka'}{'name'} ) {
        $data{'system'}{'zenka'}{'name'} = '<stdin>';
    }
    $PROGRAM_NAME = "protocol-7.$data{'system'}{'zenka'}{'name'}";
    $RS           = "\n";

    my @zenka_code = <STDIN>;

    if ( $data{'system'}{'background_mode'} ) {
        $code{'base.process-into-background'}->();
    }

    if (@zenka_code) {
        $data{'base'}{'config_parser'}{'cfg_type'}  = 'start_cfg';
        $data{'base'}{'config_parser'}{'cfg_name'}  = 'zenka';
        $data{'base'}{'config_parser'}{'cfg_descr'} = '<STDIN>';
        $code{'base.execute_zenka_code'}
            ->( $code{'base.parser.config'}->( \@zenka_code ) );
    }
}

$code{'log.noerr'}->("done.");
close;
exit;

# :: definition of basic subroutines and zenka initialization ::

sub prepare_subs {

    ## SOME BASIC SECURITY HARDENING ##

    $ENV{'PATH'} = '/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin';
    delete @ENV{qw| IFS CDPATH ENV BASH_ENV |};
    $ENV{'LC_NUMERIC'} = 'en_US.UTF-8';
    umask(0027);    ## <-- restricted, set manually .., ###

    BEGIN {
        ## character whitelist ##
        my $char_map = qr|([^0-9a-zA-Z\-\+\.:_\[\]\/]+)|;

        die "\n\n << invalid characters [ '"
            . ${^CAPTURE}[0] . "' ]"
            . " in program name '$PROGRAM_NAME' >>\n\n\n"
            if $PROGRAM_NAME =~ $char_map;
        my $bin_path = $PROGRAM_NAME;
        while ( my $link_target = readlink($bin_path) ) {
            die "\n\n<< invalid characters [ '"
                . ${^CAPTURE}[0]
                . "' ] in program name"
                . " link target '$link_target' >>\n\n\n"
                if $link_target =~ $char_map;
            $bin_path = $link_target;
        }
        ( my $local_lib_path = $bin_path )
            =~ s|/[^/]+/[^/]+$|/data/lib-path/pm|;
        unshift( @INC, $local_lib_path ) if -d $local_lib_path;
    }

    # somewhat reduntant with -C31 ... to be decided later [which to drop]..,
    use open ':encoding(UTF-8)';
    map { binmode( $ARG, ':encoding(UTF-8)' ) } ( *STDIN, *STDOUT, *STDERR );

    eval { use Text::Wrap qw| wrap | };    ## <-- used in 'base.load_code' ##

    # installing 'Time::HiRes' versions of 'base.time' and 'base.sleep'
    my $th_ref
        = (
              eval 'use Time::HiRes; return [ '
            . 'sub{ my $f = $_[0]; $f = 6 if not defined $f or $f =~ m|\D|;'
            . ' sprintf( "%.${f}f", Time::HiRes::time ) }, \&Time::HiRes::sleep'
            . ' ]' );
    $data{'system'}{'perl_module'}{'installed'}{'Time::HiRes'} = 1
        if defined $th_ref and ref($th_ref) eq 'ARRAY';
    $th_ref = [ sub { time() }, sub { select( undef, undef, undef, $_[0] ) } ]
        if not defined $th_ref
        or ref($th_ref) ne 'ARRAY';
    $code{'base.time'}  = \&{ $th_ref->[0] };
    $code{'base.sleep'} = \&{ $th_ref->[1] };
    undef $th_ref;

################################################################################

    $code{'base.choose_true_pid'} = sub {
        local $SIG{'CHLD'} = 'IGNORE';
        $data{'system'}{'start'}{'fork-count'} //= 0;
        local $data{'system'}{'verbosity'}{'console'}      = 1;
        local $data{'system'}{'verbosity'}{'zenka_buffer'} = 1;
        ## choose as TRUE asserted PID by forking ##
        my $fork_start_time = sprintf( "%.5f", &{ $code{'base.time'} } );
        local $data{'system'}{'start'}{'zenka_buffer'} = 1;
        while ( not $code{'base.assert.harmony'}->($PID) ) {
            $data{'system'}{'start'}{'fork-count'}++;
            my $new_pid = fork();
            last    if not defined $new_pid;    ## cannot fork ##
            exit(0) if $new_pid != 0;
        }
        $data{'system'}{'start-up'}{'fork-duration'}
            = $data{'system'}{'start'}{'fork-count'}
            ? sprintf( "%.5f", &{ $code{'base.time'} } - $fork_start_time )
            : 0;
    };

################################################################################

    $code{'base.ntime'} = sub { # [ netw. time : secs from 2002-06-05 * 4200 ]
        my $param        = shift // 0;
        my $want_harmony = shift // $data{'base'}{'ntime-harmony'} // 1;
        my $ntime_start  = $data{'base'}{'ntime_ustart'} //= 1023228000;

        my $retries_left    = 24;    ## <-- configure [ retries-max ]
        my $collision_delay = 0;
        my $last_time       = 0;
        my $unix_precision;
        my $ntime_precision;

        $data{'base'}{'retry-count'}{'ntime'} //= 0;

        my ( $unix_time, $precision ) = ( undef, 0 );
        if ( length($param) >= 9 ) {    # < unix time + inherited precision >
            $unix_time      = $param;
            $unix_precision = length( ${^CAPTURE}[0] )
                if $unix_time =~ m{\.(\d+)$};
            $ntime_precision = $unix_precision - 2;
            $ntime_precision = 0 if $ntime_precision < 0;

        } else {
            $ntime_precision = $param;
            $ntime_precision = 8 if $ntime_precision > 8;
            $unix_precision  = $ntime_precision + 2;
            $unix_precision  = 11 if $unix_precision > 11;
        }
        my $zulum_len = $unix_precision - 1;
        $collision_delay = join( '', '0.', '0' x $zulum_len, '7' );

    RETRY_BASE_NTIME:
        $last_time = $unix_time if defined $unix_time;
        $unix_time = $code{'base.time'}->($unix_precision);

        if ( $unix_time == $last_time ) {    ## same input \ collision ##
            Time::HiRes::sleep($collision_delay);
            goto RETRY_BASE_NTIME;
        }

        my $ntime = sprintf( "%.0${ntime_precision}f",
            ( ( $unix_time - $ntime_start ) * 4200 ) );

        if (    $want_harmony == 1
            and length($param) < 9
            and $code{'base.assert.harmony'}->( $unix_time, 0 ) == 0
            and $retries_left-- ) {

            ++$data{'base'}{'retry-count'}{'ntime'}
                and goto RETRY_BASE_NTIME;
        }

        say '< exceeded >' if !$retries_left;

        return $ntime;
    };

################################################################################

    $code{'base.ntime.b32'} = sub {
        my $param        = shift // 4;    # <-- precision or utime
        my $want_harmony = shift // $data{'base'}{'ntime-harmony'} // 1;
        my $retries_left = 5;             ## <-- configure [ retries-max ]
        my $last_ntime   = 0;
        my $ntime_precision;
        my $ntime_value;

        $data{'base'}{'retry-count'}{'ntime-B32'} //= 0;

    RETRY_BASE_NTIME_B32:                 ## only choose harmonic values ##

        $last_ntime = $ntime_value
            if $want_harmony
            and defined $ntime_value
            and $ntime_value != $last_ntime;

        ####
        $ntime_value = $code{'base.ntime'}->( $param, $want_harmony );
        ####

        if ($want_harmony) {
            $ntime_precision = 0;
            $ntime_precision = length( ${^CAPTURE}[0] )
                if $ntime_value =~ m|\.(\d+)$|;
            my $zulum_len       = $ntime_precision + 1;
            my $collision_delay = join( '', '0.', '0' x $zulum_len, '113' );
            if ( $last_ntime == $ntime_value ) {  ## same input \ collision ##
                Time::HiRes::sleep($collision_delay);
                goto RETRY_BASE_NTIME_B32;
            }
        }

        my @nt = split( m|\.|, $ntime_value );
        $nt[1] = '7' . $nt[1] if scalar @nt == 2;   # <-- 7 catches prefixed 0

        my $encoded_ntime = Crypt::Misc::encode_b32r( pack( 'w*', @nt ) );

        ++$data{'base'}{'retry-count'}{'ntime-B32'}
            and goto RETRY_BASE_NTIME_B32
            if $want_harmony == 1
            and length($param) < 9                  # <-- precision
            and $code{'base.assert.harmony'}->($encoded_ntime) == 0
            and $retries_left--;

        return $encoded_ntime;
    };

################################################################################

    $code{'base.b32.ntime'} = sub {
        my $network_time = shift;
        my $ntime_dec;
        warn 'invalid network time format <{C1}>' and return undef
            if $network_time !~ m|^[A-Z2-7]{1,22}$|;    ## <-- inc. len. [LLL]
        eval {
            no warnings;
            $ntime_dec
                = unpack( 'w', Crypt::Misc::decode_b32r($network_time) );
        };
        if ( $EVAL_ERROR or !length( $ntime_dec // '' ) ) {
            my $caller_str = [caller]->[1] . ':' . [caller]->[2];
            $code{'log.debug'}->( "network time decoding error"
                    . " [\"$network_time\"] \\ $caller_str" );
            return undef;
        }
        return $ntime_dec;
    };

################################################################################

    $code{'base.assert.harmony'} = sub {   ## overloaded by 'base' module., ##
        my $input_string = shift // '';
        my $check_elf    = shift // 1;
        return 1 if !length($input_string);    ## is harmonic ##

        my $visualize
            = defined $data{'base'}{'harmony'}{'visualize'}
            ? $data{'base'}{'harmony'}{'visualize'}
            : {};

        my $visualize_zulum      = $visualize->{'zulum'}      // 0;
        my $visualize_harmony    = $visualize->{'harmony'}    // 0;
        my $visualize_disharmony = $visualize->{'disharmony'} // 0;

        my %a;
        if (   $visualize_zulum
            or $visualize_harmony
            or $visualize_disharmony ) {
            if ( not keys %a ) {

                #  reset          "\c[[m"
                my $reset       = "\e[0m";
                my $nailara_bg  = "\e[48;2;9;5;42m";
                my $blacklight  = "\e[38;2;68;39;172m";
                my $nailara_fg  = "\e[38;2;38;46;153m";
                my $error_color = "\e[38;2;197;141;7m";
                my $neon_green  = "\e[38;2;71;195;6m";
                %a = (
                    'str'    => "\c[[1m",
                    'bg'     => $nailara_bg,
                    'bl'     => $blacklight,
                    'reset'  => $reset,
                    'ZL-B'   => $nailara_fg,
                    'ZULUM'  => $blacklight,
                    'Z-REST' => "\c[[2m" . $reset . $nailara_bg . $nailara_fg,
                    'D-REST' => $reset . $nailara_bg . $neon_green,
                    'NG'     => $neon_green . "\c[[1m",
                    'UNKNOWN' => $neon_green . "\c[[5m",
                    'color_y' => "\c[[6m" . $blacklight,
                    'color_n' => $error_color . "\c[[1m",
                    'clear'   => "\c[[H\c[[2J"
                );
            }
        }

        ## [ load modules first, if not present ] ##
        map {
            if ( not defined $data{'base'}{'perlmod'}{'loaded'}->{$ARG}
                or $data{'base'}{'perlmod'}{'loaded'}->{$ARG} == 0 ) {

                return 1
                    if defined $data{'base'}{'perlmod'}{'loading-failed'}
                    and
                    exists $data{'base'}{'perlmod'}{'loading-failed'}->{$ARG};

                ( my $pm_name = "$ARG.pm" ) =~ s|::|/|g;

                eval { require $pm_name };    ## load _before_ logging ., ##

                if ($EVAL_ERROR) {
                    $code{'log.error'}->(": loading not successful [ $ARG ]");
                    ## give up assertions to not cause infinite loops ##
                    $data{'base'}{'perlmod'}{'loading-failed'}->{$ARG} = 1;
                    return 1;
                } else {
                    $data{'base'}{'perlmod'}{'loaded'}->{$ARG} = 1;
                    $code{'log.debug'}->(": loaded perl module '$ARG'.,");
                }
            }
        } (qw| Digest::Elf Math::BigFloat |);
        ##

        Math::BigFloat->round_mode('trunc');

        my $calc_str;
        ## check as mumber ##
        if ( $input_string =~ m|^\d+(\.\d+)?$| ) {
            ( my $input_num = $input_string ) =~ s|\.||;

            my $accuracy = 13;

            ( $calc_str
                    = Math::BigFloat->new($input_num)
                    ->bdiv( 13, $accuracy + length($input_num) ) ) =~ s|\.||;

            my $seperator_str = ' : ';

            if ( index( $calc_str, '230769' ) >= 0 ) {   ## not harmonic.., ##

                my $min_len = $accuracy + 5;
                my $num_len = length($input_num);
                my $z_len   = abs( $min_len - $num_len );

                if (    $visualize_harmony
                    and $visualize_disharmony
                    and $num_len < $min_len ) {

                    $input_num .= '0' x $z_len;
                }
                ### ..340769.., [E] ##
                $calc_str
                    =~ s{(\d+?)((((((3)?0)?7)?6)?9)?230769([230769]+)*)(\d*)$}
                {$a{'D-REST'}${1}$a{'NG'}${2}$a{'D-REST'}${9}  $a{'reset'}}
                    and say "$a{bg}$a{bl}: $input_num$seperator_str$calc_str "
                    if $visualize_disharmony;

                return 0;
            } elsif ( $visualize_harmony
                and index( $calc_str, '846153' ) >= 0 ) {
                ### ..846153.., [T=5] ##
                $calc_str
                    =~ s{(\d+?)((((((4)?6)?1)?5)?3)?846153([846153]+)*)(\d*)$}
                {$a{'ZULUM'}${1}$a{'ZL-B'}${2}$a{'Z-REST'}${9} $a{'reset'}};
                say "$a{bg}$a{bl}: $input_num$seperator_str$calc_str";

            } elsif ( $visualize_zulum
                and index( $calc_str, '0000000' ) >= 0 ) {
                $calc_str =~ s{(\d+?)?(0000000*)$}
                {$a{'ZULUM'}${1}$a{'ZL-B'}${2} $a{'reset'}};
                say "$a{bg}$a{bl}: $input_num$seperator_str$calc_str";

            } elsif ( $visualize_harmony and $visualize_disharmony ) {
                say "$a{bg}$a{bl}: $input_num$seperator_str$a{'UNKNOWN'}"
                    . "$calc_str $a{'reset'}";
            }
        }

        return 1 if $check_elf == 0;

        ## check as string ##
        my $elf_checksum = Digest::Elf::elf($input_string);
        $calc_str = Math::BigFloat->new($elf_checksum)
            ->bdiv( 13, 13 + length($elf_checksum) );
        return 0 if index( $calc_str, '230769' ) >= 0;
        ##
        return 1; ## assertion complete : harmony detected ## [ no 230769.., ]
    };

################################################################################

    $code{'base.term.size'} = sub {

        my $handle = shift // *STDIN;    ## use *STDOUT for pipe detection ##

        return undef if not -t $handle;
        state $size       = "\0" x 8;
        state $TIOCGWINSZ = 21523;

        ioctl( $handle, $TIOCGWINSZ, $size ) or return undef;

        return [ unpack 'S!S!S!S!', $size ] ## <-- [ <x>, <y>, <x-px> <y-px> ]
    };

################################################################################

    $code{'base.load_b32_encoder'} = sub {
        if (    not defined &encode_b32r
            and not defined $data{'modules'}{'startup_error'}{'base32'} ) {
            eval { use Crypt::Misc qw| encode_b32r | };
            if ( $EVAL_ERROR or not defined &encode_b32r ) {
                $data{'modules'}{'startup_error'}{'base32'} = 1;
                return 0;    # module not found ##
            } else {
                return 1;    ## loading successful ##
            }
        } else {
            return 1;        ## function already present ##
        }
    };

    $code{'base.anum_log_time'} = sub {
        my $pt_param     = shift // 5;   # <-- LLL: configure, precision\utime
        my $want_harmony = shift;        # <-- skip not harmonic time stamps ?

        if ( &{ $code{'base.load_b32_encoder'} } ) {
            return $code{'base.ntime.b32'}->( $pt_param, $want_harmony );
        } else {
            return $code{'base.ntime'}->( $pt_param, $want_harmony );
        }
    };

    $code{'base.get_start_lpw'} = sub {
        my $zenka_name = shift // $data{'system'}{'zenka'}{'name'};
        my $node_name  = $data{'system'}{'node'}{'name'};
        return length("$node_name.$zenka_name");
    };

    ### basic subroutine definitions ###

    $code{'base.init_exec'} = sub {

        $SIG{'INT'} = sub { print "\b\b" if fileno(STDOUT); exit };   ## ^C ##

        ## choose harmonic PID on -NP switch ##
        #
        # ISSUES : returns to shell, not working with child zenki yet ##
        #
        my $change_pid = 0;
        map { $change_pid = 1 if $ARG eq '-NP' } @ARGV;
        &{ $code{'base.choose_true_pid'} } if $change_pid;
        #
        ##

        ## load first perl modules ##
        use utf8;
        use File::Spec::Functions;
        use FindBin qw| $RealBin $RealScript |;
        use Cwd 'abs_path';
        use Sys::Hostname;
        use File::stat;

        use constant 'τ'   => 6.28318530717958647692;
        use constant 'tau' => 'τ';

        $SIG{'PIPE'} = 'IGNORE';
        ## overriding warn subroutine ###
        $SIG{'__WARN__'} = $code{'base.sig_warn'};

        ## early variable initialization ##
        my $actual_exec = abs_path( catfile( $RealBin, $RealScript ) );
        my $bin_path    = [ File::Spec->splitpath($actual_exec) ]->[1];
        $data{'system'}{'start'}{'true_exec'} = $actual_exec;
        $data{'system'}{'start'}{'exec_name'}
            = File::Spec->rel2abs( canonpath($PROGRAM_NAME) )
            ;    # apparent exec [symlink]
        $data{'system'}{'root_path'}
            = abs_path( catdir( $bin_path, updir() ) );
        $data{'system'}{'perl_execname'} = $EXECUTABLE_NAME;
        $data{'system'}{'perl_version'}  = $PERL_VERSION;
        $data{'system'}{'perl_unicode'}  = ${^UNICODE};
        my $root_path = $data{'system'}{'root_path'};
        $data{'system'}{'code_path'} = catdir( $root_path, qw| base-code | );
        $data{'system'}{'conf_path'}
            = catdir( $root_path, qw| configuration | );
        $data{'system'}{'lmod_path'}
            = catdir( $root_path, qw| data lib-path pm | );
        delete $data{'system'}{'lmod_path'}
            if !-d $data{'system'}{'lmod_path'};
        $data{'base'}{'httpc'}{'last_mlen'}  //= 80;
        $data{'buffer'}{'zenka'}{'max_size'} //= 64 * 1024;   # 64K log-buffer

        ## source code version ##
        my $ver_str = $data{'protocol-7'}{'src-ver'} = 'unknown';
        my $version_file
            = catfile( $data{'system'}{'conf_path'}, 'protocol-7.src-ver' );
        if ( -e $version_file and open( my $ver_fh, '<' . $version_file ) ) {
            ( $data{'protocol-7'}{'src-ver'} = $ver_str = <$ver_fh> )
                =~ s|\s||g;
            close($ver_fh);
        }
        ## source code release version ##
        my $release_file
            = catfile( $data{'system'}{'conf_path'}, 'protocol-7.rel-ver' );
        if ( -e $release_file and open( my $ver_fh, '<' . $release_file ) ) {
            ( $data{'protocol-7'}{'rel-ver'} = $ver_str = <$ver_fh> )
                =~ s|\s||g;
            close($ver_fh);
        }
        ## determine zenka name and subname ###
        if ( $PROGRAM_NAME =~ m|^.*protocol-7\.| ) {
            $data{'system'}{'zenka'}{'initialized'} = 0;
            $data{'system'}{'zenka'}{'name'}        = lc($PROGRAM_NAME);
            $data{'system'}{'zenka'}{'name'} =~ s,^.*protocol-7\.|[\. ]$,,g;
        } elsif ( defined $ARGV[0] and $ARGV[0] =~ m|^([^\-].*)| ) {
            my $zenka_name = $LAST_PAREN_MATCH;
            $data{'system'}{'zenka'}{'subname'} = ${^CAPTURE}[0]
                if $zenka_name =~ s|\[([^\]]+)\]$||;
            $data{'system'}{'zenka'}{'name'} = $zenka_name;
        }
        if ( not defined $data{'system'}{'zenka'}{'name'}
            or $data{'system'}{'zenka'}{'name'} eq '' ) {
            $data{'system'}{'zenka'}{'name'} = '<init>';
        }

        $data{'system'}{'node'}{'name'} = hostname() // 'protocol-7';
        $data{'system'}{'node'}{'name'} =~ s|\..+$||;

      #   ( $data{'system'}{'node'}{'name'},
      #    $data{'system'}{'zenka'}{'name'} ) = split ( m|\.|, $_[0] ); #[LLL]

        ## early verbosity settings ###
        $data{'system'}{'verbosity'}{'console'}       = 0;
        $data{'system'}{'verbosity'}{'zenka_buffer'}  = 1;
        $data{'system'}{'verbosity'}{'zenka_logfile'} = 0;

        $data{'system'}{'ansi_color'} = 1;
        $data{'system'}{'start'}{'showbanner'} = 1;

        my $stdin_mode = 1;
        ## process command line arguments ###
        $data{'system'}{'console-mode'} //= 0;
        foreach my $arg (@ARGV) {
            $stdin_mode = 0 if $arg =~ m|^[^\-]|;
            if ( $arg =~ m|^-(v+)(h?z?d?)?$| ) {
                $data{'system'}{'verbosity'}{'console'}
                    = length( ${^CAPTURE}[0] );
                my $vis       = ${^CAPTURE}[1] // '';
                my $visualize = $data{'base'}{'harmony'}{'visualize'}
                    //= { 'zulum' => 0, 'harmony' => 0, 'disharmony' => 0 };
                $visualize->{'harmony'}    = 1 if $vis =~ m|h|;
                $visualize->{'zulum'}      = 1 if $vis =~ m|z|;
                $visualize->{'disharmony'} = 1 if $vis =~ m|d|;
            }
            if ( $arg eq '-B' ) { $data{'system'}{'background_mode'} = 1 }
            if ( $arg eq '-stdin' ) {
                $data{'system'}{'startup_initcode'} = 1;
                $data{'system'}{'console-mode'} = 0;   ## LLL: more conditions
            }
            if ( $arg eq '-console' ) {
                $data{'system'}{'console-mode'} = 1;
                $code{'log.error'}->('<< in console mode >>');
            }
            if ( $arg eq '-c' ) {
                $data{'system'}{'ansi_color'}   = 1;
                $data{'system'}{'force-colors'} = 1;
            }
            if ( $arg eq '-nc' ) {
                $data{'system'}{'ansi_color'}   = 0;
                $data{'system'}{'force-colors'} = 0;
            }
            if ( $arg eq '-nb' ) {
                $data{'system'}{'start'}{'showbanner'} = 0;
            }
            if ( $arg =~ m|^-N(.+)$| ) {
                $data{'system'}{'zenka'}{'name'} = $LAST_PAREN_MATCH;
            } elsif ($stdin_mode) {
                $data{'system'}{'zenka'}{'name'} = '<stdin>';
            }
            if ( $arg =~ m|^-lpw=(\d{1,2})$| ) {   # <-- used by 'nroot' zenka
                $data{'system'}{'zenka'}{'log_prefix_width'} = ${^CAPTURE}[0];
            }
            if ( $arg eq '-use-http-src' ) {
                $data{'system'}{'use_http_source'} = 1;
            }
            if ( $arg eq '-export-core-subs' ) {
                $code{'dump_core_subs'}->();
                exit(0);
            }
        }

        ## setting log prefix width values \ defaults ##
        $data{'system'}{'start'}{'log_prefix_width'}
            = &{ $code{'base.get_start_lpw'} };
        $data{'system'}{'zenka'}{'log_prefix_width'}
            //= $data{'system'}{'start'}{'log_prefix_width'};

        ### load zenka code from stdin ###
        $data{'system'}{'path'}{'rel'}{'cur_zenka_cfg'} = '<STDIN>'
            if $stdin_mode;

        ## prepare zenka name column width and color mode pipe override ###
        if ( not defined $code{'base.term.size'}->(*STDIN) ) {
            $data{'system'}{'term'}{'piped'}{'stdin'} = 1;
        } else {
            $data{'system'}{'term'}{'piped'}{'stdin'} = 0;
        }
        if ( not defined $code{'base.term.size'}->(*STDOUT) ) {
            $data{'system'}{'term'}{'piped'}{'stdout'} = 1;
        } else {
            $data{'system'}{'term'}{'piped'}{'stdout'} = 0;
        }
        if ( not defined $code{'base.term.size'}->(*STDERR) ) {
            $data{'system'}{'term'}{'piped'}{'stderr'} = 1;
        } else {
            $data{'system'}{'term'}{'piped'}{'stderr'} = 0;
        }
        ##
        map {
            if ( $data{'system'}{'term'}{'piped'}{$ARG} ) {
                $data{'system'}{'term'}{'colors'}{$ARG}
                    = $data{'system'}{'ansi_color'}
                    = $data{'system'}{'force-colors'} // 0;
            } else {
                $data{'system'}{'term'}{'colors'}{$ARG}
                    = $data{'system'}{'ansi_color'} // 1;
            }
        } qw| stdout stderr |;
        $data{'system'}{'ansi_color'} //= 1;
        ##

        ## defining console ansi colors ###
        if ( $data{'system'}{'ansi_color'} ) {
            %ANSI = (
                'p7_bg'        => "\e[48;2;9;5;42m",
                'p7_bg_0000'   => "\e[48;2;0;0;17m",
                'p7_fg_0000'   => "\e[38;2;68;39;172m",
                'p7_fg_0001'   => "\e[38;2;38;46;153m",
                'p7_fg_0002'   => "\e[38;2;197;141;7m",
                'p7_fg_0003'   => "\e[38;2;71;185;6m",
                'p7_fg_0004'   => "\e[38;2;6;71;195m",
                'bold'         => "\e[1m",
                'reset'        => "\e[0m",
                'clear_screen' => "\e[H\c[[2J"
            );
        } else {
            %ANSI = (
                'p7_bg'        => '',
                'p7_bg_0000'   => '',
                'p7_fg_0000'   => '',
                'p7_fg_0001'   => '',
                'p7_fg_0002'   => '',
                'p7_fg_0003'   => '',
                'p7_fg_0004'   => '',
                'bold'         => '',
                'reset'        => '',
                'clear_screen' => "\c[[H\c[[2J"
            );
        }
        ## prepare for stripping ansi from output ##
        $data{'base'}{'ansi_re'} = join(
            '|',
            map { ( my $A = $ANSI{$ARG} ) =~ s|^\e(.+)$|\\e\Q$1\E|; $A } # \1?
                keys %ANSI
        );

        print STDERR $ANSI{'p7_fg_0002'};
        my $start_string = '\\';
        ## nailara start-up banner ##
        if (   $data{'system'}{'verbosity'}{'console'}
            && $data{'system'}{'start'}{'showbanner'} ) {
            say $ANSI{'p7_bg'}, $ANSI{'p7_fg_0000'}, $start_string,
                , $ANSI{'p7_bg_0000'},
                ' ' x 77, $ANSI{'p7_bg'} . $ANSI{'p7_fg_0000'}, '/';
            &{ $code{'base.banner'} };
        }
        ## initializing early zenka buffer capture ###
        $data{'system'}{'start'}{'zenka-buffer'} = [];
        my $seperator_len = 18 + length( $data{'system'}{'zenka'}{'name'} );
        map { push( @{ $data{'system'}{'start'}{'zenka-buffer'} }, $ARG ) } (
            join( ' ',
                $code{'base.anum_log_time'}->(),
                1, '_' x $seperator_len ),
            $code{'base.anum_log_time'}->()
                . " 1 STARTUP 'zenki/$data{system}{zenka}{name}'/",
            $code{'base.anum_log_time'}->()
                . " 1 VERSION '$data{'protocol-7'}{'src-ver'}'"
        );
    };

    $code{'base.strip_ansi'} = sub {
        my $scalar_ref = shift;
        return if !$data{'system'}{'ansi_color'};
        $$scalar_ref =~ s,$data{base}{ansi_re},,g;
    };

    $code{'base.banner'} = sub {
        my $version_str = sprintf( "protocol-seven.src-ver :. %s",
            $data{'protocol-7'}{'src-ver'} );
        my $release_str = sprintf( "AMOS-release versn.: %s",
            $data{'protocol-7'}{'rel-ver'} );
        local $RS = undef;
        open( my $banner_fh,
            catfile( $data{'system'}{'conf_path'}, '.banner' ) )
            or return;
        my $nailara_header = <$banner_fh>;
        close($banner_fh);
        map {
            say "$ANSI{p7_bg}$ANSI{p7_fg_0000} $ANSI{'p7_bg_0000'} "
                . "$ANSI{p7_bg}$ANSI{p7_fg_0000}$ARG$ANSI{'p7_bg_0000'} ",
                $ANSI{'p7_bg'} . $ANSI{'p7_fg_0000'}, " \r"
            }
            split( m|\n|, $nailara_header );
        say $ANSI{'p7_bg'} . $ANSI{'p7_fg_0000'}, ' ', $ANSI{'p7_bg_0000'},
            ' ' x 77, $ANSI{'p7_bg'} . $ANSI{'p7_fg_0000'}, " \n",
            ' ', $ANSI{'p7_bg_0000'}, ' ', $ANSI{'p7_bg'},
            $ANSI{'p7_fg_0000'},
            $version_str, $ANSI{'p7_bg_0000'}, '    ', $ANSI{'p7_bg'},
            $ANSI{'p7_fg_0000'}, $release_str, $ANSI{'p7_bg_0000'}, ' ',
            $ANSI{'p7_bg'} . $ANSI{'p7_fg_0000'}, " \r\n",
            $ANSI{'p7_fg_0000'}, $ANSI{'p7_bg'}, '/', $ANSI{'p7_bg_0000'},
            ' ' x 77,
            $ANSI{'p7_bg'} . $ANSI{'p7_fg_0000'}, '\\',
            $ANSI{'reset'},
            , "\r";
    };

    $code{'dump_core_subs'} = sub {
        my %core_subs;
        my $bin_path = $data{'system'}{'start'}{'exec_name'};
        open( my $p7_fh, $bin_path ) or die "$bin_path : \l$OS_ERROR\n";
        my %sub_src;
        my $sub_name;
        foreach my $src_line (<$p7_fh>) {
            $sub_name = undef
                if defined $sub_name and $src_line =~ m|^\s*};\s*(#.*)?\n$|;
            if ( defined $sub_name ) {
                $sub_src{$sub_name} //= [];
                push( @{ $sub_src{$sub_name} }, $src_line );
            }
            $sub_name = ${^CAPTURE}[0]
                if $src_line
                =~ m|^\s*\$code\{\'([^\']+)\'\}\s*=\s*sub\s*\{\s*(#[^\n]*)?\n$|;
        }
        print "\n";
        close($p7_fh);
        foreach my $sub_name (
            sort { length $a <=> length $b }
            sort keys %sub_src
        ) {
            print "\n#  .::[ $sub_name ]:.\n#  ::\n";
            foreach my $sub_line ( @{ $sub_src{$sub_name} } ) {
                print $sub_line;
            }
            print "\n#  .\n#  ::.\n";

        }
        exit;
    };

    # [LLL] callback registry [ for skipping purging ]
    $code{'base.purge_code'} = sub {
        my $code_name   = shift;
        my $purge_count = 0;
        my @zenka_commands;
        map {
            if (    $ARG !~ m{\.(callback|handler)\.}
                and not exists $data{'base'}{'core_subs'}{$ARG}
                and $ARG ne 'base.log'
                and $ARG ne 'base.caller'
                and $ARG ne 'base.s_read'
                and $ARG ne 'base.gen_id'
                and $ARG ne 'base.sig_int'
                and $ARG ne 'base.s_write'
                and $ARG ne 'base.sig_warn'
                and $ARG ne 'base.route.add'
                and $ARG ne 'base.clean_unicode'
                and $ARG ne 'base.buffer.add_line'
                and $ARG ne 'base.list.element.add'
                and $ARG ne 'base.utf8.decode_clean'
                and $ARG ne 'base.log.send_buffer_line'
                and $ARG ne 'base.log.handler.log_reply'
                and $ARG ne 'nroot.handler.zenka_output'
                and $ARG ne 'base.protocol-7.command.send.local' ) {
                ++$purge_count
                    and $data{'code'}{$ARG}{'status'} = 'purged'
                    and
                    eval { undef &{ delete $code{$ARG} } }; # <--improve [LLL]

                #           #[ debug ]
                #           and $code{$ARG} = eval "sub { print STDERR \"\n"
                #                                 ." MISSING '$ARG'\n\n\" }";

                push( @zenka_commands, ${^CAPTURE}[0] )
                    if $ARG =~ m|\.cmd\.(.+)$|;
                --$purge_count if $EVAL_ERROR;
            } elsif ( not exists $data{'base'}{'core_subs'}{$ARG} ) {
                $data{'code'}{$ARG}{'status'}
                    = 'leftover';    ## kept \ essential ##
            }
            }
            grep {m|^$code_name(\..+)?$|} keys %code;
        map {
            delete $data{'base'}{'cmd'}{$ARG};
            delete $data{'base'}{'commands'}{'cmd'}{$ARG};
        } @zenka_commands;
        return $purge_count;
    };

    $code{'base.parser.ellipse_center'} = sub {
        my $str_param = shift;
        my $len_param = shift;
        die "expected string and maximum length [>=5] parameters"
            if not defined $str_param
            or not defined $len_param
            or $len_param =~ m|^\d+$| and $len_param < 5;

        my $by_reference = ref($str_param) eq 'SCALAR' ? 1 : 0;
        my $str_ref      = $by_reference ? $str_param      : \$str_param;
        my $str_len      = length($$str_ref);
        my $start_pos    = int( $len_param / 2 ) - 1;
        my $chars_cut    = $str_len - $len_param + 3;

        return 0          if $by_reference and $str_len <= $len_param;
        return $str_param if $str_len <= $len_param;
        return $str_len - $len_param if $by_reference;

        substr( $$str_ref, $start_pos, $chars_cut, '.,.' );
        return $$str_ref;
    };
    $code{'base.code.file_list'} = sub {
        my $codedir_fh;
        $data{'base'}{'modules'}{'load_errors'} //= 0;
        if ( !opendir( $codedir_fh, $data{'system'}{'code_path'} ) ) {
            $data{'base'}{'modules'}{'load_errors'}++;
            $code{'log.error'}->( ": cannot open source code directory"
                    . " '$data{'system'}{'code_path'}' [ \l$OS_ERROR ]" );
            return undef;
        }
        my @subroutine_names = sort { length $a <=> length $b }
            sort grep { !m|^\.| } readdir($codedir_fh);
        closedir($codedir_fh);
        return @subroutine_names;
    };

    $code{'base.code.sort_filter'} = sub {
        my @filtered_subroutines;
        my @subroutine_names = @_;
        my %subroutines      = map { $ARG => 0 } @subroutine_names;
        my $occurrence       = 0;

        ## unique filter ##
        my $subs_skipped = 0;
        my %sub_is_present;
        map {
            if ( not exists $sub_is_present{$ARG} ) {
                push( @filtered_subroutines, $ARG )
                    and ++$sub_is_present{$ARG};
            } else {
                $subs_skipped++;
            }
        } @subroutine_names;

        $code{'log.error'}->(": :. skipped identical .: $subs_skipped ::")
            if $subs_skipped;

        ## .., ## [LLL] implement code dependency tree ..,

        return @filtered_subroutines;
    };

    $code{'base.httpc.remote_file'} = sub {

        $data{'base'}{'warned'}{'http_src_deactivated'} //= 0;
        warn 'source loading over http has been temporarely deactivated'
            if !$data{'base'}{'warned'}{'http_src_deactivated'}++;

        return undef;    ## feature temporarely deactivated ##

        return undef if !( $data{'system'}{'use_http_source'} // 1 );
        my $http_retries = $data{'system'}{'http_src_retries'} // 4;
        eval { use HTTP::Tiny } if !$data{'system'}{'http_reqs'};
        $EVAL_ERROR =~ s| ?\(\@INC contains:.+\n?$|| if $EVAL_ERROR;
        warn "<< 'HTTP::Tiny' pmod. not found"
            . " [ yet in cubelist ] [ $EVAL_ERROR ] >>"
            and return undef
            if $EVAL_ERROR;
        $data{'system'}{'http_reqs'}++;
        my $file_name = shift // '';
        my $base_urls = shift // ['https://nailara.network/sourcecode/'];
        warn 'expected http file name' and return undef
            if !length($file_name);
        warn 'expected array ref to base urls' and return undef
            if ref($base_urls) ne 'ARRAY' or !@{$base_urls};
        ####
        # $code{'log.debug'}->(": $file_name .,");
        $OUTPUT_AUTOFLUSH = 1;
        foreach my $http_base_url ( @{$base_urls} ) {
            my $abs_url = join( '/', $http_base_url, $file_name );
            $abs_url =~ s|//$file_name$|/$file_name|;
            my $h_res;
            my $retries      = $data{'system'}{'http_retries_total'} //= 0;
            my $retries_left = $http_retries;
            while ( $retries_left-- ) {
                my $r = $retries ? "[$retries\\$http_retries]" : '';
                ( my $msg_url = $abs_url )
                    =~ s|^(\w+)://|<$LAST_PAREN_MATCH> |;
                my $len
                    = length( $data{'system'}{'zenka'}{'name'} )
                    + length( $data{'system'}{'host'}{'hostname'} // '' );
                $len = 26 if $len < 27;

                my $w_len
                    = 95 - $len
                    - (
                          length( $data{'system'}{'node'}{'name'} )
                        + length( $data{'system'}{'zenka'}{'name'} ) );

                $code{'base.parser.ellipse_center'}->( \$msg_url, $w_len )
                    if defined $msg_url;

                $msg_url =~ s| | : |;
                my $m_len    = length($msg_url);
                my $last_len = $data{'base'}{'httpc'}{'last_mlen'};
                $data{'base'}{'httpc'}{'last_mlen'} = length($msg_url) + 13;
                my $s     = ' ' x $last_len;
                my $m_str = "\r$s\r: $msg_url.,";
                print "\r$m_str\r"
                    if $data{'system'}{'verbosity'}{'console'} == 1;
                $code{'log.debug'}->(":$r: $msg_url")
                    if $retries_left != $retries;
                my $h_obj = $data{'base'}{'httpc'}{'obj'}
                    //= HTTP::Tiny->new( 'timeout' => 7 );
                $h_res = $h_obj->get($abs_url);
                my $h_code = $h_res->{'status'};

                if ( not $h_res->{'success'} ) {
                    my $r_str = $EVAL_ERROR ? " < $EVAL_ERROR >" : '';
                    goto skiplog_httpmsg;
                    $code{'log.debug'}->(
                        sprintf(
                            ":[ %d ] %s : [ %s ]%s",
                            $h_code, $abs_url, $h_res->{'reason'}, $r_str
                        )
                    );
                skiplog_httpmsg:
                    if ( $h_code == 404 or $h_code eq 599 ) {
                        $retries_left = 0;
                        $code{'log.noerr'}->( ":: aborting retries ["
                                . " after first $h_code code ] ::" );
                        return undef;
                    } else {    ## client side rate limiting ## [???]
                        my $randomized_delay = 0.13 + rand(
                            0.777 * ++$data{'system'}{'http_retries_total'} );
                        $code{'base.sleep'}->($randomized_delay);
                    }
                    next;
                }
                if ( $h_code == 200 and length $h_res->{'content'} ) {
                    return $h_res->{'content'};
                } else {
                    warn "<< failed to acquire http file '$file_name' >>";
                    return undef;
                }
            }
        }
        $OUTPUT_AUTOFLUSH = 0;
    };

    $code{'base.chk_nlr_path'} = sub {    ## LLL: reduce calls \ exposure .,
        my $chk_path = shift // '';
        my $d_aref   = shift // [qw| ext/ / |];
        my $base_dir = shift // $data{'system'}{'root_path'} // '';
        die "no base_dir defined"        if !length($base_dir);
        die "chk_path argument expected" if !length($chk_path);
        die "expected array ref as second argument"
            if ref($d_aref) ne 'ARRAY';

        if ( $data{'system'}{'use_http_source'} ) {
            return $chk_path
                if
                exists $data{'base'}{'httpc'}{'remote_source'}->{$chk_path};
            ## else | not exists ###
            warn "<< remote source file not found : $chk_path >> <{C1}>";
            return undef;
        }
        my $f_path;
        foreach my $chk_parent ( @{$d_aref} ) {
            $f_path
                = canonpath(
                catfile( catfile( $base_dir, $chk_parent ), $chk_path ) );
            ( my $path_str = catfile( $chk_parent, $chk_path ) ) =~ s|^/+||;
            return $path_str if defined $f_path and -r $f_path;
        }
        $data{'modules'}{'warned'}{$f_path}
            //= {};    # <-- LLL: clean up later..,
        my $reason
            = ( -l $f_path and !-r readlink($f_path) ) ? 'readable' : 'found';
        warn "<< source not $reason : '$chk_path' >> <{C1}>"
            if !$data{'modules'}{'warned'}{$f_path}++;
        return undef;
    };

    $code{'base.source_path_valid'} = sub {
        my $src_file_rel = shift // '';
        warn 'no file name supplied' if !length($src_file_rel);
        my $src_remote = $data{'base'}{'httpc'}{'remote_source'} // {};
        ## ignored ##
        return 0
            if !length($src_file_rel)
            or $src_file_rel =~ m,~$|\.orig$|\.LOG$,;
        ## remote ##
        return 1
            if $data{'system'}{'use_http_source'}
            and exists $src_remote->{$src_file_rel};
        ## local ##
        my $src_abs_path = abs_path(
            catfile( $data{'system'}{'root_path'}, $src_file_rel ) );
        return 1
            if defined $src_abs_path
            and ( -f $src_abs_path
            or -l $src_abs_path and -f readlink($src_abs_path) );
        warn "<< no match : $src_abs_path >> <{C1}>";
        return 0;    # <-- no match.
    };

    $code{'base.load_code'} = sub {
        my ( $file, $code_name );

        my $base = 0;    ## loading 'base' first ##
        map { $base = 1 if $ARG eq 'base' } @_;
        my @module_names = sort { length $a <=> length $b } reverse sort
            grep { !m|^base$| } @_;
        unshift( @module_names, 'base' ) if $base;

        $data{'callbacks'}{'end_code'} //= [];

        map { $code{'plugins.status'}->{$ARG}->{'load_errors'} = 0 }
            grep {m|^plugin\.|} @module_names;

        ## http source ### ..,/.v7/file-list
        my $base_url_aref = $data{'system'}{'http_src_base_urls'};
        my @http_src_base_urls
            = ref($base_url_aref) eq 'ARRAY'
            ? @{$base_url_aref}
            : qw| http://nailara.network/sourcecode http://src.v7.ax/nailara/ |;

        my $src_from_http = (
            ( $data{'system'}{'use_http_source'} // 0 )
                or !-r $data{'system'}{'code_path'}
                and not( $data{'system'}{'no_http_source'} // 0 )
        ) ? 1 : 0;

        $code{'log.error'}
            ->( '< not readable > ' . $data{'system'}{'code_path'} )
            if $src_from_http
            and !-r $data{'system'}{'code_path'}
            and not( $data{'system'}{'use_http_source'} // 0 );

        $data{'system'}{'use_http_source'} = $src_from_http;

        my $c_ref            = $data{'base'}{'source'}{'code_files'} // [];
        my @subroutine_names = @{$c_ref};

        if ($src_from_http) {
            $code{'log.error'}->("<<< network source loading enabled >>>")
                if !@subroutine_names;
            ##### remote source code access ###
            my $method = ${^CAPTURE}[0]
                if $http_src_base_urls[0] =~ m|^(\w+):|;
            $code{'log.debug'}
                ->(": reading source file list over $method ..,");
            my $remote_data_str
                = $code{'base.httpc.remote_file'}
                ->( '.v7/file-list/base', \@http_src_base_urls );
            if ( defined $remote_data_str ) {
                my $read_len = length($remote_data_str);
                @subroutine_names = split( m|\n|, $remote_data_str );
                $data{'base'}{'httpc'}{'remote_source'} = {};
                map {
                    $data{'base'}{'httpc'}{'remote_source'}
                        ->{"base-code/$ARG"}
                        = 1
                } @subroutine_names;
                $data{'base'}{'source'}{'code_files'} = \@subroutine_names;
            } else {
                $code{'log.error'}
                    ->(": no success reading remote source file list .,");
                $code{'log.noerr'}->(": :");
                $code{'log.error'}->(": :. terminating startup sequence..,");
                $code{'log.noerr'}->(':....,');
                if ( defined $code{'base.exit'} ) {
                    $code{'base.exit'}->(1);
                } else {
                    exit(1);
                }
            }
            ####
        } else {
            $code{'log.debug'}->(": reading source list from disk.,");
            @subroutine_names = $code{'base.code.file_list'}->();
            my $file_cnt = scalar @subroutine_names;
            $code{'log.debug'}->(": :. $file_cnt files. [base-code]");
        }
        $OUTPUT_AUTOFLUSH = 1;

        my %module_code_map;
        my @compile_order = ();

        while ( $code_name = shift @module_names ) {

            my $src_str = $code_name =~ m|^(.+/)?plugin.| ? '' : ' source';
            $code{'log.noerr'}->(". loading$src_str '$code_name'");

            $data{'base'}{'p7_mod'}{'errors'}->{$code_name} = 0;
            $data{'base'}{'p7_mod'}{'loaded'}->{$code_name} = 0;

            if ( my $purge_count = $code{'base.purge_code'}->($code_name) ) {
                my $s = $purge_count == 1 ? '' : 's';
                $code{'log.debug'}->(": $purge_count sub$s undefined");
            }

            my $code_count      = 0;
            my $last_code_count = 0;
            if ( exists $data{'base'}{'modules'}{'internal_name'} ) {
                my $internal_name
                    = delete $data{'base'}{'modules'}{'internal_name'};
                delete $data{'base'}{'modules'}{'moved_to'}{$internal_name}
                    if exists $data{'base'}{'modules'}{'moved_to'};
            }

            foreach my $file_name (@subroutine_names) {
                next if not defined $file_name or !length($file_name);
                ## todo : reconcile with code_path ##
                my $src_abs_path;
                my $src_rel
                    = $code{'base.chk_nlr_path'}->("base-code/$file_name");

                $src_rel = "base-code/$file_name"
                    if not defined $src_rel;    # <-- warn.

                $src_abs_path
                    = abs_path(
                    catfile( $data{'system'}{'root_path'}, $src_rel ) )
                    if defined $src_rel;

                if (    $src_rel =~ m|^(.*/)?$code_name(\..+)?$|
                    and $code{'base.source_path_valid'}->($src_rel) ) {
                    $code_count++;
                    local $RS = undef;
                    if ( $src_from_http
                        or !-r $src_abs_path
                        and !( $data{'system'}{'no_http_source'} // 0 ) ) {
                        ### read base-code from network [ more methods coming ]

                        # $code{'log.debug'}->(":[http]: $src_rel .,");

                        $data{'code'}{$file_name}{'source'}
                            = $code{'base.httpc.remote_file'}
                            ->( $src_rel, \@http_src_base_urls );
                        ####
                    } else {
                        ## loading code from disk [ including ./ext directory ]
                        $code{'log.debug'}->(":[disk]: $src_rel .,");
                        open( my $src_fh, '<', $src_abs_path )
                            or die ":$src_abs_path : \l$OS_ERROR";
                        $data{'code'}{$file_name}{'source'} = <$src_fh>;
                        close($src_fh);
                    }

                    # <[sub_name]>->(  -->  $code{'sub_name'}->(
                    my $orig_len
                        = length( $data{'code'}{$file_name}{'source'} );

                    $data{'code'}{$file_name}{'source'}
                        =~ s|(?<!\\)<\[([\w\-]+\.[\w\-\.]+?)\]>\s*->\(
                            |\$code{'$LAST_PAREN_MATCH'}->(|sgxo;

                  # < ! > the parser currently does not respect quoted strings
                  #       escape like \<[sub.name]> <-- this to avoid a match.
                  #
                  # note: a generic quoted string match might be :  ##########
                  # ####  (["'])(?:\\?+.)*?\1 or "([ˆ"]<(?<=\\)")+" #[mre:212]

                    # <[sub_name]>  -->  $code{'sub_name'}->()
                    $data{'code'}{$file_name}{'source'}
                        =~ s|(?<!\\)<\[([\w\-]+\.[\w\-\.]+)\]>
                            |\$code{'$LAST_PAREN_MATCH'}->()|gxo;

                    # <foo.bar>  -->  $data{'foo'}{'bar'}
                    # (requires at least 1 . in the data key to match)
                    $data{'code'}{$file_name}{'source'}
                        =~ s|(?<!\\)<([\w\-:]+\.[\w\-\.:]+)(?<!\\)>
                            |my $k="\$data{'$LAST_PAREN_MATCH'}";
                                $k=~s/\./'}{'/g;$k|gexo;
                    $RS = "\n";
                    if (length( $data{'code'}{$file_name}{'source'} )
                        > $orig_len
                        and $data{'system'}{'verbosity'}{'console'} > 3 ) {
                        $code{'log.debug'}->( "\n\n .: $file_name :.\n\n"
                                . $data{'code'}{$file_name}{'source'} );
                        $data{'plugins'}{'status'}{$code_name}
                            {'load_errors'}++
                            if !length($src_str);    # <-- is plugin..
                    }

                    push( @compile_order, $file_name );

                    # register for error \ success tracking #
                    $module_code_map{$file_name} = $code_name;

                } elsif ( $file_name =~ m|\.orig$| ) {
                    $code{'log.error'}->("[invalid\\remove.,] $file_name");
                }
            }
            if (    $data{'system'}{'verbosity'}{'console'} == 1
                and $data{'system'}{'use_http_source'}
                and exists $data{'base'}{'httpc'}{'last_mlen'} ) {
                my $last_mlen = delete $data{'base'}{'httpc'}{'last_mlen'};
                $last_mlen += 92;
                $last_mlen = 79 if $last_mlen > 79;
                my $space_str = ' ' x $last_mlen;
                $OUTPUT_AUTOFLUSH = 1;
                print "\r$space_str\r";
                $OUTPUT_AUTOFLUSH = 0;
            }
            if ( !$code_count ) {
                $code{'log.error'}->(
                    ": no success loading base-code '$code_name' \t[ not found ]"
                );
                $data{'base'}{'modules'}{'load_errors'}++;
            } elsif ( $code_count > $last_code_count ) {
                $data{'system'}{'subs_loaded'}{$code_name}
                    = $code_count - $last_code_count;
            }
            $last_code_count = $code_count;
        }
        my $mod_count = scalar @compile_order;
        return if !$mod_count and !@module_names;
        next   if !$mod_count;
        my $src_bytes_total = 0;
        $code{'log.debug'}->(": compiling ..,");
        my ( $ok_count, $err_count, $warn_count, $warn_count_total )
            = ( 0, 0, 0, 0 );

        my %disabled_commands;
        map { $disabled_commands{$ARG} = 1 } @{ $data{'disabled_commands'} }
            if exists $data{'disabled_commands'}
            and ref( $data{'disabled_commands'} ) eq 'ARRAY';

        ## sort [ and filter ] in code occurence order ###
        @compile_order = $code{'base.code.sort_filter'}->(@compile_order);
        ##

        foreach my $sub_name (@compile_order) {
            my $loading_error = 0;
            my $module_name   = $module_code_map{$sub_name};
            my $source_len    = length( $data{'code'}{$sub_name}{'source'} );
            $source_len //= 0;

            ## recompile twice case, now filtered ##
            $code{'log.error'}->(":. << empty subroutine [ $sub_name ] >>")
                and $loading_error = 1
                if !$source_len;

            $data{'base'}{'p7_mod'}{'sbytes'}->{$module_name} = $source_len;

            local $SIG{'__WARN__'} = 'IGNORE';
            local $SIG{'__DIE__'}  = 'IGNORE';

            my $sub_code     = undef;
            my $code_header  = '';
            my $code_footer  = '';
            my $sub_conflict = 0;

            if ( $sub_name =~ m{\.(cmd|console)\.(.+)$} ) {
                my $cmd_type = ${^CAPTURE}[0];
                my $cmd_name = ${^CAPTURE}[1];
                next
                    if $cmd_type eq 'cmd'
                    and exists $disabled_commands{$cmd_name};
                if ( exists $data{'base'}{$cmd_type}{$cmd_name} ) {
                    my $old_sub = $data{'base'}{$cmd_type}{$cmd_name};
                    if (not exists $data{'base'}{'overwritten'}{$cmd_type}
                        {$cmd_name} ) {
                        if ( $sub_name ne $old_sub ) {
                            $code{'log.debug'}->("[!] $sub_name >> $old_sub");
                        } else {
                            $code{'log.debug'}
                                ->("[!] replacing sub $sub_name");
                        }
                        $data{'base'}{'overwritten'}{$cmd_type}{$cmd_name}
                            = {
                            'old' => $old_sub,
                            'new' => $sub_name
                            };
                    } else {
                        push(
                            @{  $data{'base'}{'overwritten'}
                                    {$cmd_type}{$cmd_name}{'conflicts'}
                            },
                            $sub_name
                        );
                        $data{'base'}{'modules'}{'load_errors'}++;
                        $code{'log.error'}->("[!] conflict: $sub_name");
                        $sub_conflict = 1;
                    }
                }

                $data{'base'}{$cmd_type}{$cmd_name} = $sub_name
                    if !$sub_conflict;
                my $stat_start_cref
                    = defined $code{'stats.sub_start'}
                    ? $code{'stats.sub_start'}->($sub_name)
                    : sub { };
                my $stat_end_cref
                    = defined $code{'stats.sub_end'}
                    ? $code{'stats.sub_end'}->($sub_name)
                    : sub { };
                $code_footer
                    .= "\$code{'stats.sub_end'}->(\$sub_name)"
                    . " if ref(\$code{'stats.sub_end'}) eq 'CODE';";
                $code_header
                    = 'my $call={}; my $reply={ \'mode\' => \'nak\', \'data\''
                    . " => \"error during invocation of '$cmd_name' command"
                    . " [ details logged ]\" }; "
                    . "\$code{'stats.sub_start'}->(\$sub_name) if defined "
                    . "ref(\$code{'stats.sub_start'}) eq 'CODE'; "
                    . 'if ( ref( $_[0] ) eq \'HASH\' ) { '
                    . ' $call=$_[0]; } else { $$call{\'args\'}=$_[0] } ';
                $code_footer = ' ; return $reply';

                $data{'code'}{$sub_name}{'source'}
                    = $code_header
                    . $data{'code'}{$sub_name}{'source'}
                    . $code_footer;
            }

            if ( $data{'system'}{'verbosity'}{'console'} > 2 ) {
                my $line_comment = "\n# line 1 \"" . $sub_name . "\"\n";
                $sub_code
                    = 'sub {'
                    . $line_comment
                    . "\&{\$code{'base.debug_sub'}}('$sub_name',\@_); "
                    . $data{'code'}{$sub_name}{'source'} . ' }';
            } else {
                my $line_comment = "\n# line 1 \"" . $sub_name . "\"\n";
                $sub_code = join ' ',
                    'sub {', $line_comment,
                    ( $data{'code'}{$sub_name}{'source'} ), '}';
            }

            ##                      ###
            ## compiling subroutine ###
            ##                      ###

            $src_bytes_total += $source_len;

            $code{'base.stderr_redir'}->( \my $s_comp_stderr );

            my $compilation_success
                = ( $code{$sub_name} = eval($sub_code)
                    and ref( $code{$sub_name} ) eq 'CODE' )
                ? 1
                : 0;

            my $err_str = $EVAL_ERROR;
            state $t_wrap //=
                ( defined &wrap )
                ? sub { return wrap( '', ': ..  ', $ARG ) }
                : sub { return $ARG };
            $err_str =~ s| at $sub_name line (\d+)[\.,]
                         | [ line $LAST_PAREN_MATCH ]\n|sx
                if defined $err_str;
            $warn_count_total += $warn_count
                = scalar $s_comp_stderr =~ s| at $sub_name line (\d+)[\.,]
                    | [ line $LAST_PAREN_MATCH ]\n|sgx

                if defined $s_comp_stderr and $s_comp_stderr;
            ( my $lpw )
                = ( $data{'system'}{'start'}{'log_prefix_width'}
                    // $code{'base.get_start_lpw'}->() || 24 );
            my $width = 76 - $lpw;
            local $Text::Wrap::columns   = $width;
            local $Text::Wrap::separator = "\n";
            delete $data{'code'}{$sub_name}{'warnings'};  ## clear previous ##
            my @compile_errors = (
                '>',
                ".:[ $sub_name ]:.",
                ':',
                (   map  { s|Can.t|cannot|g; s|"|'|g; ": :  \l$ARG" }
                    grep { !m|^BEGIN | } split( m|\n+|, $err_str )
                ),
                '='
                )
                if length( $err_str // '' )
                or defined $s_comp_stderr;
            push(
                @compile_errors,
                '>',
                '  :: warning ::',
                '  :',
                (   map {
                        push(
                            @{  $data{'code'}{$sub_name}{'warnings'} //= []
                            },
                            "\l$ARG"
                        );
                        "  :: \l$ARG"
                    } split( m|\n+|, $s_comp_stderr )
                ),
                '..,'
            ) if defined $s_comp_stderr;

            $code{'base.stderr_restore'}->();

            $compilation_success = 0 if $source_len == 0;

            if ($compilation_success) {

                $data{'base'}{'p7_mod'}{'loaded'}->{$module_name} = 1;

                delete $data{'code'}{$sub_name}{'source'};
                $data{'code'}{$sub_name}{'status'}
                    = $warn_count ? 'warned' : 'no-error';
                $ok_count++;
                if (    $sub_name !~ m{\.(cmd|console)\.}
                    and $sub_name =~ m|\.end_code$| ) {
                    ## needs module namespace for defined callback order ##
                    push( @{ $data{'callbacks'}{'end_code'} }, $sub_name );
                }
            } else {

                $data{'base'}{'p7_mod'}{'errors'}->{$module_name}++;

                $code{$sub_name} = sub {
                    if ( $sub_name !~ m{\.(cmd|console)\.(.+)$} ) {
                        $code{'log.error'}
                            ->("<<< called broken routine :: $sub_name >>>");
                        return undef;
                    } else {
                        $code{'log.error'}
                            ->("<<< broken command called :: $sub_name >>>");
                        return {
                            'mode' => 'nak',
                            'data' => "command '$sub_name' is broken.,"
                                . " details in startup log.,"
                        };
                    }
                };
                delete $data{'code'}{$sub_name}{'source'};
                $data{'base'}{'modules'}{'load_errors'}++;
                $data{'buffer'}{'compile-errors'}{'max_size'} //= 42 * 1024;
                my @wrapped_error
                    = map { split m|\n|, $t_wrap->($ARG) } @compile_errors;
                $code{'log.error'}->(@wrapped_error);
                map {
                    $code{'base.buffer.add_line'}->( 'compile-errors', $ARG )
                } @wrapped_error if defined $code{'base.buffer.add_line'};

                $err_str =~ s|\n| |sg;
                $err_str =~ tr| ||s;
                $data{'code'}{$sub_name}{'status'} = "[error] $err_str";
                undef $s_comp_stderr;
                undef $err_str;
                $warn_count = 0;
                $err_count++;
            }
            if ( $compilation_success and $warn_count ) {
                $data{'buffer'}{'compile-errors'}{'max_size'} //= 42 * 1024;
                my @wrapped_error
                    = map { split m|\n|, $t_wrap->($ARG) } @compile_errors;
                $code{'log.error'}->(@wrapped_error);
                map {
                    $code{'base.buffer.add_line'}->( 'compile-errors', $ARG )
                } @wrapped_error if defined $code{'base.buffer.add_line'};
                $warn_count = 0;
            }

            if ( $sub_name =~ m{\.(cmd|console)\.(.+)$} )
            {    # command desciptions #
                my $section = ${^CAPTURE}[0];
                my $command = ${^CAPTURE}[1];
                if ( $data{'code'}{$sub_name}{'status'} eq 'no-error' ) {
                    if ( $sub_code =~ m|#\s*param\s*=\s*(.+)| ) {
                        $data{'base'}{'commands'}{$section}{$command}{'param'}
                            = ${^CAPTURE}[0];
                    }
                    if ( $sub_code =~ m|#\s*descr\s*=\s*(.+)| ) {
                        $data{'base'}{'commands'}{$section}{$command}{'descr'}
                            = ${^CAPTURE}[0];
                    } else {
                        $data{'base'}{'commands'}{$section}{$command}{'descr'}
                            = '<<< \'descr\' header key not defined >>>';
                    }

                # } elsif ( $data{'code'}{$sub_name}{'status'} ne 'warned' ) {
                } else {
                    $code{'log.error'}
                        ->( ':', "::[ broken zenka command '${2}' ]", ':' );
                    $code{'log.error'}->(@compile_errors)
                        if not $data{'base'}{'modules'}{'load_errors'}++;
                    $data{'base'}{'commands'}{$section}{$command}{'descr'}
                        = '<<< command did not compile properly >>>';
                }
            }
        }
        delete $data{'callbacks'}{'end_code'}
            if !@{ $data{'callbacks'}{'end_code'} };
        map {
            $data{'code'}{$ARG}{'status'} = 'undefined'
                if not defined $code{$ARG}
            }
            keys %{ $data{'code'} };
        my $p     = '..: ';
        my $s     = $ok_count != 1         ? 's' : '';
        my $w     = $warn_count_total == 1 ? ''  : 's';
        my $w_msg = !$warn_count_total ? '' : ", $warn_count_total warning$w";

        if ($err_count) {
            $code{'log.error'}->( $p
                    . "success on $ok_count sub$s,"
                    . " $err_count broken$w_msg., `:|" );
        } elsif ($warn_count_total) {
            $code{'log.error'}
                ->( $p . "success on $ok_count sub$s$w_msg :|" );
        } else {
            $src_bytes_total = sprintf( "%.2f", $src_bytes_total / 1024 );
            $src_bytes_total =~ s|\.?0+$||;
            $code{'log.noerr'}->(
                sprintf(
                    $p . "%d sub%s., %dK src., no errors., =)",
                    $ok_count, $s, $src_bytes_total
                )
            );
        }
        return ( $ok_count, $err_count );
    };

    $code{'base.stderr_redir'} = sub {
        my $redir_ref = shift // \my $redir_var;
        open( $data{'base'}{'stderr_fh'}, '>&', STDERR )
            or print "\n<< ! >> cannot clone STDERR [ \l$OS_ERROR ]\n\n";
        close(STDERR);
        open( STDERR, '>', $redir_ref ) or say "< stderr_redir > \l$OS_ERROR";
        return $redir_ref;
    };

    $code{'base.stderr_restore'} = sub {
        my $restore_fh = delete $data{'base'}{'stderr_fh'};
        close(STDERR);
        if ( defined $restore_fh ) {
            open( STDERR, '>&', $restore_fh )
                or print "\n<< ! >> cannot restore STDERR"
                . " to $restore_fh [ \l$OS_ERROR ]\n\n";
        } else {
            open( STDERR, '>', File::Spec->devnull() )
                or print "\n<< ! >> cannot restore STDERR"
                . " to '/dev/null' [ \l$OS_ERROR ]\n\n";
        }
    };

    $code{'base.collect_sub_stats'} = sub {    ## [ LLL ] .. implement ., ###
        my $sub_name = shift;
    };

    $code{'base.debug_sub'} = sub {
        return if $data{'system'}{'verbosity'}{'console'} < 2;
        my $sub_name = shift(@_);
        ## $code{'base.collect_sub_stats'}->($sub_name); # <-- replace touch_dir
        my $quoted_chars = qr{[\ ;:,\.'\\]|^$};
        my @_p           = @_;

      # log all used subroutines if $sub_touch_dir exist and is owned by root.
        my $sub_touch_dir = $data{'system'}{'path'}{'sub_log_dir'}
            // '/var/tmp/protocol-7_debug.sub_log';
        if ( -d $sub_touch_dir
            and File::stat::stat($sub_touch_dir)->uid == 0 ) {
            my $zenka_name = $data{'system'}{'zenka'}{'name'};
            my $actual_dir = "$sub_touch_dir/$zenka_name";
            if ( !-d $actual_dir ) {
                my ( $dir_uid, $dir_gid );
                my $dir_mode = 0777;  ##  fallback mode ., non-critical.., ###
                if ( defined $data{'system'}{'privs'}{'user'} ) {
                    ( undef, undef, $dir_uid, $dir_gid )
                        = getpwnam( $data{'system'}{'privs'}{'user'} );
                    ## regular mode ###
                    $dir_mode = 0770;
                }
                mkdir( $actual_dir, 0700 ) or warn "$actual_dir : $!";
                chown( $dir_uid, $dir_gid, $actual_dir ) if defined $dir_gid;
                chmod( $dir_mode, $actual_dir ) or warn "$actual_dir : $!";
            }
            open( my $_fh, ">$actual_dir/$sub_name" )
                if !-f ">$actual_dir/$sub_name";
            if ( fileno($_fh) ) {
                say {$_fh} $code{'base.ntime'}->(3);
                close($_fh);
            }
        }

      # hiding plain text passwords in debug output [not including conf files]
        $_p[2] = '*' x 7 if $sub_name eq 'net.authme';
        $_p[1] = '*' x 7 if $sub_name eq 'auth.ok';
        $_p[0] = '*' x 7 if $sub_name eq 'chk-sum.sha.1';
        $_p[1] =~ s|^(auth [^\ ]+) [^\ ]+\n$|$LAST_PAREN_MATCH *****\n|o
            if $sub_name eq 'net.out';

        map { $ARG =~ s|(\')|\\$LAST_PAREN_MATCH|go if defined $ARG } @_p;
        my @params = map {
            defined $ARG
                ? ( $ARG =~ $quoted_chars ? "'$ARG'" : $ARG )
                : ''
        } @_p;

        my $param_list = join( ', ', @params );

        $param_list =~ s|\n|\\n|g;
        $param_list =~ s|\e|\\e|g;
        $param_list =~ s|\0|\\0|g;

        ## replacing perl objects ##
        eval { use Crypt::Misc qw| encode_b32r | }
            if not defined &{'encode_base32'};
        if ( $param_list =~ s|\'?(\S+(::\S+)+)|lc(${^CAPTURE}[0])|ge ) {
            $param_list =~ s|::|.|g;
            $param_list =~ s|event\.event|event|g;
        }
        $param_list =~ s{=(CODE|SCALAR|GLOB|HASH|ARRAY)}
                        {' : '.lc($LAST_PAREN_MATCH)}ige;
        $param_list =~ s{(CODE|SCALAR|GLOB|HASH|ARRAY)}
                        {lc($LAST_PAREN_MATCH)}ge;
        $param_list =~ s{\(0x([a-f0-9]+)\)\'?}{ sprintf( " :: %s ::",
             substr( encode_b32r(pack("V*",
              Digest::Elf::elf(${^CAPTURE}[0]))) , 2,3 )
             .'0'. substr(
              Digest::Elf::elf(pack("H*",${^CAPTURE}[0])), -3, 3 )
             )
        }gxe if defined &{'encode_b32r'} and defined &Digest::Elf::elf;
        ## [ LLL ] ids need to become resolvable + debug command ..,
        say sprintf(
            "$ANSI{p7_fg_0000}. %s$ANSI{p7_fg_0001} : $ANSI{p7_fg_0004}%s"
                . " [ $ANSI{p7_fg_0003}%s$ANSI{p7_fg_0000} ]"
                . $ANSI{'reset'},
            $data{'system'}{'zenka'}{'name'},
            $sub_name, $param_list
            )
            if $sub_name ne 'base.log'
            and ( $sub_name ne 'base.buffer.add_line' or $_[0] ne 'zenka' )
            and $sub_name ne 'base.dump_data';  # skipping too much output ..,
    };

    $code{'base.log_hook'} = sub {
        ## flush early zenka log buffer ###
        if (    defined $data{'system'}{'start'}{'zenka-buffer'}
            and @{ $data{'system'}{'start'}{'zenka-buffer'} }
            and defined $code{'base.buffer.add_line'} ) {
            my $buffer = $data{'system'}{'start'}{'zenka-buffer'};
            while ( my $log_line = shift( @{$buffer} ) ) {
                my $log_level
                    = $log_line =~ m|^\S+ (\-?\d+) | ? $LAST_PAREN_MATCH : 0;
                $code{'base.buffer.add_line'}
                    ->( 'zenka', $log_line, $log_level )
                    if $log_level
                    <= $data{'system'}{'verbosity'}{'zenka_buffer'}
                    or $log_level
                    <= $data{'system'}{'verbosity'}{'zenka_logfile'};
            }
            delete $data{'system'}{'start'}{'zenka-buffer'};
        }
        ##
        return 0
            if
            not $data{'system'}{'use_http_source'}  # <-- check if required .,
            or not defined $data{'base'}{'httpc'}{'last_mlen'}
            or not $data{'system'}{'verbosity'}{'console'};
        if ( my $last_len = delete $data{'base'}{'httpc'}{'last_mlen'} ) {
            local $OUTPUT_AUTOFLUSH = 1;
            my $spaces = ' ' x $last_len;
            print "\r$spaces\r" and return $last_len;
        }
        return 0;
    };

    $code{'log.name_template'} = sub {
        my $lpw = shift;
        return sprintf(
            "%s%s. %s.%-${lpw}s .%s",
            $ANSI{'p7_bg'}, $ANSI{'p7_fg_0000'},
            $data{'system'}{'node'}{'name'},
            $data{'system'}{'zenka'}{'name'},
            $ANSI{'p7_bg_0000'}
        );
    };
    $code{'log.format_name'} = sub {
        my $last_lpw = $data{'log'}{'lpw'}{'last'} // 0;
        my $lpw
            = $data{'system'}{'zenka'}{'log_prefix_width'}
            - length( $data{'system'}{'node'}{'name'} )
            - 1;

        if ($last_lpw) {
            my $lpw_delta = $lpw - $last_lpw;
            if ( $lpw_delta > 0 ) {    ## adjust in steps ##
                $lpw = ++$last_lpw;
            } elsif ( $lpw_delta != 0 ) {
                $lpw = --$last_lpw;
            }
        }

        $data{'log'}{'lpw'}{'last'} = $lpw;
        return $code{'log.name_template'}->($lpw);
    };

    $code{'log.noerr'} = sub {
        my $s_len;
        $s_len = $code{'base.log_hook'}->()
            if defined $code{'base.log_hook'};
        $s_len //= 1;    # <-- << ! >>
        my $spaces = ' ' x $s_len;
        if ( defined $code{'base.log'} ) {
            map { $code{'base.log'}->( 1, $ARG ) } @_;
        } else {
            if ( $data{'system'}{'verbosity'}{'console'} ) {
                map {
                    say &{ $code{'log.format_name'} }, ' ',
                        $ANSI{'p7_fg_0004'}, $ARG, $ANSI{'reset'},
                        $spaces
                } @_;
            }
            ## early start-up buffer ##
            map {
                push(
                    @{ $data{'system'}{'start'}{'zenka-buffer'} },
                    join( ' ', $code{'base.anum_log_time'}->(), 1, $ARG )
                )
            } @_ if $data{'system'}{'verbosity'}{'zenka_buffer'};
        }
    };

    $code{'log.error'} = sub {
        my $error_color
            = $data{'system'}{'term'}{'colors'}{'stderr'}
            ? $ANSI{'bold'}
            : '';
        $code{'base.log_hook'}->() if defined $code{'base.log_hook'};
        if ( defined $code{'base.log'} and defined &{ $code{'base.log'} } ) {
            map { $code{'base.log'}->( 0, $ARG ) } @_;
        } else {
            map {
                if ( defined $ARG ) {
                    my $n_n = $data{'system'}{'node'}{'name'}  // '';
                    my $a_n = $data{'system'}{'zenka'}{'name'} // '';
                    my $s_len
                        = defined $code{'base.log_hook'}
                        ? $code{'base.log_hook'}->()
                        : 0;
                    my $spaces = ' ' x $s_len;
                    say &{ $code{'log.format_name'} }, ' ',
                        $ANSI{'p7_fg_0004'}, $ARG,
                        $spaces, $ANSI{'p7_fg_0004'}, $ARG, $ANSI{'reset'},
                        $spaces;

                } else {
                    warn '<< error message undefined >> <{C1}>';
                }
            } @_;
            ## early start-up buffer ##
            map {
                push(
                    @{ $data{'system'}{'start'}{'zenka-buffer'} },
                    join( ' ', $code{'base.anum_log_time'}->(), 0, $ARG )
                )
            } @_;
        }
    };

    $code{'log.debug'} = sub {
        $code{'base.log_hook'}->() if defined $code{'base.log_hook'};
        if ( defined $code{'base.log'} ) {
            map { $code{'base.log'}->( 2, $ARG ) } @_;
        } else {
            if ( $data{'system'}{'verbosity'}{'console'} > 1 ) {
                my $s_len;
                $s_len = $code{'base.log_hook'}->()
                    if defined $code{'base.log_hook'};
                $s_len //= 0;
                my $spaces = ' ' x $s_len;
                map {
                    say &{ $code{'log.format_name'} }, $ANSI{'p7_fg_0001'},
                        $ARG, $ANSI{'reset'},
                        $spaces
                } @_;
            }
            ## early start-up buffer ##
            map {
                push(
                    @{ $data{'system'}{'start'}{'zenka-buffer'} },
                    join( ' ', $code{'base.anum_log_time'}->(), 2, $ARG )
                )
            } @_ if $data{'system'}{'verbosity'}{'zenka_buffer'} > 1;
        }
    };

    $code{'dev.null'} = $code{'base.undef'} = sub { return undef };

    $code{'base.sig_warn'} = sub {
        my $s_len;
        $s_len = $code{'base.log_hook'}->() if defined $code{'base.log_hook'};
        $s_len //= 0;
        my $spaces = ' ' x $s_len;
        if (@_) {
            my $level = 0;
            chomp( my @err = @_ );
            map {
                $ARG =~ s|([^[:print:]])
                           | sprintf("[%03d]",ord($LAST_PAREN_MATCH)) |aegx
            } @err;
            push( @err, $spaces ) if length($spaces);
            if ( $err[0] =~ m|^Deep recursion | ) {
                no warnings 'recursion';    # no follow-ups
                my $msg = join( ' ', '<< FATAL >>', @err );
                undef $code{'base.log'}
                    if $err[0] =~ m{$PROGRAM_NAME|protocol-7};
                $code{'log.error'}->($msg);
                exit(2);
            }
            my @caller = caller;
            my ( $package, $filename, $line, $subroutine ) = @caller;
            if ( defined $data{'sig_warn_blacklist'} )
            {    # LLL: <-- use an array.
                return
                    if defined $data{'sig_warn_blacklist'}{'package'}
                    and $package eq $data{'sig_warn_blacklist'}{'package'}
                    or defined $data{'sig_warn_blacklist'}{'pattern'}
                    and join( ' ', @err )
                    =~ $data{'sig_warn_blacklist'}{'pattern'};
            } # todo: human readable way do debug [eval] callers., [+stacktrc?]
            map {
                $ARG =~ s| at $filename line $line[\.,].*$||;
                $ARG =~ s|no success on eval ('\$code\{\S+)
                         |<< $LAST_PAREN_MATCH >>|x;
                $level = ${^CAPTURE}[0] || 1
                    if $ARG =~ s| *<\{C(\d{1,3})?\}>$||
            } @err;
            if ($level) {    # <-- log parent caller instead ('<{C[level]}>')
                @caller = caller($level);
                ( $package, $filename, $line, $subroutine ) = @caller;
            }

            # special exception for zenka code evaluation [ base.init ]
            my $abs_filename = abs_path($filename);
            my $abs_ex_name
                = abs_path( $data{'system'}{'start'}{'exec_name'} );
            if (    defined $SUB_NAME
                and defined $abs_ex_name
                and defined $abs_filename
                and $abs_filename eq $abs_ex_name
                and $SUB_NAME eq 'base.init' ) {
                my $l = 0;
                $filename = $data{'base'}{'eval_error'}{'name'}
                    //= [ caller($l) ]->[1];
                $line = $data{'base'}{'eval_error'}{'line'}
                    //= [ caller($l) ]->[2];
            }
            $filename
                =~ s|^/usr/share/perl5/||;    ## shorten path for .pm modules
            my $caller_str = "[$filename:$line]";
            $caller_str = "[ ... caller level $level too high .., ]"
                if !length( $filename . $line );
            my $log_warning = 1;
            ## alternative handlers registered for filename:line ? ##
            my $match_param = "$filename:$line";    # <-- expand .., [LLL]
            if ( defined $data{'base'}{'warn-match-handler'}{$match_param} ) {
                my $cb_name
                    = $data{'base'}{'warn-match-handler'}{$match_param};
                ( my $msg_str = join( ' ', @err ) ) =~ s{^\s+|\s+$}{}g;
                $log_warning
                    = $code{$cb_name}->( $msg_str, $match_param, @caller )
                    if defined $code{$cb_name};
            }
            ##
            push( @err, $caller_str );
            $code{'log.error'}->( join( ' ', '<< warn >>', @err ) )
                if $log_warning;
        }
        return 1;
    };

    $code{'base.handler.end_code'} = sub {
        goto RESET_STDERR if not exists $data{'callbacks'}{'end_code'};
        foreach
            my $callback_name ( reverse @{ $data{'callbacks'}{'end_code'} } )
        {
            if ( exists $code{$callback_name} ) {
                $code{'base.log'}
                    ->( 2, "calling end_code callback '$callback_name'..," );
                $code{$callback_name}->();
            } else {
                $code{'base.log'}->(
                    0,
                    '<<  referenced end_code callback '
                        . "'$callback_name'"
                        . ' does not exist >>'
                );
            }
        }
    RESET_STDERR:
        eval { print STDERR $ANSI{'reset'} }   ## [LLL] check 'output' mode ##
            if defined $ANSI{'reset'} and fileno(STDERR);
    };

    map {
        $data{'base'}{'core_subs'}{$ARG} = $code{$ARG};
        $data{'code'}{$ARG}{'status'} = 'core-sub'
    } keys %code;
}

END {
    $code{'base.handler.end_code'}->();
}

#.............................................................................
#C2OTZIW3ZZ2NJQSTVSPHPNXDKAJ34O2SCOIUV743FRMBX6BWGZ2OU5VFBA37SW45E2ISXSUHFA6JM
#::: W2N5EMRMZP7SOLYBQIDQDYTTBBWJOSNQVMWAP56UYG5OMMRRML2 :::: NAILARA AMOS :::
# :: RNQZGV6O7N2UCWIGR6OTT46IAHOFD4T6WX2EMMZJXYXTZEV4USCQ :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
