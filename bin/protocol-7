#!/usr/bin/perl -C31

use v5.28.0;
use strict;
use warnings;
use English;

BEGIN {
    my $bin_path = $PROGRAM_NAME;
    while ( my $link_target = readlink($bin_path) ) { $bin_path = $link_target }
    ( my $local_lib_path = $bin_path ) =~ s|/[^/]+/[^/]+$|/lib/pm|;
    unshift( @INC, $local_lib_path ) if -d $local_lib_path;
}

# somewhat reduntant with -C31 ... to be decided later [which to drop]..,
use open ':encoding(UTF-8)';
map { binmode( $ARG, ':encoding(UTF-8)' ) } ( *STDIN, *STDOUT, *STDERR );

# globals
our %code;
our %data;
our %KEYS;
our %ANSI;

prepare_subs();

&{ $code{'base.init_exec'} };

$code{'base.load_code'}->('base');

my $agentname;

if ( $PROGRAM_NAME =~ m|^.*protocol-7\.| ) {
    $agentname = lc($PROGRAM_NAME);
    $agentname =~ s|^.*protocol-7\.||g;
} elsif ( defined $ARGV[0] and $ARGV[0] =~ m|^([^\-].*)| ) {
    $agentname = $1;
    shift(@ARGV);
}

( $agentname, @ARGV ) = ( split( m| +|, $agentname ), @ARGV )
    if defined $agentname and index( $agentname, ' ' ) != -1;

( $data{'system'}{'args'} = join( ' ', @ARGV ) ) =~ s| *-[v]+( *)|$1|;

if ( defined $agentname and $agentname ne '' ) {
    if ( $data{'system'}{'startup_initcode'} ) {
        $data{'startup'}{'init_code'} = [];
        $code{'log.noerr'}->('< awaiting stdin init-code');
        while (<STDIN>) {
            push( @{ $data{'startup'}{'init_code'} }, $ARG );
        }
        my $lines = @{ $data{'startup'}{'init_code'} };
        my $s     = $lines != 1 ? 's' : '';
        $code{'log.noerr'}->("> read $lines line$s of init-code");
    }
    $code{'base.init'}->( $data{'system'}{'node'}{'name'} . '.' . $agentname );
} else {
    if ( !@ARGV or not defined $data{'system'}{'agent'}{'name'} ) {
        $data{'system'}{'agent'}{'name'} = '<stdin>';
    }
    $PROGRAM_NAME = "protocol-7.$data{'system'}{'agent'}{'name'}";
    $RS           = "\n";

    my @agent_code = <STDIN>;

    if ( $data{'system'}{'daemon_mode'} ) { $code{'base.daemonize'}->() }

    if (@agent_code) {
        $data{'base'}{'config_parser'}{'cfg_type'}  = 'start_cfg';
        $data{'base'}{'config_parser'}{'cfg_name'}  = 'agent';
        $data{'base'}{'config_parser'}{'cfg_descr'} = '<STDIN>';
        $code{'base.execute_agent_code'}
            ->( $code{'base.parser.config'}->( \@agent_code ) );
    }
}

$code{'log.noerr'}->("done.");
close;
exit;

# :: definition of basic subroutines and agent initialization ::

sub prepare_subs {
    $ENV{'PATH'} = '/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin';
    delete @ENV{qw| IFS CDPATH ENV BASH_ENV |};
    $ENV{'LC_NUMERIC'} = 'en_US.UTF-8';

    eval { use Text::Wrap qw| wrap | };    ## <-- used in 'base.load_code' ##

    # installing 'Time::HiRes' versions of 'base.time' and 'base.sleep'
    my $th_ref
        = (
              eval 'use Time::HiRes; return [ '
            . 'sub{ my $f = $_[0]; $f = 6 if not defined $f or $f =~ m|\D|;'
            . ' sprintf( "%.${f}f", Time::HiRes::time ) }, \&Time::HiRes::sleep'
            . ' ]' );
    $data{'system'}{'perl_module'}{'installed'}{'Time::HiRes'} = 1
        if defined $th_ref and ref($th_ref) eq 'ARRAY';
    $th_ref = [ sub { time() }, sub { select( undef, undef, undef, $_[0] ) } ]
        if not defined $th_ref
        or ref($th_ref) ne 'ARRAY';
    $code{'base.time'}  = \&{ $th_ref->[0] };
    $code{'base.sleep'} = \&{ $th_ref->[1] };
    undef $th_ref;

    $code{'base.ntime'} = sub { # [ network time : secs from 2002-06-05 * 4200 ]
        my $param = shift // 0;
        my $ntime = $data{'base'}{'ntime_ustart'} //= 1023228000;
        my ( $cur_time, $precision ) = ( undef, 0 );
        if ( length($param) >= 9 ) {    # < unix time + inherited precision >
            $cur_time  = $param;
            $precision = length($1) if $cur_time =~ m{\.(\d+)$};
        } else {
            $precision = $param > 11 ? 11 : $param;
            $cur_time  = $code{'base.time'}->( 2 + $precision );
        }
        return sprintf( "%.${precision}f", ( $cur_time - $ntime ) * 4200 );
    };

    $code{'base.ntime.b32'} = sub {
        my $ntime_value = $code{'base.ntime'}->(shift);  # <-- precision \ utime
        my @nt          = split( m|\.|, $ntime_value );
        $nt[1] = '7' . $nt[1] if scalar @nt == 2;    # <-- 7 catches prefixed 0
        return encode_b32r( pack( 'w*', @nt ) );
    };

    $code{'base.load_b32_encoder'} = sub {
        if (    not defined &encode_b32r
            and not defined $data{'modules'}{'startup_error'}{'base32'} ) {
            eval { use Crypt::Misc qw| encode_b32r | };
            if ( $EVAL_ERROR or not defined &encode_b32r ) {
                $data{'modules'}{'startup_error'}{'base32'} = 1;
                return 0;    # module not found ##
            } else {
                return 1;    ## loading successful ##
            }
        } else {
            return 1;        ## function already present ##
        }
    };

    $code{'base.anum_log_time'} = sub {
        my $nt_param = shift // 3; # <-- LLL: make configurable, precision\utime
        if ( &{ $code{'base.load_b32_encoder'} } ) {
            return $code{'base.ntime.b32'}->($nt_param);
        } else {
            my $ntime_value = $code{'base.ntime'}->($nt_param);
            return $ntime_value;
        }
    };

    $code{'base.log_prefix_width'} = sub {
        my $agent_name = shift // $data{'system'}{'agent'}{'name'};
        my $node_name  = $data{'system'}{'node'}{'name'};

        return length("$node_name.$agent_name");
    };

    ### basic subroutine definitions ###

    $code{'base.init_exec'} = sub {

        ## first perl modules ##
        use utf8;
        use File::Spec::Functions;
        use FindBin qw| $RealBin $RealScript |;
        use Cwd 'abs_path';
        use Sys::Hostname;
        use File::stat;

        use constant 'τ'   => 6.28318530717958647692;
        use constant 'tau' => 'τ';

        $SIG{'PIPE'} = 'IGNORE';
        ## overriding warn subroutine ###
        $SIG{'__WARN__'} = $code{'base.sig_warn'};

        ## early variable initialization ##
        my $actual_exec = abs_path( catfile( $RealBin, $RealScript ) );
        my $bin_path    = [ File::Spec->splitpath($actual_exec) ]->[1];
        $data{'system'}{'start'}{'true_exec'} = $actual_exec;
        $data{'system'}{'start'}{'exec_name'}
            = File::Spec->rel2abs( canonpath($PROGRAM_NAME) )
            ;    # apparent exec [symlink]
        $data{'system'}{'root_path'} = abs_path( catdir( $bin_path, updir() ) );
        $data{'system'}{'perl_version'} = $PERL_VERSION;       # < v5.6
        $data{'system'}{'perl_version'} = sprintf( "%vd", $^V ) if defined $^V;
        $data{'system'}{'perl_unicode'} = ${^UNICODE};
        my $root_path = $data{'system'}{'root_path'};
        $data{'system'}{'code_path'} = catdir( $root_path, 'src' );
        $data{'system'}{'conf_path'} = catdir( $root_path, 'cfg' );
        $data{'system'}{'lmod_path'} = catdir( $root_path, 'lib', 'pm' );
        delete $data{'system'}{'lmod_path'} if !-d $data{'system'}{'lmod_path'};
        $data{'base'}{'httpc'}{'last_mlen'}  //= 80;
        $data{'buffer'}{'agent'}{'max_size'} //= 64 * 1024;    # 64K log-buffer
        $data{'buffer'}{'compile-errors'}{'max_size'} //= 42 * 1024;

        ## source code version ##
        my $ver_str = $data{'protocol-7'}{'source-version'} = 'unknown';
        my $version_file
            = catfile( $data{'system'}{'conf_path'},
            'protocol-7.source-version' );
        if ( -e $version_file and open( my $ver_fh, '<' . $version_file ) ) {
            ( $data{'protocol-7'}{'source-version'} = $ver_str = <$ver_fh> )
                =~ s|\s||g;
            close($ver_fh);
        }
        ## source code release version ##
        my $release_file = catfile( $data{'system'}{'conf_path'},
            'protocol-7.release-version' );
        if ( -e $release_file and open( my $ver_fh, '<' . $release_file ) ) {
            ( $data{'protocol-7'}{'release-version'} = $ver_str = <$ver_fh> )
                =~ s|\s||g;
            close($ver_fh);
        }
        ## determine agent name and subname ###
        if ( $PROGRAM_NAME =~ m|^.*protocol-7\.| ) {
            $data{'system'}{'agent'}{'initialized'} = 0;
            $data{'system'}{'agent'}{'name'}        = lc($PROGRAM_NAME);
            $data{'system'}{'agent'}{'name'} =~ s,^.*protocol-7\.|[\. ]$,,g;
        } elsif ( defined $ARGV[0] and $ARGV[0] =~ m|^([^\-].*)| ) {
            my $agent_name = $1;
            $data{'system'}{'agent'}{'subname'} = $1
                if $agent_name =~ s|\[([^\]]+)\]$||;
            $data{'system'}{'agent'}{'name'} = $agent_name;
        }
        if ( not defined $data{'system'}{'agent'}{'name'}
            or $data{'system'}{'agent'}{'name'} eq '' ) {
            $data{'system'}{'agent'}{'name'} = '<init>';
        }

        #   ( $data{'system'}{'node'}{'name'},
        #    $data{'system'}{'agent'}{'name'} ) = split ( m|\.|, $_[0] ); #[LLL]

        ## early verbosity settings ###
        $data{'system'}{'verbosity'}{'console'}       = 0;
        $data{'system'}{'verbosity'}{'agent_buffer'}  = 1;
        $data{'system'}{'verbosity'}{'agent_logfile'} = 0;

        $data{'system'}{'ansi_color'} = 1;
        $data{'system'}{'start'}{'showbanner'} = 1;

        my $stdin_mode = 1;
        ## process command line arguments ###
        $data{'system'}{'console-mode'} //= 0;
        foreach my $arg (@ARGV) {
            $stdin_mode = 0 if $arg =~ m|^[^\-]|;
            if ( $arg =~ m|^-(v+)$| ) {
                $data{'system'}{'verbosity'}{'console'} = length($1);
            }
            if ( $arg eq '-d' ) { $data{'system'}{'daemon_mode'} = 1 }
            if ( $arg eq '-stdin' ) {
                $data{'system'}{'startup_initcode'} = 1;
                $data{'system'}{'console-mode'}     = 0; ## LLL: more conditions
            }
            if ( $arg eq '-console' ) {
                $data{'system'}{'console-mode'} = 1;
                $code{'log.error'}->('<< in console mode >>');
            }
            if ( $arg eq '-na' ) { $data{'system'}{'ansi_color'} = 0 }
            if ( $arg eq '-nb' ) { $data{'system'}{'start'}{'showbanner'} = 0; }
            if ( $arg =~ /^-N(.+)$/ ) { $data{'system'}{'agent'}{'name'} = $1; }
            elsif ($stdin_mode) {
                $data{'system'}{'agent'}{'name'} = '<stdin>';
            }
            if ( $arg =~ m|^-lpw=(\d{1,2})$| ) {    # <- used by 'nroot' agent
                $data{'system'}{'start'}{'log_prefix_width'} = $1;
            }
            if ( $arg eq '-use-http-src' ) {
                $data{'system'}{'use_http_source'} = 1;
            }
            if ( $arg eq '-export-core-subs' ) {
                $code{'dump_core_subs'}->();
                exit(0);
            }
        }
        ### load agent code from stdin ###
        $data{'system'}{'path'}{'rel'}{'cur_agent_cfg'} = '<STDIN>'
            if $stdin_mode;
        $data{'system'}{'node'}{'name'} = hostname() // 'protocol-7';
        $data{'system'}{'node'}{'name'} =~ s|\..+$||;

        ## defining console ansi colors ###
        if ( $data{'system'}{'ansi_color'} ) {
            %ANSI = (
                'bold'      => "\c[[1m",
                'yelblue'   => "\c[[44m\c[[33m\c[[38;5;202m\c[[48;5;17m",
                'underline' => "\c[[4m",
                'reverse'   => "\c[[7m",
                'normal'    => "\c[[m",
                'cls'       => "\c[[H\c[[2J"
            );
        } else {
            %ANSI = (
                'yelblue'   => '',
                'bold'      => "<< ",
                'underline' => "<< ",
                'reverse'   => "<< ",
                'normal'    => " >>",
                'cls'       => "\c[[H\c[[2J"
            );
        }
        ## prepare agent name column width ###
        my $own_len = &{ $code{'base.log_prefix_width'} };

        if ( defined $data{'system'}{'start'}{'log_prefix_width'}
            and $own_len <= $data{'system'}{'start'}{'log_prefix_width'} ) {

            my $dot_cnt
                = $data{'system'}{'start'}{'log_prefix_width'} - $own_len + 1;

            $data{'log'}{'dots'} = '.' x $dot_cnt;
        }
        ## nailara start-up banner ##
        if (   $data{'system'}{'verbosity'}{'console'}
            && $data{'system'}{'start'}{'showbanner'} ) {
            say ".\n.";
            &{ $code{'base.banner'} };
        }
        ## initializing early agent buffer capture ###
        $data{'system'}{'start'}{'agent-buffer'} = [];
        my $seperator_len = 18 + length( $data{'system'}{'agent'}{'name'} );
        map { push( @{ $data{'system'}{'start'}{'agent-buffer'} }, $ARG ) } (
            join( ' ',
                $code{'base.anum_log_time'}->(),
                1, '_' x $seperator_len ),
            $code{'base.anum_log_time'}->()
                . " 1 STARTUP 'agents/$data{system}{agent}{name}'/",
            $code{'base.anum_log_time'}->()
                . " 1 VERSION '$data{'protocol-7'}{'source-version'}'"
        );
    };

    $code{'base.banner'} = sub {
        my $version_str = sprintf( " \\ protocol-seven version \\ %s \\",
            $data{'protocol-7'}{'source-version'} );
        local $RS = undef;
        open( my $banner_fh,
            catfile( $data{'system'}{'conf_path'}, '.banner' ) )
            or return;
        my $banner = <$banner_fh>;
        close($banner_fh);
        my $n = $b = '';
        if ( $data{'system'}{'ansi_color'} ) {
            $n = $ANSI{'normal'} and $b = $ANSI{'bold'};
        } else {
            $ANSI{'yelblue'} = '';
        }
        map { say "$n: $b$ARG" } split( m|\n|, $banner ), '';
        say "$n: $version_str\n:";
    };

    $code{'dump_core_subs'} = sub {
        my %core_subs;
        my $bin_path = $data{'system'}{'start'}{'exec_name'};
        open( my $nlr_fh, $bin_path ) or die "$bin_path: $OS_ERROR\n";
        my %sub_src;
        my $sub_name;
        foreach my $src_line (<$nlr_fh>) {
            $sub_name = undef
                if defined $sub_name and $src_line =~ m|^\s*};\s*(#.*)?\n$|;
            if ( defined $sub_name ) {
                $sub_src{$sub_name} //= [];
                push( @{ $sub_src{$sub_name} }, $src_line );
            }
            $sub_name = $1
                if $src_line
                =~ m|^\s*\$code\{\'([^\']+)\'\}\s*=\s*sub\s*\{\s*(#[^\n]*)?\n$|;
        }
        print "\n";
        close($nlr_fh);
        foreach
            my $sub_name ( sort { length $a <=> length $b } sort keys %sub_src )
        {
            print "\n#  .::[ $sub_name ]:.\n#  ::\n";
            foreach my $sub_line ( @{ $sub_src{$sub_name} } ) {
                print $sub_line;
            }
            print "\n#  .\n#  ::.\n";

        }
        exit;
    };

    $code{'base.purge_code'} = sub { # [LLL] callback registry : skipping purge.
        my $code_name   = shift;
        my $purge_count = 0;
        my @agent_commands;
        map {
            if (    $ARG !~ m{\.(callback|handler)\.}
                and not exists $data{'base'}{'core_subs'}{$ARG}
                and $ARG ne 'base.log'
                and $ARG ne 'base.s_read'
                and $ARG ne 'base.gen_id'
                and $ARG ne 'base.sig_int'
                and $ARG ne 'base.s_write'
                and $ARG ne 'base.sig_warn'
                and $ARG ne 'base.route.add'
                and $ARG ne 'base.buffer.add_line'
                and $ARG ne 'base.list.element.add'
                and $ARG ne 'base.log.send_buffer_line'
                and $ARG ne 'base.log.handler.log_reply'
                and $ARG ne 'nroot.handler.agent_output'
                and $ARG ne 'base.protocol-7.command.send.local' ) {
                ++$purge_count
                    and $data{'code'}{$ARG}{'status'} = 'purged'
                    and
                    eval { undef &{ delete $code{$ARG} } };   # <--improve [LLL]

#           #[ debug ]
#           and $code{$ARG} = eval "sub { print STDERR \"\n MISSING '$ARG'\n\n\" }";

                push( @agent_commands, $1 ) if $ARG =~ m|\.cmd\.(.+)$|;
                --$purge_count              if $EVAL_ERROR;
            } elsif ( not exists $data{'base'}{'core_subs'}{$ARG} ) {
                $data{'code'}{$ARG}{'status'}
                    = 'leftover';    ## kept \ essential ##
            }
            }
            grep {m|^$code_name(\..+)?$|} keys %code;
        map {
            delete $data{'base'}{'cmd'}{$ARG};
            delete $data{'base'}{'commands'}{'cmd'}{$ARG};
        } @agent_commands;
        return $purge_count;
    };

    $code{'base.parser.ellipse_center'} = sub {
        my $str_param = shift;
        my $len_param = shift;
        die "expected string and maximum length [>=5] parameters"
            if not defined $str_param
            or not defined $len_param
            or $len_param =~ m|^\d+$| and $len_param < 5;

        my $by_reference = ref($str_param) eq 'SCALAR' ? 1 : 0;
        my $str_ref      = $by_reference ? $str_param      : \$str_param;
        my $str_len      = length($$str_ref);
        my $start_pos    = int( $len_param / 2 ) - 1;
        my $chars_cut    = $str_len - $len_param + 3;

        return 0          if $by_reference and $str_len <= $len_param;
        return $str_param if $str_len <= $len_param;
        return $str_len - $len_param if $by_reference;

        substr( $$str_ref, $start_pos, $chars_cut, '.,.' );
        return $$str_ref;
    };
    $code{'base.code.file_list'} = sub {
        my $codedir_fh;
        $data{'base'}{'modules'}{'load_errors'} //= 0;
        if ( !opendir( $codedir_fh, $data{'system'}{'code_path'} ) ) {
            $data{'base'}{'modules'}{'load_errors'}++;
            $code{'log.error'}->( ": can not open source code directory"
                    . " '$data{'system'}{'code_path'}' [$OS_ERROR]" );
            return undef;
        }
        my @subroutine_names = sort { length $a <=> length $b }
            sort grep { !m|^\.| } readdir($codedir_fh);
        closedir($codedir_fh);
        return @subroutine_names;
    };

    $code{'base.code.sort_filter'} = sub {
        my @subroutine_names = @_;
        my %subroutines      = map { $ARG => 0 } @subroutine_names;
        my $occurrence       = 0;

        #        map { say $ARG } @subroutine_names;
        return @subroutine_names;
    };

    $code{'base.httpc.remote_file'} = sub {

        $data{'base'}{'warned'}{'http_src_deactivated'} //= 0;
        warn 'source loading over http has been temporarely deactivated'
            if !$data{'base'}{'warned'}{'http_src_deactivated'}++;

        return undef;    ## feature temporarely deactivated ##

        return undef if !( $data{'system'}{'use_http_source'} // 1 );
        my $http_retries = $data{'system'}{'http_src_retries'} // 4;
        eval { use HTTP::Tiny } if !$data{'system'}{'http_reqs'};
        $EVAL_ERROR =~ s| ?\(\@INC contains:.+\n?$|| if $EVAL_ERROR;
        warn
            "<< 'HTTP::Tiny' pmod. not found [ yet in corelist ] [ $EVAL_ERROR ] >>"
            and return undef
            if $EVAL_ERROR;
        $data{'system'}{'http_reqs'}++;
        my $file_name = shift // '';
        my $base_urls = shift // ['https://nailara.network/sourcecode/'];
        warn "expected http file name" and return undef
            if !length($file_name);
        warn "expected array ref to base urls" and return undef
            if ref($base_urls) ne 'ARRAY' or !@{$base_urls};
        ####
        # $code{'log.debug'}->(": $file_name .,");
        $OUTPUT_AUTOFLUSH = 1;
        foreach my $http_base_url ( @{$base_urls} ) {
            my $abs_url = join( '/', $http_base_url, $file_name );
            $abs_url =~ s|//$file_name$|/$file_name|;
            my $h_res;
            my $retries      = $data{'system'}{'http_retries_total'} //= 0;
            my $retries_left = $http_retries;
            while ( $retries_left-- ) {
                my $r = $retries ? "[$retries\\$http_retries]" : '';
                ( my $msg_url = $abs_url ) =~ s|^(\w+)://|<$1> |;
                my $len
                    = length( $data{'system'}{'agent'}{'name'} )
                    + length( $data{'system'}{'host'}{'hostname'} // '' );
                $len = 26 if $len < 27;

                my $w_len
                    = 95 - $len
                    - (
                          length( $data{'system'}{'node'}{'name'} )
                        + length( $data{'system'}{'agent'}{'name'} ) );

                $code{'base.parser.ellipse_center'}->( \$msg_url, $w_len )
                    if defined $msg_url;

                $msg_url =~ s| | : |;
                my $m_len    = length($msg_url);
                my $last_len = $data{'base'}{'httpc'}{'last_mlen'};
                $data{'base'}{'httpc'}{'last_mlen'} = length($msg_url) + 13;
                my $s     = ' ' x $last_len;
                my $m_str = "\r$s\r: $msg_url.,";
                print "\r$m_str\r"
                    if $data{'system'}{'verbosity'}{'console'} == 1;
                $code{'log.debug'}->(":$r: $msg_url")
                    if $retries_left != $retries;
                my $h_obj = $data{'base'}{'httpc'}{'obj'}
                    //= HTTP::Tiny->new( 'timeout' => 7 );
                $h_res = $h_obj->get($abs_url);
                my $h_code = $h_res->{'status'};

                if ( not $h_res->{'success'} ) {
                    my $r_str = $EVAL_ERROR ? " < $EVAL_ERROR >" : '';
                    goto skiplog_httpmsg;
                    $code{'log.debug'}->(
                        sprintf(
                            ":[ %d ] %s : [ %s ]%s",
                            $h_code, $abs_url, $h_res->{'reason'}, $r_str
                        )
                    );
                skiplog_httpmsg:
                    if ( $h_code == 404 or $h_code eq 599 ) {
                        $retries_left = 0;
                        $code{'log.noerr'}->( ":: aborting retries ["
                                . " after first $h_code code ] ::" );
                        return undef;
                    } else {    ## client side rate limiting ##
                        $code{'base.sleep'}->(
                            0.13 + rand(
                                0.777 * ++$data{'system'}{'http_retries_total'}
                            )
                        );
                    }
                    next;
                }
                if ( $h_code == 200 and length $h_res->{'content'} ) {
                    return $h_res->{'content'};
                } else {
                    warn "<< failed to acquire http file '$file_name' >>";
                    return undef;
                }
            }
        }
        $OUTPUT_AUTOFLUSH = 0;
    };

    $code{'base.chk_nlr_path'} = sub { ## LLL: todo : reduce calls \ exposure .,
        my $chk_path = shift // '';
        my $d_aref   = shift // [qw| ext/ / |];
        my $base_dir = shift // $data{'system'}{'root_path'} // '';
        die "no base_dir defined"        if !length($base_dir);
        die "chk_path argument expected" if !length($chk_path);
        die "expected array ref as second argument"
            if ref($d_aref) ne 'ARRAY';

        if ( $data{'system'}{'use_http_source'} ) {
            return $chk_path
                if exists $data{'base'}{'httpc'}{'remote_source'}->{$chk_path};
            ## else | not exists ###
            warn "<< remote source file not found : $chk_path >> <{C1}>";
            return undef;
        }
        my $f_path;
        foreach my $chk_parent ( @{$d_aref} ) {
            $f_path
                = canonpath(
                catfile( catfile( $base_dir, $chk_parent ), $chk_path ) );
            ( my $path_str = catfile( $chk_parent, $chk_path ) ) =~ s|^/+||;
            return $path_str if defined $f_path and -r $f_path;
        }
        $data{'modules'}{'warned'}{$f_path} //= {}; # <-- LLL: clean up later..,
        my $reason
            = ( -l $f_path and !-r readlink($f_path) ) ? 'readable' : 'found';
        warn "<< source not $reason : '$chk_path' >> <{C1}>"
            if !$data{'modules'}{'warned'}{$f_path}++;
        return undef;
    };

    $code{'base.source_path_valid'} = sub {
        my $src_file_rel = shift // '';
        warn 'no file name supplied' if !length($src_file_rel);
        my $src_remote = $data{'base'}{'httpc'}{'remote_source'} // {};
        ## ignored ##
        return 0
            if !length($src_file_rel)
            or $src_file_rel =~ m,~$|\.orig$|\.LOG$,;
        ## remote ##
        return 1
            if $data{'system'}{'use_http_source'}
            and exists $src_remote->{$src_file_rel};
        ## local ##
        my $src_abs_path = abs_path(
            catfile( $data{'system'}{'root_path'}, $src_file_rel ) );
        return 1
            if defined $src_abs_path
            and ( -f $src_abs_path
            or -l $src_abs_path and -f readlink($src_abs_path) );
        warn "<< no match : $src_abs_path >> <{C1}>";
        return 0;    # <-- no match.
    };

    $code{'base.load_code'} = sub {
        my ( $file, $code_name );
        my @module_names = sort { length $a <=> length $b } sort @_;

        $data{'callbacks'}{'end_code'} //= [];

        map { $code{'plugins.status'}->{$ARG}->{'load_errors'} = 0 }
            grep {m|^plugin\.|} @module_names;

        ## http source ### ..,/.v7/file-list
        my $base_url_aref = $data{'system'}{'http_src_base_urls'};
        my @http_src_base_urls
            = ref($base_url_aref) eq 'ARRAY'
            ? @{$base_url_aref}
            : qw| http://nailara.network/sourcecode http://src.v7.ax/nailara/ |;

        my $src_from_http = (
            ( $data{'system'}{'use_http_source'} // 0 )
                or !-r $data{'system'}{'code_path'}
                and not( $data{'system'}{'no_http_source'} // 0 )
        ) ? 1 : 0;

        $data{'system'}{'use_http_source'} = $src_from_http;

        my $c_ref            = $data{'base'}{'source'}{'code_files'} // [];
        my @subroutine_names = @{$c_ref};

        if ($src_from_http) {
            $code{'log.error'}->("<<< network source loading enabled >>>")
                if !@subroutine_names;
            ##### remote source code access ###
            my $method = $1 if $http_src_base_urls[0] =~ m|^(\w+):|;
            $code{'log.debug'}->(": reading source file list over $method ..,");
            my $remote_data_str
                = $code{'base.httpc.remote_file'}
                ->( '.v7/file-list/base', \@http_src_base_urls );
            if ( defined $remote_data_str ) {
                my $read_len = length($remote_data_str);
                @subroutine_names = split( m|\n|, $remote_data_str );
                $data{'base'}{'httpc'}{'remote_source'} = {};
                map {
                    $data{'base'}{'httpc'}{'remote_source'}->{"src/$ARG"} = 1
                } @subroutine_names;
                $data{'base'}{'source'}{'code_files'} = \@subroutine_names;
            } else {
                $code{'log.error'}
                    ->(": no success reading remote source file list .,");
                $code{'log.noerr'}->(": :");
                $code{'log.error'}->(": :. terminating startup sequence..,");
                $code{'log.noerr'}->(':....,');
                if ( defined $code{'base.exit'} ) {
                    $code{'base.exit'}->(1);
                } else {
                    exit(1);
                }
            }
            ####
        } else {
            $code{'log.debug'}->(": reading source list from disk.,");
            @subroutine_names = $code{'base.code.file_list'}->();
            my $file_cnt = scalar @subroutine_names;
            $code{'log.debug'}->(": :. $file_cnt files. [src]");
        }
        $OUTPUT_AUTOFLUSH = 1;
        my @compile_order = ();
        while ( $code_name = shift @module_names ) {
            my $src_str = $code_name =~ m|^(.+/)?plugin.| ? '' : ' source';
            $code{'log.noerr'}->(": loading$src_str '$code_name'");

            if ( my $purge_count = $code{'base.purge_code'}->($code_name) ) {
                my $s = $purge_count == 1 ? '' : 's';
                $code{'log.debug'}->(": $purge_count sub$s undefined");
            }

            my $code_count      = 0;
            my $last_code_count = 0;
            if ( exists $data{'base'}{'modules'}{'internal_name'} ) {
                my $internal_name
                    = delete $data{'base'}{'modules'}{'internal_name'};
                delete $data{'base'}{'modules'}{'moved_to'}{$internal_name}
                    if exists $data{'base'}{'modules'}{'moved_to'};
            }

            foreach my $file_name (@subroutine_names) {
                next if not defined $file_name or !length($file_name);
                ## todo : reconcile with code_path ##
                my $src_abs_path;
                my $src_rel = $code{'base.chk_nlr_path'}->("src/$file_name");

                $src_rel = "src/$file_name" if not defined $src_rel; # <-- warn.

                $src_abs_path
                    = abs_path(
                    catfile( $data{'system'}{'root_path'}, $src_rel ) )
                    if defined $src_rel;

                if (    $src_rel =~ m|^(.*/)?$code_name(\..+)?$|
                    and $code{'base.source_path_valid'}->($src_rel) ) {
                    $code_count++;
                    local $RS = undef;
                    if ( $src_from_http
                        or !-r $src_abs_path
                        and !( $data{'system'}{'no_http_source'} // 0 ) ) {
                        #### read src from network [ more methods to come ] ####

                        # $code{'log.debug'}->(":[http]: $src_rel .,");

                        $data{'code'}{$file_name}{'source'}
                            = $code{'base.httpc.remote_file'}
                            ->( $src_rel, \@http_src_base_urls );
                        ####
                    } else {
                        ## loading code from disk [ including ./ext directory ]
                        $code{'log.debug'}->(":[disk]: $src_rel .,");
                        open( my $src_fh, '<', $src_abs_path )
                            or die ":$src_abs_path : $OS_ERROR";
                        $data{'code'}{$file_name}{'source'} = <$src_fh>;
                        close($src_fh);
                    }

                    # <[sub_name]>->(  -->  $code{'sub_name'}->(
                    my $orig_len
                        = length( $data{'code'}{$file_name}{'source'} );

                    $data{'code'}{$file_name}{'source'}
                        =~ s|(?<!\\)<\[([\w\-]+\.[\w\-\.]+?)\]>\s*->\(
                            |\$code{'$1'}->(|sgxo;

                    # < ! > the parser currently does not respect quoted strings
                    #       escape like \<[sub.name]> <-- this to avoid a match.
                    #
                    # note: a generic quoted string match might be :  ##########
                    # ####  (["'])(?:\\?+.)*?\1 or "([ˆ"]<(?<=\\)")+" #[mre:212]

                    # <[sub_name]>  -->  $code{'sub_name'}->()
                    $data{'code'}{$file_name}{'source'}
                        =~ s|(?<!\\)<\[([\w\-]+\.[\w\-\.]+)\]>
                            |\$code{'$1'}->()|gxo;

                    # <foo.bar>  -->  $data{'foo'}{'bar'}
                    # (requires at least 1 . in the data key to match)
                    $data{'code'}{$file_name}{'source'}
                        =~ s|(?<!\\)<([\w\-:]+\.[\w\-\.:]+)(?<!\\)>
                            |my $k="\$data{'$1'}";$k=~s/\./'}{'/g;$k|gexo;
                    $RS = "\n";
                    if (length( $data{'code'}{$file_name}{'source'} )
                        > $orig_len
                        and $data{'system'}{'verbosity'}{'console'} > 3 ) {
                        $code{'log.error'}->( "\n\n .: $file_name :.\n\n"
                                . $data{'code'}{$file_name}{'source'} );

                        $data{'plugins'}{'status'}{$code_name}{'load_errors'}++
                            if !length($src_str);    # <- is plugin..
                    }
                    push( @compile_order, $file_name );
                } elsif ( $file_name =~ m|\.orig$| ) {
                    $code{'log.error'}->("[invalid\\remove.,] $file_name");
                }
            }
            if (    $data{'system'}{'verbosity'}{'console'} == 1
                and $data{'system'}{'use_http_source'}
                and exists $data{'base'}{'httpc'}{'last_mlen'} ) {
                my $last_mlen = delete $data{'base'}{'httpc'}{'last_mlen'};
                $last_mlen += 92;
                $last_mlen = 79 if $last_mlen > 79;
                my $space_str = ' ' x $last_mlen;
                $OUTPUT_AUTOFLUSH = 1;
                print "\r$space_str\r";
                $OUTPUT_AUTOFLUSH = 0;
            }
            if ( !$code_count ) {
                $code{'log.error'}
                    ->(": no success loading src '$code_name' \t[ not found ]");
                $data{'base'}{'modules'}{'load_errors'}++;
            } elsif ( $code_count > $last_code_count ) {
                $data{'system'}{'subs_loaded'}{$code_name}
                    = $code_count - $last_code_count;
            }
            $last_code_count = $code_count;
        }
        my $mod_count = scalar @compile_order;
        return if !$mod_count and !@module_names;
        next   if !$mod_count;
        my $src_bytes_total = 0;
        $code{'log.debug'}->(": compiling ..,");
        my ( $ok_count, $err_count, $warn_count ) = ( 0, 0, 0 );

        my %disabled_commands;
        map { $disabled_commands{$ARG} = 1 } @{ $data{'disabled_commands'} }
            if exists $data{'disabled_commands'}
            and ref( $data{'disabled_commands'} ) eq 'ARRAY';

        ## sort [ and filter ] in code occurence order ###
        # @compile_order = $code{'base.code.sort_filter'}->(@compile_order);
        ##
        foreach my $sub_name (@compile_order) {

            local $SIG{'__WARN__'} = 'IGNORE';
            local $SIG{'__DIE__'}  = 'IGNORE';

            my $sub_code     = undef;
            my $code_header  = '';
            my $code_footer  = '';
            my $sub_conflict = 0;

            if ( $sub_name =~ m{\.(cmd|console)\.(.+)$} ) {
                my $cmd_type = $1;
                my $cmd_name = $2;
                next
                    if $cmd_type eq 'cmd'
                    and exists $disabled_commands{$cmd_name};
                if ( exists $data{'base'}{$cmd_type}{$cmd_name} ) {
                    my $old_sub = $data{'base'}{$cmd_type}{$cmd_name};
                    if (not exists $data{'base'}{'overwritten'}{$cmd_type}
                        {$cmd_name} ) {
                        if ( $sub_name ne $old_sub ) {
                            $code{'log.debug'}->("[!] $sub_name >> $old_sub");
                        } else {
                            $code{'log.debug'}->("[!] replacing sub $sub_name");
                        }
                        $data{'base'}{'overwritten'}{$cmd_type}{$cmd_name} = {
                            'old' => $old_sub,
                            'new' => $sub_name
                        };
                    } else {
                        push(
                            @{  $data{'base'}{'overwritten'}
                                    {$cmd_type}{$cmd_name}{'conflicts'}
                            },
                            $sub_name
                        );
                        $data{'base'}{'modules'}{'load_errors'}++;
                        $code{'log.error'}->("[!] conflict: $sub_name");
                        $sub_conflict = 1;
                    }
                }

                $data{'base'}{$cmd_type}{$cmd_name} = $sub_name
                    if !$sub_conflict;
                my $stat_start_cref
                    = defined $code{'stats.sub_start'}
                    ? $code{'stats.sub_start'}->($sub_name)
                    : sub { };
                my $stat_end_cref
                    = defined $code{'stats.sub_end'}
                    ? $code{'stats.sub_end'}->($sub_name)
                    : sub { };
                $code_footer
                    .= "\$code{'stats.sub_end'}->(\$sub_name)"
                    . " if ref(\$code{'stats.sub_end'}) eq 'CODE';";
                $code_header
                    = 'my $call={}; my $reply={ \'mode\' => \'nak\', \'data\''
                    . " => \"error during invocation of '$cmd_name' command"
                    . " [ details logged ]\" }; "
                    . "\$code{'stats.sub_start'}->(\$sub_name) if defined "
                    . "ref(\$code{'stats.sub_start'}) eq 'CODE'; "
                    . 'if ( ref( $_[0] ) eq \'HASH\' ) { '
                    . ' $call=$_[0]; } else { $$call{\'args\'}=$_[0] } ';
                $code_footer = ' ; return $reply';

                $data{'code'}{$sub_name}{'source'}
                    = $code_header
                    . $data{'code'}{$sub_name}{'source'}
                    . $code_footer;
            }

            if ( $data{'system'}{'verbosity'}{'console'} > 2 ) {
                my $line_comment = "\n# line 1 \"" . $sub_name . "\"\n";
                $sub_code
                    = 'sub {'
                    . $line_comment
                    . "\&{\$code{'base.debug_sub'}}('$sub_name',\@_); "
                    . $data{'code'}{$sub_name}{'source'} . ' }';
            } else {
                my $line_comment = "\n# line 1 \"" . $sub_name . "\"\n";
                $sub_code
                    = 'sub {'
                    . $line_comment
                    . $data{'code'}{$sub_name}{'source'} . '}';
            }

            ##                      ###
            ## compiling subroutine ###
            ##                      ###
            my $stderr_fh;
            open( $stderr_fh, ">&STDERR" )
                or print "\n<< ! >> cannot clone STDERR [ $OS_ERROR ]\n\n";
            close(STDERR);
            open STDERR, '>', \my $s_comp_stderr
                or print "stderr.redir: $OS_ERROR\n";
            $src_bytes_total += length($sub_code);
            my $compilation_success
                = ( $code{$sub_name} = eval($sub_code)
                    and ref( $code{$sub_name} ) eq 'CODE' )
                ? 1
                : 0;
            my $err_str = $EVAL_ERROR;
            state $t_wrap //=
                ( defined &wrap )
                ? sub { return wrap( '', ':   :  ', $ARG ) }
                : sub { return $ARG };
            map {
                $ARG =~ s| at $sub_name line (\d+)\.\n| ( line $1 )\n|sg
                    if defined $ARG;
            } ( $err_str, $s_comp_stderr );
            local $Text::Wrap::columns   = 57;
            local $Text::Wrap::separator = "\n";
            delete $data{'code'}{$sub_name}{'warnings'};    ## clear previous ##
            my @compile_errors = (
                '>',
                ".:[ $sub_name ]:.",
                ':',
                (   map  { s|Can.t|cannot|g; s|"|'|g; ": <<!>> \l$ARG" }
                    grep { !m|BEGIN not safe| } split( m|\n+|, $err_str )
                ),
                '='
            );
            push(
                @compile_errors,
                '>',
                '  :: warning ::',
                '  :',
                map {
                    ++$warn_count and push(
                        @{ $data{'code'}{$sub_name}{'warnings'} //= [] },
                        "\l$ARG"
                    );
                    "  :. \l$ARG"
                } split( m|\n+|, $s_comp_stderr ),
                '='
            ) if defined $s_comp_stderr;
            close(STDERR);

            open( STDERR, ">&", $stderr_fh )
                or print "\n<< ! >> cannot restore STDERR [ $OS_ERROR ]\n\n";

#            my $dev_null_path = File::Spec->devnull();
#            open STDERR, ">$dev_null_path" or print "$dev_null_path: $OS_ERROR\n";

            if ($compilation_success) {
                delete $data{'code'}{$sub_name}{'source'};
                $data{'code'}{$sub_name}{'status'}
                    = $warn_count ? 'warned' : 'no-error';
                $ok_count++;
                if (    $sub_name !~ m{\.(cmd|console)\.}
                    and $sub_name =~ m|\.end_code$| ) {
                    push( @{ $data{'callbacks'}{'end_code'} }, $sub_name );
                }
            } else {
                $code{$sub_name} = sub {
                    {
                        $code{'log.error'}
                            ->("< ! > - [ broken cmd sub '$sub_name' called ]");
                        return {
                            'mode' => 'nak',
                            'data' =>
                                "$1 command is broken <!> see startup log"
                            }
                            if $sub_name =~ m|\.cmd\.(.+)$|;
                    }
                };
                delete $data{'code'}{$sub_name}{'source'};
                $data{'base'}{'modules'}{'load_errors'}++;
                $code{'log.error'}
                    ->( map { split m|\n|, $t_wrap->($ARG) } @compile_errors );
                map {
                    $code{'base.buffer.add_line'}->( 'compile-errors', $ARG )
                    } @compile_errors
                    if defined $code{'base.buffer.add_line'};

                $err_str =~ s|\n| |sg;
                $err_str =~ tr| ||s;
                $data{'code'}{$sub_name}{'status'} = "[error] $err_str";
                $err_count++;
            }
            if ( $compilation_success and $warn_count ) {
                $code{'log.error'}
                    ->( map { split m|\n|, $t_wrap->($ARG) } @compile_errors );
                map {
                    $code{'base.buffer.add_line'}->( 'compile-errors', $ARG )
                    } @compile_errors
                    if defined $code{'base.buffer.add_line'};
            }

            if ( $sub_name =~ m{\.(cmd|console)\.(.+)$} )
            {    # command desciptions #
                my $section = $1;
                my $command = $2;
                if ( $data{'code'}{$sub_name}{'status'} eq 'no-error' ) {
                    if ( $sub_code =~ m|#\s*param\s*=\s*(.+)| ) {
                        $data{'base'}{'commands'}{$section}{$command}{'param'}
                            = $1;
                    }
                    if ( $sub_code =~ m|#\s*descr\s*=\s*(.+)| ) {
                        $data{'base'}{'commands'}{$section}{$command}{'descr'}
                            = $1;
                    } else {
                        $data{'base'}{'commands'}{$section}{$command}{'descr'}
                            = '<<< \'descr\' header key not defined >>>';
                    }
                } else {
                    $data{'base'}{'modules'}{'load_errors'}++;
                    $code{'log.error'}
                        ->( ':', "::[ broken agent command '$2' ]", ':' );
                    $data{'base'}{'commands'}{$section}{$command}{'descr'}
                        = '<<< command did not compile properly >>>';
                }
            }
        }
        delete $data{'callbacks'}{'end_code'}
            if !@{ $data{'callbacks'}{'end_code'} };
        map {
            $data{'code'}{$ARG}{'status'} = 'removed'
                if not exists $code{$ARG}
            }
            keys %{ $data{'code'} };
        my $s = $ok_count != 1 ? 's' : '';
        if ($err_count) {
            $code{'log.error'}
                ->(": success on $ok_count sub$s, $err_count broken., `:|");
        } elsif ($warn_count) {
            my $w = $warn_count == 1 ? '' : 's';
            $code{'log.error'}
                ->(": success on $ok_count sub$s, $warn_count warning$w :|");
        } else {
            $src_bytes_total = sprintf( "%.2f", $src_bytes_total / 1024 );
            $src_bytes_total =~ s|\.?0+$||;
            $code{'log.noerr'}->(
                sprintf(
                    ": %d sub%s., %dK src., no errors., =)",
                    $ok_count, $s, $src_bytes_total
                )
            );
        }
        return ( $ok_count, $err_count );
    };

    $code{'base.collect_sub_stats'} = sub {    ## [ LLL ] .. implement ., ###
        my $sub_name = shift;
    };

    $code{'base.debug_sub'} = sub {
        return if $data{'system'}{'verbosity'}{'console'} < 2;
        my $sub_name = shift(@_);
        ## $code{'base.collect_sub_stats'}->($sub_name); # <-- replace touch_dir
        my $quoted_chars = qr/[\ ;:,\.'\\]|^$/o;
        my @_p           = @_;

        # log all used subroutines if $sub_touch_dir exist and is owned by root.
        my $sub_touch_dir = $data{'system'}{'path'}{'sub_log_dir'}
            // '/tmp/nailara_debug.sub_log';
        if ( -d $sub_touch_dir
            and File::stat::stat($sub_touch_dir)->uid == 0 ) {
            my $agent_name = $data{'system'}{'agent'}{'name'};
            my $actual_dir = "$sub_touch_dir/$agent_name";
            if ( !-d $actual_dir ) {
                mkdir($actual_dir);
                chmod( 0777, $actual_dir );
            }
            open( my $_fh, ">$actual_dir/$sub_name" )
                if !-f ">$actual_dir/$sub_name";
            if ( fileno($_fh) ) {
                say {$_fh} $code{'base.ntime'}->(3);
                close($_fh);
            }
        }

        # hiding plain text passwords in debug output [not including conf files]
        $_p[2] = '*' x 7 if $sub_name eq 'net.authme';
        $_p[1] = '*' x 7 if $sub_name eq 'auth.ok';
        $_p[0] = '*' x 7 if $sub_name eq 'digest.sha.1';
        $_p[1] =~ s|^(auth [^\ ]+) [^\ ]+\n$|$1 *****\n|o
            if $sub_name eq 'net.out';

        map { $ARG =~ s|(\')|\\$1|go if defined $ARG } @_p;
        my @params = map {
            defined $ARG
                ? ( $ARG =~ $quoted_chars ? "'$ARG'" : $ARG )
                : ''
        } @_p;

        my $param_list = join( ', ', @params );

        $param_list =~ s|\n|\\n|g;
        $param_list =~ s|\e|\\e|g;
        $param_list =~ s|\0|\\0|g;

        ## replacing perl objects ##
        eval { use Crypt::Misc qw| encode_b32r | }
            if not defined &{'encode_base32'};
        if ( $param_list =~ s|\'?(\S+(::\S+)+)|lc($1)|ge ) {
            $param_list =~ s|::|.|g;
            $param_list =~ s|event\.event|event|g;
        }
        $param_list =~ s{=(CODE|SCALAR|GLOB|HASH|ARRAY)}{' : '.lc($1)}ige;
        $param_list =~ s{(CODE|SCALAR|GLOB|HASH|ARRAY)}{lc($1)}ge;
        $param_list =~ s{\(0x([a-f0-9]+)\)\'?}{ sprintf( " :: %s ::",
            lc(encode_b32r(pack("H*",$1))))
        }gxe
            if defined &{'encode_b32r'};
        ##
        say sprintf(
            ' . %s : %s [ %s ]',
            $data{'system'}{'agent'}{'name'},
            $sub_name, $param_list
            )
            if $sub_name ne 'base.log'
            and ( $sub_name ne 'base.buffer.add_line' or $_[0] ne 'agent' )
            and $sub_name ne 'base.dump_data';    # skipping too much output..,
    };

    $code{'base.log_hook'} = sub {
        ## flush early agent log buffer ###
        if (    defined $data{'system'}{'start'}{'agent-buffer'}
            and @{ $data{'system'}{'start'}{'agent-buffer'} }
            and defined $code{'base.buffer.add_line'} ) {
            my $buffer = $data{'system'}{'start'}{'agent-buffer'};
            while ( my $log_line = shift( @{$buffer} ) ) {
                my $log_level = $log_line =~ m|^\S+ (\-?\d+) | ? $1 : 0;
                $code{'base.buffer.add_line'}
                    ->( 'agent', $log_line, $log_level )
                    if $log_level
                    <= $data{'system'}{'verbosity'}{'agent_buffer'}
                    or $log_level
                    <= $data{'system'}{'verbosity'}{'agent_logfile'};
            }
            delete $data{'system'}{'start'}{'agent-buffer'};
        }
        ##
        return 0
            if not defined $data{'base'}{'httpc'}{'last_mlen'}
            or not $data{'system'}{'verbosity'}{'console'};
        if ( my $last_len = delete $data{'base'}{'httpc'}{'last_mlen'} ) {
            local $OUTPUT_AUTOFLUSH = 1;
            my $spaces = ' ' x $last_len;
            print "\r$spaces\r" and return $last_len;
        }
        return 0;
    };

    $code{'log.noerr'} = sub {
        my $s_len;
        $s_len = $code{'base.log_hook'}->()
            if defined $code{'base.log_hook'};
        $s_len //= 1;    # <-- << ! >>
        my $spaces = ' ' x $s_len;
        if ( defined $code{'base.log'} ) {
            map { $code{'base.log'}->( 1, $ARG ) } @_;
        } else {
            if ( $data{'system'}{'verbosity'}{'console'} ) {
                my $dot
                    = defined $data{'log'}{'dots'}
                    ? $data{'log'}{'dots'}
                    : '.';
                map {
                    say ':.', $data{'system'}{'node'}{'name'},
                        $dot, $data{'system'}{'agent'}{'name'}, '.', $ARG,
                        $spaces
                } @_;
            }
            ## early start-up buffer ##
            map {
                push(
                    @{ $data{'system'}{'start'}{'agent-buffer'} },
                    join( ' ', $code{'base.anum_log_time'}->(), 1, $ARG )
                )
            } @_ if $data{'system'}{'verbosity'}{'agent_buffer'};
        }
    };

    $code{'log.error'} = sub {
        $code{'base.log_hook'}->() if defined $code{'base.log_hook'};
        if ( defined $code{'base.log'} and defined &{ $code{'base.log'} } ) {
            map { $code{'base.log'}->( 0, $ARG ) } @_;
        } else {
            my $dot
                = defined $data{'log'}{'dots'}
                ? $data{'log'}{'dots'}
                : '.';
            map {
                if ( defined $ARG ) {
                    my $n_n = $data{'system'}{'node'}{'name'}  // '';
                    my $a_n = $data{'system'}{'agent'}{'name'} // '';
                    my $s_len
                        = defined $code{'base.log_hook'}
                        ? $code{'base.log_hook'}->()
                        : 0;
                    my $spaces  = ' ' x $s_len;
                    my $msg_str = $ARG . $spaces;
                    say ':.', $n_n, $dot, $a_n, '.', $ANSI{'bold'} // '',
                        $msg_str, $ANSI{'normal'} // '';
                } else {
                    warn '<< error message undefined >> <{C1}>';
                }
            } @_;
            ## early start-up buffer ##
            map {
                push(
                    @{ $data{'system'}{'start'}{'agent-buffer'} },
                    join( ' ', $code{'base.anum_log_time'}->(), 0, $ARG )
                )
            } @_;
        }
    };

    $code{'log.debug'} = sub {
        $code{'base.log_hook'}->() if defined $code{'base.log_hook'};
        if ( defined $code{'base.log'} ) {
            map { $code{'base.log'}->( 2, $ARG ) } @_;
        } else {
            if ( $data{'system'}{'verbosity'}{'console'} > 1 ) {
                my $s_len;
                $s_len = $code{'base.log_hook'}->()
                    if defined $code{'base.log_hook'};
                $s_len //= 0;
                my $spaces = ' ' x $s_len;
                my $dot
                    = defined $data{'log'}{'dots'}
                    ? $data{'log'}{'dots'}
                    : '.';
                map {
                    my $msg_str = $ARG . $spaces;
                    say ':.', $data{'system'}{'node'}{'name'},
                        $dot, $data{'system'}{'agent'}{'name'}, '.', $msg_str
                } @_;
            }
            ## early start-up buffer ##
            map {
                push(
                    @{ $data{'system'}{'start'}{'agent-buffer'} },
                    join( ' ', $code{'base.anum_log_time'}->(), 2, $ARG )
                )
            } @_ if $data{'system'}{'verbosity'}{'agent_buffer'} > 1;
        }
    };

    $code{'dev.null'} = $code{'base.undef'} = sub { return undef };

    $code{'base.sig_warn'} = sub {
        my $s_len;
        $s_len = $code{'base.log_hook'}->() if defined $code{'base.log_hook'};
        $s_len //= 0;
        my $spaces = ' ' x $s_len;
        if (@_) {
            my $level = 0;
            chomp( my @err = @_ );
            map { $ARG =~ s|([^[:print:]])| sprintf("[%03d]",ord($1)) |age }
                @err;
            push( @err, $spaces ) if length($spaces);
            if ( $err[0] =~ m|^Deep recursion | ) {
                no warnings 'recursion';    # no follow-ups
                my $msg = join( ' ', '<< FATAL >>', @err );
                undef $code{'base.log'}
                    if $err[0] =~ m{$PROGRAM_NAME|protocol-7};
                $code{'log.error'}->($msg);
                exit(2);
            }
            my @caller = caller;
            my ( $package, $filename, $line, $subroutine ) = @caller;
            if ( defined $data{'sig_warn_blacklist'} ) { # LLL: <- use an array.
                return
                    if defined $data{'sig_warn_blacklist'}{'package'}
                    and $package eq $data{'sig_warn_blacklist'}{'package'}
                    or defined $data{'sig_warn_blacklist'}{'pattern'}
                    and join( ' ', @err )
                    =~ $data{'sig_warn_blacklist'}{'pattern'};
            }  # todo: human readable way do debug [eval] callers., [+stacktrc?]
            map {
                $ARG =~ s| at $filename line $line[\.,].*$||;
                $level = $1 || 1 if $ARG =~ s| *<\{C(\d{1,3})?\}>$||
            } @err;
            if ($level) {    # <- log parent caller instead ('<{C[level]}>')
                @caller = caller($level);
                ( $package, $filename, $line, $subroutine ) = @caller;
            }

            # special exception for agent code evaluation
            if ( abs_path($filename) eq
                abs_path( $data{'system'}{'start'}{'exec_name'} )
                and $line == 56 ) {
                my $l = 0;
                $filename = $data{'base'}{'eval_error'}{'name'}
                    //= [ caller($l) ]->[1];
                $line = $data{'base'}{'eval_error'}{'line'}
                    //= [ caller($l) ]->[2];
            }
            $filename =~ s|^/usr/share/perl5/||; ## shorten path for .pm modules
            my $caller_str = "[ $filename, $line ]";
            $caller_str = "[ ... caller level $level too high .., ]"
                if !length( $filename . $line );
            my $log_warning = 1;
            ## alternative handlers registered for filename:line ? ##
            my $match_param = "$filename:$line";    # <-- expand .., [LLL]
            if ( defined $data{'base'}{'warn-match-handler'}{$match_param} ) {
                my $cb_name
                    = $data{'base'}{'warn-match-handler'}{$match_param};
                ( my $msg_str = join( ' ', @err ) ) =~ s{^\s+|\s+$}{}g;
                $log_warning
                    = $code{$cb_name}->( $msg_str, $match_param, @caller )
                    if defined $code{$cb_name};
            }
            ##
            push( @err, $caller_str );
            $code{'log.error'}->( join( ' ', '<< warn >>', @err ) )
                if $log_warning;
        }
    };

    $code{'base.handler.end_code'} = sub {
        return if not exists $data{'callbacks'}{'end_code'};
        foreach
            my $callback_name ( reverse @{ $data{'callbacks'}{'end_code'} } ) {
            if ( exists $code{$callback_name} ) {
                $code{'base.log'}
                    ->( 2, "calling end_code callback '$callback_name'..," );
                $code{$callback_name}->();
            } else {
                $code{'base.log'}->(
                    0,
                    "<< ! >> referenced end_code callback "
                        . "'$callback_name' does not exist. << ! >>"
                );
            }
        }
    };

    map {
        $data{'base'}{'core_subs'}{$ARG} = $code{$ARG};
        $data{'code'}{$ARG}{'status'} = 'core-sub'
    } keys %code;
}

END {
    $code{'base.handler.end_code'}->();
}

# ______________________________________________________________________________
#\\7OP7PSBMJWP46GUSI7XUBJOE6XH2SCD6XS63HYIU7BUTQR2VOJ4R6TVVZUW2IDCFQCGP7PWXMUNBS
# \\ 74CNXFDRLSZFLCT6JRT7HMRGC4BVK75WRUVYU3GOEP7BKSX7235Y \\// C25519-BASE-32 //
#  \\// LDQLZIHPDUYCZLZOG5L6RKSWBYZX7FVWNENL4JCXHHZ5LV4CICY \\ CODE SIGNATURE \\
#   ````````````````````````````````````````````````````````````````````````````
