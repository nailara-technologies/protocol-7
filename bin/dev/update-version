#!/usr/bin/perl

use strict;
use v5.30.0;
use English;
use warnings;
use File::Spec;
use Time::HiRes;
use Git::Wrapper;
use Cwd 'abs_path';
use Math::BigFloat;
use FindBin '$RealBin';
use Digest::Elf qw| elf |;
use Crypt::Misc qw| encode_b32r |;

our $amend = 0;
my $reset = 0;
my $down  = 0;

if (@ARGV) {
    map { $amend = 1 if $_ eq 'amend' } @ARGV;
    map { $down  = 1 if $_ eq 'down'; } @ARGV;
    map {
        if ( $_ eq 'reset' ) { $down = 0; $reset = 1 }
    } @ARGV;
}

my $u = File::Spec->updir;
my $root_path
    = abs_path( File::Spec->rel2abs( File::Spec->catdir( $RealBin, $u, $u ) ) );
my $cfg_path = File::Spec->catdir( $root_path, 'cfg' );
our $v_file    = File::Spec->catfile( $cfg_path, 'protocol-7.source-version' );
our $rl_v_file = File::Spec->catfile( $cfg_path, 'protocol-7.release-version' );
my $readme_md    = File::Spec->catfile( $root_path, 'README.md' );
my $old_version  = get_old_version();
my $git          = Git::Wrapper->new($root_path);
my $commit_count = $git->log - 1;

$commit_count-- if $amend;

my $version_base = gen_ver_string( $commit_count + 1 - $reset );
my $minor        = $down ? -1 : 1;
my $new_minor    = 0;

if ( $old_version =~ m|^(.+)\.(\d+)$| ) {
    my $old_base  = $1;
    my $old_minor = $2;

    $minor = 0 if $minor < 0 and !$old_minor;
    map { $_ =~ s|^[^-]+-|| } ( $old_base, $version_base );
    $new_minor = $old_minor + $minor if $amend;
}

$new_minor = 0 if $reset;
$new_minor = 1 if $amend and !$new_minor;

my $version_string = gen_ver_string( $commit_count + 1 - $reset, $new_minor );

## no a longer release version [ modified ]
$git->add($rl_v_file)
    if !$amend
    and $version_string ne $old_version
    and -f $rl_v_file
    and $git->ls_files('cfg/protocol-7.release-version');

## ./cfg/protocol-7.source-version ##
open( my $ver_fh, '>' . $v_file ) or die " -> $v_file : $!\n";
print {$ver_fh} "$version_string\n";
close($ver_fh);
$git->add($v_file);

## ./README.md ##
{
    local $/ = undef;
    my $B32_ntime_re = qr|[A-Z2-7]{10}|o;
    open( my $md_fh, '<' . $readme_md ) or die "$readme_md : $!\n";
    my $md_copy = my $md_str = <$md_fh>;
    close($md_fh);
    if ( $md_str =~ s|\Q$old_version\E|$version_string|g ) {
        $md_str =~ s|: $B32_ntime_re |: $version_string |g;    ## B32 version ##
        $md_str =~ s|: \d\d\.\d\d\d\d\-\d\d\d\d\.\d+ |: $version_string |g;
    }
    if ( $md_str ne $md_copy ) {
        open( $md_fh, '>' . $readme_md ) or die " -> $readme_md : $!\n";
        print {$md_fh} $md_str;
        close($md_fh);
        $git->add($readme_md);
    }
}

print ":\n: updated version : $version_string\n:\n";

### SUBROUTINES ################################################################

sub gen_ver_string {
    my $count_str = shift;
    my $new_minor = shift // '';
    $count_str .= '.' . $new_minor if length($new_minor);
    return join( '-', ntime_B32(), $count_str );
}

sub get_old_version {
    local $/ = undef;
    return '' if !-f $v_file;
    open( my $fh, $v_file ) or die "$v_file : $!\n";
    ( my $old_version = <$fh> ) =~ s|\n+.+$||sg;
    close($fh);
    return $old_version;
}

################################################################################

sub time_float {
    my $f = shift // 2;
    return sprintf( "%.${f}f", Time::HiRes::time );
}

sub ntime {    # [ network time : secs from 2002-06-05 * 4200 ]
    my $param        = shift // 0;
    my $want_harmony = shift // 1;
    my $ntime_start  = 1023228000;

    my $retries_left    = 24;    ## <-- configure [ retries-max ]
    my $collision_delay = 0;
    my $last_time       = 0;
    my $unix_precision;
    my $ntime_precision;

    my $ntime_retry_count = 0;

    my ( $unix_time, $precision ) = ( undef, 0 );
    if ( length($param) >= 9 ) {    # < unix time + inherited precision >
        $unix_time       = $param;
        $unix_precision  = length($1) if $unix_time =~ m{\.(\d+)$};
        $ntime_precision = $unix_precision - 2;
        $ntime_precision = 0 if $ntime_precision < 0;

    } else {
        $ntime_precision = $param;
        $ntime_precision = 8 if $ntime_precision > 8;
        $unix_precision  = $ntime_precision + 2;
        $unix_precision  = 11 if $unix_precision > 11;
    }
    my $zulum_len = $unix_precision - 1;
    $collision_delay = join( '', '0.', '0' x $zulum_len, '7' );

RETRY_BASE_NTIME:
    $last_time = $unix_time if defined $unix_time;
    $unix_time = time_float($unix_precision);

    if ( $unix_time == $last_time ) {    ## same input \ collision ##
        Time::HiRes::sleep($collision_delay);
        goto RETRY_BASE_NTIME;
    }

    my $ntime = sprintf( "%.0${ntime_precision}f",
        ( ( $unix_time - $ntime_start ) * 4200 ) );

    if (    $want_harmony == 1
        and length($param) < 9
        and assert_harmony( $unix_time, 0 ) == 0
        and $retries_left-- ) {

        ++$ntime_retry_count
            and goto RETRY_BASE_NTIME;
    }

    say '< exceeded >' if !$retries_left;

    return $ntime;
}

################################################################################

sub ntime_B32 {
    my $param        = shift // 0;    # <-- precision or utime
    my $want_harmony = shift // 1;
    my $retries_left = 5;             ## <-- configure [ retries-max ]
    my $last_ntime   = 0;
    my $ntime_precision;
    my $ntime_value;

    my $ntime_B32_retry_count = 0;

RETRY_BASE_NTIME_B32:                 ## only choose harmonic values ##

    $last_ntime = $ntime_value
        if $want_harmony
        and defined $ntime_value
        and $ntime_value != $last_ntime;

    ####
    $ntime_value = ntime( $param, $want_harmony );
    ####

    if ($want_harmony) {
        $ntime_precision = 0;
        $ntime_precision = length($1) if $ntime_value =~ m|\.(\d+)$|;
        my $zulum_len       = $ntime_precision + 1;
        my $collision_delay = join( '', '0.', '0' x $zulum_len, '113' );
        if ( $last_ntime == $ntime_value ) {    ## same input \ collision ##
            Time::HiRes::sleep($collision_delay);
            goto RETRY_BASE_NTIME_B32;
        }
    }

    my @nt = split( m|\.|, $ntime_value );
    $nt[1] = '7' . $nt[1] if scalar @nt == 2;    # <-- 7 catches prefixed 0

    my $encoded_ntime = encode_b32r( pack( 'w*', @nt ) );

    ++$ntime_B32_retry_count
        and goto RETRY_BASE_NTIME_B32
        if $want_harmony == 1
        and length($param) < 9                   # <-- precision
        and assert_harmony($encoded_ntime) == 0
        and $retries_left--;

    return $encoded_ntime;
}

################################################################################

sub assert_harmony {
    my $input_string = shift // '';
    my $check_elf    = shift // 1;
    return 1 if !length($input_string);          ## is harmonic ##

    Math::BigFloat->round_mode('trunc');

    my $calc_str;
    ## check as mumber ##
    if ( $input_string =~ m|^\d+(\.\d+)?$| ) {
        ( my $input_num = $input_string ) =~ s|\.||;

        my $accuracy = 11;

        ( $calc_str
                = Math::BigFloat->new($input_num)
                ->bdiv( 13, $accuracy + length($input_num) ) ) =~ s|\.||;

        my $seperator_str = ' : ';

        if ( index( $calc_str, '230769' ) >= 0 ) {    ## not harmonic.., ##

            my $min_len = $accuracy + 5;
            my $num_len = length($input_num);
            my $z_len   = abs( $min_len - $num_len );

            ### ..340769.., [E] ##
        }

        return 1 if $check_elf == 0;

        ## check as string ##
        my $elf_checksum = elf($input_string);
        $calc_str = Math::BigFloat->new($elf_checksum)
            ->bdiv( 13, 13 + length($elf_checksum) );
        return 0 if index( $calc_str, '230769' ) >= 0;
        ##
        return 1;   ## assertion complete : harmony detected ## [ no 230769.., ]
    }
}

################################################################################

# ______________________________________________________________________________
#\\YYYMPBNRRR5RM3WZI2T7BHB62R35ZRC4TW2H2EBAVFRIX5O2YH4IFDYCLKLO7O6LELLS3CEGCEOAC
# \\ ZEGVAJ36ROHFXLHUFEWH7MWZUEIJ4PAXOFL4YFVMJ3ZKVFFXWBWH \\// C25519-BASE-32 //
#  \\// AZTNOFUWC544EMZVZ3HONWVAHKBW4I7C6SZWICKZDHS3V4UVYBA \\ CODE SIGNATURE \\
#   ````````````````````````````````````````````````````````````````````````````
