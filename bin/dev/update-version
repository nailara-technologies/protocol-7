#!/usr/bin/perl

use strict;
use v5.30.0;
use English;
use warnings;
use File::Spec;
use Time::HiRes;
use Git::Wrapper;
use Cwd 'abs_path';
use Math::BigFloat;
use FindBin '$RealBin';
use Digest::Elf qw| elf |;
use Crypt::Misc qw| encode_b32r |;

my $readme_file_path = 'readme/md/README.md';

our $amend = 0;
my $reset = 0;
my $down  = 0;

if (@ARGV) {
    map { $amend = 1 if $_ eq 'amend' } @ARGV;
    map { $down  = 1 if $_ eq 'down'; } @ARGV;
    map {
        if ( $_ eq 'reset' ) { $down = 0; $reset = 1 }
    } @ARGV;
}

my $u = File::Spec->updir;
my $root_path
    = abs_path( File::Spec->rel2abs( File::Spec->catdir( $RealBin, $u, $u ) ) );
my $cfg_path = File::Spec->catdir( $root_path, 'cfg' );
our $v_file    = File::Spec->catfile( $cfg_path, 'protocol-7.source-version' );
our $rl_v_file = File::Spec->catfile( $cfg_path, 'protocol-7.release-version' );
my $readme_md    = File::Spec->catfile( $root_path, $readme_file_path );
my $old_version  = get_old_version();
my $git          = Git::Wrapper->new($root_path);
my $commit_count = $git->log - 1;

$commit_count-- if $amend;

my $version_base = gen_ver_string( $commit_count + 1 - $reset );
my $minor        = $down ? -1 : 1;
my $new_minor    = 0;

if ( $old_version =~ m|^(.+)\.(\d+)$| ) {
    my $old_base  = $1;
    my $old_minor = $2;

    $minor = 0 if $minor < 0 and !$old_minor;
    map { $_ =~ s|^[^-]+-|| } ( $old_base, $version_base );
    $new_minor = $old_minor + $minor if $amend;
}

$new_minor = 0 if $reset;
$new_minor = 1 if $amend and !$new_minor;

my $version_string = gen_ver_string( $commit_count + 1 - $reset, $new_minor );

## no a longer release version [ modified ]
$git->add($rl_v_file)
    if !$amend
    and $version_string ne $old_version
    and -f $rl_v_file
    and $git->ls_files('cfg/protocol-7.release-version');

## ./cfg/protocol-7.source-version ##
open( my $ver_fh, '>' . $v_file ) or die " -> $v_file : $!\n";
say {$ver_fh} $version_string;
close($ver_fh);
$git->add($v_file);

## ./README.md ##
{
    local $/ = undef;
    my $B32_re = qr|[A-Z2-7]{10}|o;
    open( my $md_fh, '<' . $readme_md ) or die "$readme_md : $!\n";
    my $md_copy = my $md_str = <$md_fh>;
    close($md_fh);

    $md_str =~ s{: ($B32_re|\d\d\.\d{4})\-\d{4,}\.\d+ }{: $version_string }g
        if $md_str !~ s|\Q$old_version\E|$version_string|g;

    if ( $md_str ne $md_copy ) {
        open( $md_fh, '>' . $readme_md ) or die " -> $readme_md : $!\n";
        print {$md_fh} $md_str;
        close($md_fh);
        $git->add($readme_md);
    }
}

say ":\n:: source version :: $version_string\n:";

### SUBROUTINES ################################################################

sub gen_ver_string {
    my $version_str;
    my $count_str = shift;
    my $new_minor = shift // '';
    $count_str .= '.' . $new_minor if length($new_minor);
RECALC_VERSION:
    $version_str = '';
    $version_str = join( '-', ntime_B32(), $count_str );
    Time::HiRes::sleep(0.013) and goto RECALC_VERSION
        if assert_harmony($version_str);

    return $version_str;
}

sub get_old_version {
    local $/ = undef;
    return '' if !-f $v_file;
    open( my $fh, $v_file ) or die "$v_file : $!\n";
    ( my $old_version = <$fh> ) =~ s|\n+.+$||sg;
    close($fh);
    return $old_version;
}

################################################################################

sub time_float {
    my $f = shift // 2;
    return sprintf( "%.${f}f", Time::HiRes::time );
}

sub ntime {    # [ network time : secs from 2002-06-05 * 4200 ]
    my $param       = shift // 0;
    my $ntime_start = 1023228000;

    my $retries_left    = 24;    ## <-- configure [ retries-max ]
    my $collision_delay = 0;
    my $last_time       = 0;
    my $unix_precision;
    my $ntime_precision;

    my ( $unix_time, $precision ) = ( undef, $param );
    $ntime_precision = $param;
    $unix_precision  = $ntime_precision + 2;

    $unix_time = time_float($unix_precision);

    my $ntime = sprintf( "%.0${ntime_precision}f",
        ( ( $unix_time - $ntime_start ) * 4200 ) );

    return $ntime;
}

################################################################################

sub ntime_B32 {
    my $precision = shift // 0;    # <-- precision or utime
    my $ntime_value;
    my $last_ntime = 0;

RETRY_BASE_NTIME_B32:              ## only choose harmonic values ##

    ####
    $ntime_value = ntime($precision);
    ####

    my $zulum_len = $precision + 1;

    my @nt = split( m|\.|, $ntime_value );
    $nt[1] = '7' . $nt[1] if scalar @nt == 2;    # <-- 7 catches prefixed 0

    my $encoded_ntime = encode_b32r( pack( 'w*', @nt ) );

    Time::HiRes::sleep(0.013) and goto RETRY_BASE_NTIME_B32
        if assert_harmony($encoded_ntime) == 0;

    return $encoded_ntime;
}

################################################################################

sub assert_harmony {
    my $input_string = shift // '';
    my $check_elf    = shift // 1;

    Math::BigFloat->round_mode('trunc');

    my $calc_str;
    ## check as mumber ##

    my $accuracy = 13;

    ## check as string ##
    my $elf_checksum = elf($input_string);
    $calc_str = Math::BigFloat->new($elf_checksum)
        ->bdiv( 13, 13 + length($elf_checksum) );

    my $check_str = scalar $calc_str;
    return 0 if index( $check_str, '230769' ) >= 0;
    ##
    return 1;    ## assertion complete : harmony detected ## [ no 230769.., ]
}

################################################################################

# ______________________________________________________________________________
#\\DT2ZDRK33EH6WGWDCTVY7TWF4C5D6MYVIYVDEQ2ARWBVZIRZEJIZVGLGYK4QHWTGIMETF4KBXMNLY
# \\ 2FGLNNXOOGELOTZ3V2BWV5U4FVS26BASO35LTTW7C4LOTYRR4IRF \\// C25519-BASE-32 //
#  \\// 52TQUOI74PMNOJMK3SBKXD7FAK6ITIVL6ZK6EDGC2QXFWHWYWDA \\ CODE SIGNATURE \\
#   ````````````````````````````````````````````````````````````````````````````
