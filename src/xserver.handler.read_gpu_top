# >:]

# name  = xserver.handler.read_gpu_top
# descr = reads output from 'intel_gpu_top' process and collects load statistics

my $watcher  = shift->w;
my $read_fh  = $watcher->fd;
my $gtop_pid = $watcher->data->{'pid'};

my @stat_secs = ( 5, 15, 30 );

<xserver.gpu_top.stats> //= {};
<xserver.gpu_top.stats.secs> = [ 1, sort { $a <=> $b } @stat_secs ];
<xserver.gpu_top.stats.sample>       //= {};
<xserver.gpu_top.stats.load_average> //= {};
<xserver.gpu_top.output_buffer>      //= '';

my $read_bytes = <[base.s_read]>->(
    $read_fh, \$data{'xserver'}{'gpu_top.output_buffer'},
    4096,     length(<xserver.gpu_top.output_buffer>)
);
if ( not defined $read_bytes or $read_bytes == 0 ) {  # ( filehandle exception )
    $watcher->cancel;
    close($read_fh);
    <[base.log]>->(
        1, "intel_gpu_top [PID:$gtop_pid] output filehandle closed."
    );
    <[base.log]>->( 0, "intel_gpu_top terminated. deleting stats.." );
    $watcher->cancel if $watcher->is_active;
    delete <xserver.gpu_top.stats>;
    return undef;
}

my $load_ref = <xserver.gpu_top.stats.load_average>;

my ($max_samples) = reverse sort { $a <=> $b } @stat_secs;

while ( <xserver.gpu_top.output_buffer> =~ s|^([^\n]*)\n||s ) {
    my $output_line = $1;
    next if $output_line =~ /^\#/;
    my ( $time, $load );
    if ( $output_line =~ /^(\d+(\.\d+)?)\s+(\d+(\.\d+)?)\s+/ ) {
        ( $time, $load ) = ( $1, $3 );
    } else {
        substr( $output_line, 253, length($output_line) - 253, '...' )
            if length($output_line) > 253;
        <[base.log]>->( 0, "[ERROR] < intel_gpu_top > $output_line" );
        $watcher->cancel if $watcher->is_active;
        delete <xserver.gpu_top.stats>;
        return undef;
    }
    my $stat_ref   = <xserver.gpu_top.stats>;
    my $sample_ref = <xserver.gpu_top.stats.sample>;
    $load_ref->{1} = $sample_ref->{$time} = $load;

    while ( keys( %{$sample_ref} ) > $max_samples ) {
        ( my $del_tstamp ) = sort { $a <=> $b } keys( %{$sample_ref} );
        delete $sample_ref->{$del_tstamp};
    }

    # LLL: adjust for timecode drift...
    my $added;
    my $sec_count = keys %{$load_ref};
    foreach my $count (@stat_secs) {
        $added = 0;
        foreach
            my $t_code ( reverse sort { $a <=> $b } keys( %{$sample_ref} ) ) {
            last if ++$added == $count;
            $load_ref->{$count} //= 0;
            $load_ref->{$count} += $sample_ref->{$t_code};
        }
        if ( $added < $count ) {
            delete $load_ref->{$count};
            next;
        }
        $load_ref->{$count} = sprintf( "%.4f", $load_ref->{$count} / $added );
    }
    my $sec     = '';
    my $new_sec = $sec_count < keys %{$load_ref} ? 1 : 0;
    my $avg_str = join(
        ' .. ',
        map {
            $sec = $new_sec ? " <- ${added}s" : '';
            defined $load_ref->{$_}
                ? sprintf( "%5s", sprintf( "%.2f", $load_ref->{$_} ) )
                : '-- --'
            }
            reverse sort { $a <=> $b } @stat_secs
    );
    my $freq = '';
    my $llvl = <xserver.gpu_top.stat_log_level> //= 3;
    <[base.log]>->(
        $llvl, sprintf "< GPU >  %3s  <  .. $avg_str ..  >$sec", "$load\%"
    );

    # handle configured GPU load alerts
    my $min_wait    = 20;    # allow for startup action to settle..
    my $alert_pause = 30;    # allow restarts to complete before re-triggering..
    if (    defined <xserver.gpu_load.alert>
        and ref(<xserver.gpu_load.alert>) eq 'HASH'
        and keys %{<xserver.gpu_load.alert>} ) {
        <xserver.gpu_load.last_alert>
            //= <[base.time]>->(2) - $alert_pause + $min_wait;
        foreach
            my $al_secs ( sort { $a <=> $b } keys %{<xserver.gpu_load.alert>} )
        {
            next
                if <[base.time]>->(2) - <xserver.gpu_load.last_alert>
                < ( $alert_pause + $al_secs );

            my $alert_threshold = <xserver.gpu_load.alert>->{$al_secs};

            if ( defined $load_ref->{$al_secs}
                and $load_ref->{$al_secs} >= $alert_threshold ) {
                <[base.log]>->(
                    0,
                    sprintf( "<!> GPU load alert <!> ( ${al_secs}s at %.2f",
                        $load_ref->{$al_secs} )
                        . '% )'
                );
                if ( defined <xserver.gpu_load.send_alerts> ) {
                    map {
                        <[base.proto.nailara.command.send.local]>->(
                            {   'command'   => "core.$_.gpu_load_alert",
                                'call_args' => {
                                    'args' => join( ' ',
                                        $al_secs, $load_ref->{$al_secs} )
                                }
                            }
                        );
                    } split( / +/, <xserver.gpu_load.send_alerts> );
                }
                <xserver.gpu_load.last_alert> = <[base.time]>->(2);
            }
        }
    }
}

if ( defined <xserver.gpu_top.write_to_disk.path> ) {
    my $stats_file    = <xserver.gpu_top.write_to_disk.path>;
    my $stats_content = join( "\n",
        map { join( ':', $_, <xserver.gpu_top.stats.load_average>->{$_} ) }
        sort { $a <=> $b } keys %{<xserver.gpu_top.stats.load_average>} );
    eval { <[file.put]>->( "$stats_file.NEW", "$stats_content\n" ) };
    rename( "$stats_file.NEW", $stats_file ) or die "rename: $!";
}

# ______________________________________________________________________________
#\\XAF6UI2QUYPLTHGO7IK5UCH4D4XNFG3KU2RSGSF2OIC2J5AGAD7HWKY4UIUMLFJWQCC3RECEVE25S
# \\ R7UX4PABJTEIN7XJIERVIPBZBZDA2KPZ4CMKI2Z4SDY7YEWVJGVD \\// C25519-BASE-32 //
#  \\// LFMIUZODBMCHZHFBNFAUTS7FDGOO7OYV3OA4V5PI34RWUN64SDQ \\ CODE SIGNATURE \\
#   ````````````````````````````````````````````````````````````````````````````
