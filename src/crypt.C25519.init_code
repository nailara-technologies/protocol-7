# >:]

# name = crypt.C25519.init_code

use Crypt::Ed25519;
use Crypt::Curve25519;
use File::Path qw(make_path);
use MIME::Base64 qw( encode_base64url decode_base64url );

my $usr = <system.privs.user>;
$usr //= getpwuid($>);
my ( undef, undef, $uid, $gid, undef, undef, undef, $homedir ) = getpwnam($usr);
die "failed to obtain home directory for user '$usr'"
    if ( not defined $homedir or !length($homedir) )
    and not defined <crypt.C25519.key_dir>;

my $key_name = 'default';                                           # <- cfg (?)
my $key_dir = <crypt.C25519.key_dir> //= "$homedir/.nailara/keys";
my $key_basepath = <crypt.C25519.key_basepath>
    //= "$key_dir/$key_name.C25519_b64u";

if ( !-d $key_dir ) {
    <[base.log]>->( 1, "creating key directory '$key_dir' .." );
    make_path( $key_dir, { mode => 0700, uid => $uid, group => $gid } );
}

if ( !-f $key_basepath and !-f "$key_basepath.pub" ) {
    <[base.log]>->( 0, "generating default C25519 key pair ..." );
    <[crypt.C25519.gen_keys]>->($key_name);
    my %key_b64u = ( 'priv' => '', 'pub' => '' );
    foreach my $type ( 'private', 'public' ) {
        my $file_name = $type eq 'public' ? "$key_basepath.pub" : $key_basepath;
        open( my $k_fh, '>>', "$file_name.$$" ) or die "$file_name.$$: $!";
        if ( $type eq 'public' ) {
            chmod( 0644, "$file_name.$$" ) or die "chmod: $!";
        } else {
            chmod( 0600, "$file_name.$$" ) or die "chmod: $!";
        }
        $key_b64u{$type} = encode_base64url( $key{'C25519'}{$key_name}{$type} );
        printf( {$k_fh} "%s\n", $key_b64u{$type} );
        close($k_fh);
        rename( "$file_name.$$", $file_name ) or die "$file_name: $!";
        <[base.log]>->( 1, ": $file_name" );
    }

    if ( defined <crypt.C25519.root_key_url> ) {
        my $root_key_name;
        my %root_key = ( 'priv' => '', 'pub' => '' );
        if ( <crypt.C25519.root_key_url>
            =~ m{^https?://.+/C25519_b64u(\.(.+))?$} ) {
            $root_key_name = $2 // '';
            require LWP::UserAgent;   # use download agent later, needs blocking
            my $ua = LWP::UserAgent->new();
            $ua->get( <crypt.C25519.root_key_url>,
                ':content_cb' => sub { chomp( $root_key{'priv'} = shift ) } );
            $ua->get( <crypt.C25519.root_key_url> . '.pub',
                ':content_cb' => sub { chomp( $root_key{'pub'} = shift ) } );
        }
        my $rkst = length($root_key_name) ? " '$root_key_name'" : '';
        <[base.log]>->( 0, ": signing C25519 key pair with$rkst root key ..." );
        my $sig_file_path = <crypt.C25519.key_basepath> . '.sig';
        $sig_file_path .= ".$root_key_name" if length($root_key_name);
        <[file.put]>->(
            $sig_file_path,
            encode_base64url(
                Crypt::Ed25519::sign(
                    $key_b64u{'pub'} . "\n",
                    decode_base64url( $root_key{'pub'} ),
                    decode_base64url( $root_key{'priv'} )
                    )
                    . "\n"
            )
            )
            if length( $root_key{'pub'} ) == 43
            and length( $root_key{'priv'} ) == 86;
        my $fail = 0;
        if ( -f $sig_file_path ) {
            <[base.log]>->( 1, ": : $sig_file_path" );
            (   my $root_pubkey_path = join( '.',
                    <crypt.C25519.key_basepath>, 'rkp', $root_key_name )
            ) =~ s|\.$||;
            <[file.put]>->( $root_pubkey_path, $root_key{'pub'} . "\n" );
            <[base.log]>->( 1, ": : $root_pubkey_path" );
        } else {

            # XXX: log reason ...
            <[base.log]>->(
                0, "<!> failed to sign public host key ( root key? )"
            );
        }
    } else {
        <[base.log]>->( 1, ": no root key path defined, skipped key signing!" );
    }
}

0;
