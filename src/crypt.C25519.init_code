# >:]

# name = crypt.C25519.init_code

<crypt.C25519.initialized> //= 0;

<[base.perlmod.load]>->( 'File::Path', qw/make_path/ );
<[base.perlmod.load]>->(qw( MIME::Base64 encode_base64url decode_base64url ));

<[base.perlmod.autoload]>->('Crypt::Ed25519');
<[base.perlmod.autoload]>->('Crypt::Curve25519');

<[base.perlmod.load]>->( 'Crypt::PRNG::Fortuna', qw/random_string_from/ );

my $home_dir = <[base.get_homedir]>->($>);

my $usr = <crypt.C25519.key_uid_user> //= getpwuid($>);

my ( undef, undef, $uid, $gid, undef, undef, undef, undef ) = getpwnam($usr);

if ( not defined $home_dir or !-r $home_dir ) {
    if ( !<base.parser.config.reloading> ) {
        <[base.log]>->(
            0, "<!> no homedir access for user '$usr', aborting init!"
        );
    } else {
        <[base.log]>->( 1, ": skipped key reload.. [homedir]" );
    }
    return 0;    # still valid state!
}

my $key_name = 'default';                                           # <- cfg (?)
my $key_dir  = <crypt.C25519.key_dir> //= "$home_dir/.n/user-keys/";
my $key_basepath = <crypt.C25519.key_basepath>
    //= "$key_dir/$key_name.C25519_b64u";

# chk_key_dir {

if ( -w "$key_dir/.." or "$key_dir/../.." ) {
    if ( !-d $key_dir ) {
        <[base.log]>->( 1, "creating key directory '$key_dir' .." );
        eval {
            make_path( $key_dir, { mode => 0700, uid => $uid, group => $gid } );
        };
        warn $@ if $@;
    }
} elsif ( !-r $key_dir or !-d $key_dir ) {
    my $perms     = -e $key_dir ? '' : ' (permissions)';
    my $log_level = <crypt.C25519.initialized> // 0;
    $log_level++ if $log_level;
    <[base.log]>->( $log_level, "no key dir$perms ['$key_dir']!" );
    return 0;
}

# }

# create_keys {

if ( !-f $key_basepath and !-f "$key_basepath.pub" and -r $key_basepath ) {
    <[base.log]>->( 0, "generating default C25519 key pair for '$usr' ..." );
    my %key_b64u = ( 'priv' => '', 'pub' => '' );
    if ( <[crypt.C25519.gen_keys]>->($key_name) ) {
        foreach my $type ( 'priv', 'pub' ) {
            my $file_name
                = $type eq 'pub' ? "$key_basepath.pub" : $key_basepath;
            open( my $k_fh, '>>', "$file_name.$$" ) or die "$file_name.$$: $!";
            if ( $type eq 'pub' ) {
                chmod( 0644, "$file_name.$$" ) or die "chmod: $!";
            } else {
                chmod( 0600, "$file_name.$$" ) or die "chmod: $!";
            }
            $key_b64u{$type}
                = encode_base64url( $KEYS{'C25519'}{$key_name}{$type} );
            printf( {$k_fh} "%s\n", $key_b64u{$type} );
            close($k_fh);
            rename( "$file_name.$$", $file_name ) or die "$file_name: $!";
            chown( $uid, $gid, $file_name ) or warn "$file_name: $!";
            <[base.log]>->( 1, ": $file_name" );
        }
    }

    # }

    # sign_keys {

    if ( defined <crypt.C25519.root_key_url> ) {
        my $root_key_name;
        my %root_key = ( 'priv' => '', 'pub' => '' );
        if ( <crypt.C25519.root_key_url>
            =~ m{^https?://.+/C25519_b64u(\.(.+))?$} ) {
            $root_key_name = $2 // '';
            require LWP::UserAgent;   # use download agent later, needs blocking
            my $ua = LWP::UserAgent->new();
            $ua->get( <crypt.C25519.root_key_url>,
                ':content_cb' => sub { chomp( $root_key{'priv'} = shift ) } );
            $ua->get( <crypt.C25519.root_key_url> . '.pub',
                ':content_cb' => sub { chomp( $root_key{'pub'} = shift ) } );
        }
        my $rkst = length($root_key_name) ? " '$root_key_name'" : '';

        my $rk_priv_len = length( $root_key{'priv'} );
        if ( length( $root_key{'pub'} ) != 43 or $rk_priv_len != 86 ) {
            <[base.log]>->(
                0, "<!> failed to read root key <<!>> key signing aborted <!>"
            );

            # LLL: log reason ...
            goto skip_sign;
        }
        <[base.log]>->( 0, ": signing C25519 key pair with$rkst root key ..." );
        my $sig_file_path = <crypt.C25519.key_basepath> . '.sig';
        $sig_file_path .= ".$root_key_name" if length($root_key_name);
        <[file.put]>->(
            $sig_file_path,
            encode_base64url(
                Crypt::Ed25519::sign(
                    $key_b64u{'pub'} . "\n",
                    decode_base64url( $root_key{'pub'} ),
                    decode_base64url( $root_key{'priv'} )
                    )
                    . "\n"
            )
        );
        if ( -f $sig_file_path ) {
            <[base.log]>->( 1, ": : $sig_file_path" );
            (   my $root_pubkey_path = join( '.',
                    <crypt.C25519.key_basepath>, 'rkp', $root_key_name )
            ) =~ s|\.$||;
            <[file.put]>->( $root_pubkey_path, $root_key{'pub'} . "\n" );
            <[base.log]>->( 1, ": : $root_pubkey_path" );
        } else {
            <[base.log]>->( 0, "<!> failed to sign public host key <!>" );
        }
    skip_sign:
        substr( $root_key{'priv'}, 0, $rk_priv_len,
            <[base.rnd_chars]>->($rk_priv_len) );
        map { undef $root_key{$_} } ( 'priv', 'pub' );
    } else {
        <[base.log]>->( 1, ": no root key path defined, skipped key signing!" );
    }
} elsif ( not defined $KEYS{'C25519'}{$key_name} ) {
    my $pubkey_file = "$key_basepath.pub";
    if ( -r $key_basepath and -r $pubkey_file ) {
        <[base.log]>->( 1, ": loading ['$key_name'] key pair.. [$home_dir/]" );
        $KEYS{'C25519'}{$key_name}{'priv'}
            = decode_base64url( ${ <[file.slurp]>->($key_basepath) } );
        $KEYS{'C25519'}{$key_name}{'pub'}
            = decode_base64url( ${ <[file.slurp]>->($pubkey_file) } );
    } else {
        <[base.log]>->( 1, "failed to load '$key_name' key pair ..." );
    }
}

while ( glob $key_basepath . '.{rkp,sig}.*' ) {
    if (/([^\/]+\.(rkp|sig)\.(.+))$/) {
        my ( $fname, $type, $rkname ) = ( $1, $2, $3 );
        <[base.log]>->( 1, ": loading '$fname'" );
        $type = 'pub' if $type eq 'rkp';    # <- [root-key-pub]
        chomp( $KEYS{'C25519'}{$key_name}{'root'}{$rkname}{$type}
                = ${ <[file.slurp]>->($_) } );
    }
}

<crypt.C25519.initialized>++;

0;
