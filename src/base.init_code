# >:]

# name  = base.init_code
# descr = initialize the base module

use Safe;
use Module::Load;
use Time::Seconds;

<[base.perlmod.autoload]>->('Event');
<[base.perlmod.autoload]>->('IO::AIO');
<[base.perlmod.load]>->( 'Time::Local',          'timegm_nocheck' );
<[base.perlmod.load]>->( 'POSIX::1003::Time',    'strftime' );
<[base.perlmod.load]>->( 'POSIX::1003::Limit',   ':rlimit' );
<[base.perlmod.load]>->( 'Crypt::PRNG::Fortuna', 'random_string_from' );
<[base.perlmod.load]>->(
    'POSIX::1003::Proc', qw/ WNOHANG waitpid setsid getcwd /
);

# init some vars

<agent.shutdown> //= 0;

$data{'debug'} //= {};
## reducing debug ( verbosity >= 2 ) log output ###
<debug.sig_int_dump>   = 0;  # dump %data state on SIGINT in log level 2
<debug.skip_log_msg>   = 1;  # skip log.msg commands in log level 2 debug output
<debug.skip_root_ping> = 1;  # skip root agent status pings (and responses)
##
$data{'system'}{'process_start'} = {
    'time'  => <[base.time]>->(5),
    'pid'   => $$,
    'pname' => $0,
    'uid'   => $<,
    'euid'  => $>,
    'gid'   => $(,
    'egid'  => $)
    }
    if not exists $data{'system'}{'process_start'};

# maximizing open files limit

my ( $of_cur, $of_max, $rl_success ) = getrlimit('RLIMIT_NOFILE');
if ( !$rl_success ) {
    warn "getrlimit('RLIMIT_NOFILE') failed [$!]";
} elsif ( $of_cur != $of_max ) {
    <[base.log]>->( 2, ": open files limit increased [$of_cur->$of_max]" );
    setrlimit( 'RLIMIT_NOFILE', $of_max, $of_max )
        or warn "setrlimit <$of_max> failed [$!]";
}
( $data{'system'}{'limits'}{'ofile'} ) = getrlimit('RLIMIT_NOFILE')
    if $rl_success;

$data{'system'}{'host'} = {
    'os'       => { 'name' => $^O },
    'hostname' => hostname,
    'timezone' => <[base.timezone]>
};

# LLL: todo: + uname -r, uname -m (?)

# flush / init regex cache
$data{'regex'} = { 'base' => <[base.regex]> };

# init / reset lists
$data{'list'} //= {};

<list.users> = {
    'var'     => 'data',
    'key'     => 'user',
    'sub_key' => 'session',
    'mask'    => '<key>:user connected_since session:sessions',
    'align'   => { 'session' => 'center' },
    'filters' => {
        'session'         => 'base.parser.element_count',
        'connected_since' => 'base.parser.timestamp'
    },
    'descr' => 'connected users'
};
<list.sessions> = {
    'var'      => 'data',
    'key'      => 'session',
    'sort_key' => 'num:start_time',
    'mask'     => '<key>:sid proto link mode user start_time:since',
    'align'    => {
        'user'       => 'center-2',
        'link'       => 'center-2',
        'start_time' => 'right'
    },
    'filters' => { 'start_time' => 'base.parser.duration' },
    'descr'   => 'registered / connected sessions'
};
<list.buffers> = {
    'var'   => 'data',
    'key'   => 'buffer',
    'mask'  => '<key>:name data:lines size:bytes max_size',
    'align' => {
        'data'     => 'right-5',
        'size'     => 'center-2',
        'max_size' => 'right-5'
    },
    'filters' => {
        'data'     => 'base.parser.element_count',
        'max_size' => 'base.parser.size_str'
    },
    'descr' => 'available log / data buffers'
};

# 'verify-instance' command not required in core type agents [for now]
if ( exists <system.agent.type> and <system.agent.type> eq 'core' ) {
    <[base.disable_command]>->('verify-instance');
    <agents.virtual> //= {};
    my $key_ref = \$data{'agents'}{'virtual'};
    $data{'base'}{'element'}{$key_ref}{'max_count'} //= 4096;  # LLL: -> config!
    <list.virtual> = {
        'var'   => 'data',
        'key'   => 'agents.virtual',
        'mask'  => '<key>:id name type status session',
        'align' => {
            'name'    => 'left',
            'type'    => 'center-2',
            'status'  => 'center-2',
            'session' => 'center-1'
        },
        'filters' => {
            'status'  => 'base.parser.ondemand_status',
            'session' => 'base.parser.ondemand_session'
        },
        'descr' => 'virtual agent list'
    };
} else {    # remove some commands for non-core type agents
    map { <[base.disable_command]>->($_) } (
        qw/
            exit
            clear
            ntime
            last-sid
            localtime
            is-online
            ondemand-agent
            session-key
            term-all
            time
            /
    );

    <base.help.cmd.source-age.param> = "['date']";  # <- disabling second param!
    <base.help.cmd.source-age.descr> =~ s|\[year\]||;

    if ( <system.agent.name> ne 'media' ) {
        <[base.disable_command]>->(qw/ whoami /);
        <[base.hide_list]>->(qw/ sessions /);
    }

    <[base.hide_list]>->(qw/ users /);
}

map {
    <base.watcher.signal>->{$_}->cancel
        if defined <base.watcher.signal>->{$_};
    my $uc_sig = uc($_);
    delete $SIG{$uc_sig} if defined $SIG{$uc_sig};

    ## initializing signal handlers ##    [ <!> potential SIGCHLD problems <!> ]
    <base.watcher.signal>->{$_} = <[event.add_signal]>
        ->( { 'signal' => $uc_sig, 'handler' => 'base.sig_' . $_ } );
} ( qw-
        int   term  hup
        chld  abrt  trap
        usr1  usr2  -
);

# initialize session list

if ( ref( $data{'session'} ) ne 'HASH' ) { $data{'session'} = {} }

<[base.list.init]>->(
    {   'name'         => 'sessions',
        'key_ref'      => \$data{'session'},
        'max_elements' => $data{'limit'}{'max'}{'sessions'}
    }
);

<[base.parser.access_conf]>;

# command aliases with source agent name prefixes
if (    exists $data{'setup'}
    and exists <setup.aliases> ) {
    if ( defined <setup.aliases.source_agent> ) {
        foreach my $alias_cmd ( split /\s+/, <setup.aliases.source_agent> ) {
            $data{'alias'}{$alias_cmd} = "$alias_cmd SOURCE_AGENT";
        }
    }
    map { $data{'alias'}{$_} = "$_ SOURCE_AGENT SOURCE_SID" }
        split( /\s+/, <setup.aliases.source_agent_sid> )
        if defined <setup.aliases.source_agent_sid>;
}

<base.callback_hooks.async_online> //= []; # <- called after receiving core sid!

# setting up command (argument) filter hooks
<base.filter_hooks.command.ping.send> = 'base.handler.ping_time';
<base.filter_hooks.command.ping.recv> = 'base.handler.ping_time_reply';

return 0;
