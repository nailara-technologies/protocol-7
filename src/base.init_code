# >:]

# name       = base.init_code
# descr      = initialize the base module

use Time::Seconds;
use POSIX::1003::Limit ':rlimit';
use POSIX::1003::Time qw(strftime);
use POSIX::1003::Proc qw(WNOHANG waitpid setsid getcwd);

# init some vars

<agent.shutdown> //= 0;

$data{'debug'} //= {};
## reducing debug ( verbosity >= 2 ) log output ###
<debug.sig_int_dump>   = 0;  # dump %data state on SIGINT in log level 2
<debug.skip_log_msg>   = 1;  # skip log.msg commands in log level 2 debug output
<debug.skip_root_ping> = 1;  # skip root agent status pings (and responses)
##
$data{'system'}{'process_start'} = {
    'time'  => <[base.time]>->(5),
    'pid'   => $$,
    'pname' => $0,
    'uid'   => $<,
    'euid'  => $>,
    'gid'   => $(,
    'egid'  => $)
    }
    if not exists $data{'system'}{'process_start'};

# maximizing open files limit

my ( $of_cur, $of_max, $rl_success ) = getrlimit('RLIMIT_NOFILE');
if ( !$rl_success ) {
    warn "getrlimit('RLIMIT_NOFILE') failed [$!]";
} elsif ( $of_cur != $of_max ) {
    <[base.log]>->( 2, ": open files limit increased [$of_cur->$of_max]" );
    setrlimit( 'RLIMIT_NOFILE', $of_max, $of_max )
        or warn "setrlimit <$of_max> failed [$!]";
}
( $data{'system'}{'limits'}{'ofile'} ) = getrlimit('RLIMIT_NOFILE')
    if $rl_success;

$data{'system'}{'host'} = {
    'os'       => { 'name' => $^O },
    'hostname' => hostname,
    'timezone' => <[base.timezone]>
};

# XXX: todo: + uname -r, uname -m (?)

# flush / init regex cache
$data{'regex'} = { 'base' => <[base.regex]> };

# init / reset lists
$data{'list'} = {
    'users' => {
        'var'     => 'data',
        'key'     => 'user',
        'sub_key' => 'session',
        'mask'    => '<key>:user connected_since session:sessions',
        'align'   => { 'session' => 'center' },
        'filters' => {
            'session'         => 'base.parser.element_count',
            'connected_since' => 'base.parser.timestamp'
        },
        'descr' => 'connected users'
    },
    'sessions' => {
        'var'   => 'data',
        'key'   => 'session',
        'mask'  => '<key>:id proto link mode user start_time:since',
        'align' => {
            'user'       => 'center-2',
            'link'       => 'center-2',
            'start_time' => 'right'
        },
        'filters' => { 'start_time' => 'base.parser.duration' },
        'descr'   => 'registered sessions'
    },
    'buffers' => {
        'var'   => 'data',
        'key'   => 'buffer',
        'mask'  => '<key>:name data:lines size:stored_bytes max_size',
        'align' => {
            'data'     => 'right-5',
            'size'     => 'center-1',
            'max_size' => 'right-5'
        },
        'filters' => {
            'data'     => 'base.parser.element_count',
            'max_size' => 'base.parser.size_str'
        },
        'descr' => 'available buffers'
    }
};

# 'verify_instance' command not required in core type agents (for now)
if ( exists <system.agent.type> and <system.agent.type> eq 'core' ) {
    <[base.disable_command]>->('verify_instance');
    <agents.virtual> //= {};
    my $key_ref = \$data{'agents'}{'virtual'};
    $data{'base'}{'element'}{$key_ref}{'max_count'} //= 4096;  # XXX: -> config!
    <list.virtual> = {
        'var'   => 'data',
        'key'   => 'agents.virtual',
        'mask'  => 'name type <key>:id status session',
        'align' => {
            'name'    => 'left+2',
            'type'    => 'center',
            'status'  => 'center-1',
            'session' => 'center-1'
        },
        'filters' => {
            'status'  => 'base.parser.ondemand_status',
            'session' => 'base.parser.ondemand_session'
        },
        'descr' => 'virtual agent list'
    };
} else {    # remove some commands for non-core type agents
    map { <[base.disable_command]>->($_) } (
        'online', 'session_key', 'slay',      'exit',
        'clear',  'time',        'localtime', 'timezone',
        'ondemand_agent'
    );
    <[base.disable_command]>->('whoami') if <system.agent.name> ne 'media';
}

map {
    <base.watcher.signal>->{$_}->cancel
        if defined <base.watcher.signal>->{$_};
    my $uc_sig = uc($_);
    delete $SIG{$uc_sig} if defined $SIG{$uc_sig};
    ## initializing signal handlers ##    [ <!> potential SIGCHLD problems <!> ]
    <base.watcher.signal>->{$_} = <[event.add_signal]>
        ->( { 'signal' => $uc_sig, 'handler' => 'base.sig_' . $_ } );
} ( 'int', 'term', 'hup', 'usr1', 'usr2', 'abrt', 'chld' );

# initialize session list

if ( ref( $data{'session'} ) ne 'HASH' ) { $data{'session'} = {} }

<[base.list.init]>->(
    {   'name'         => 'sessions',
        'key_ref'      => \$data{'session'},
        'max_elements' => $data{'limit'}{'max'}{'sessions'}
    }
);

<[base.parser.access_conf]>;

# command aliases with source agent name prefixes
if (    exists $data{'setup'}
    and exists <setup.aliases> ) {
    if ( defined <setup.aliases.source_agent> ) {
        foreach my $alias_cmd ( split /\s+/, <setup.aliases.source_agent> ) {
            $data{'alias'}{$alias_cmd} = "$alias_cmd SOURCE_AGENT";
        }
    }
    map { $data{'alias'}{$_} = "$_ SOURCE_AGENT SOURCE_SID" }
        split( /\s+/, <setup.aliases.source_agent_sid> )
        if defined <setup.aliases.source_agent_sid>;
}

# setting up command (argument) filter hooks
<base.filter_hooks.command.ping.send> = 'base.handler.ping_time';
<base.filter_hooks.command.ping.recv> = 'base.handler.ping_time_reply';

return 0;
