# >:]

# name  = root.init_code
# descr = initializes root module

<[base.perlmod.autoload]>->('Proc::ProcessTable');

<system.agent.type> = 'root';

<root.timeout.kill_list>       //= 2;
<root.timeout.verify_instance> //= 13;

<root.agent.notify_online>    //= {};
<root.agent.manually_stopped> //= {};

<root.cfg_data.spawn_config> //= [];

map { <[base.disable_command]>->($_) } qw(
    verify_instance
    switch_user
    get_subname
);

<root.gcc_bin> = '/usr/bin/gcc';
<root.cfg.install_bin_unx> //= 'no';
<root.cfg.unx_bin_path>    //= '/usr/local/bin/unx';
chomp( <root.gcc_bin> = qx(which gcc) ) if !-x <root.gcc_bin>;
if ( !-x <root.gcc_bin> ) {
    <root.gcc_bin> = undef;
    <[base.log]>->( 0, "<!> 'gcc' binary not found <!>" )
        if defined <root.cfg.install_bin_unx>
        and <root.cfg.install_bin_unx> =~ /^(1|yes)$/;
} elsif ( defined <root.cfg.install_bin_unx>
    and <root.cfg.install_bin_unx> =~ /^(1|yes)$/ ) {
    eval {<[root.callback.install_bin_unx]>};
    warn $@ if $@;
}

<root.modprobe_bin> = '/sbin/modprobe';
chomp( <root.modprobe_bin> = qx(which modprobe) ) if !-x <root.modprobe_bin>;
if ( !-x <root.modprobe_bin> ) {
    <root.modprobe_bin> = undef;
    <[base.log]>->( 0, "<!> 'modprobe' binary not found <!>" );
}
<root.rmmod_bin> = '/sbin/rmmod';
chomp( <root.rmmod_bin> = qx(which rmmod) ) if !-x <root.rmmod_bin>;
if ( !-x <root.rmmod_bin> ) {
    <root.rmmod_bin> = undef;
    <[base.log]>->( 0, "<!> 'rmmod' binary not found <!>" );
}

<[root.load_spawn_config]>->(<load.spawn_config>)
    if defined <load.spawn_config>;

<[config.json.import_file]>->('root.spawn_config.json');

map { <[root.init_spawn_config]>->($_) }
    @{ clone(<root.cfg_data.spawn_config>) };

<[base.perlmod.autoload]>->('Data::Dumper');
$Data::Dumper::Sortkeys = 1;

print Dumper(<root.spawn_config.globals>) if <system.verbosity> > 1;

<[event.add_signal]>
    ->( { 'signal' => 'CHLD', 'handler' => 'root.handler.sig_chld' } );

<[root.load_agent_patterns]>;
<[root.init_agent_patterns]>;

delete <list.users>;

<list.agents> = {
    'var'   => 'data',
    'key'   => 'root.agent.instance',
    'descr' => 'agent instances',
    'mask'  => '<key>:instance job_id agent_name:name agent_id status',
    'align' => {
        'agent_id'   => 'right-5',
        'agent_name' => 'left+1',
        'instance'   => 'left+1',
        'job_id'     => 'right-4',
        'status'     => 'center-1'
    }
};

<list.subnames> = {
    'var'   => 'data',
    'key'   => 'root.agent.instance',
    'descr' => 'optional agent subnames',
    'mask'  => '<key>:instance status agent_name:agent subname',
    'align' => {
        'instance'   => 'left+1',
        'status'     => 'center-2',
        'agent_name' => 'right-2',
        'subname'    => 'left+1',
    }
};

<list.manual> = {
    'var'   => 'data',
    'key'   => 'root.agent.manually_stopped',
    'descr' => 'manually stopped agents',
    'mask'  => '<key>:agent_name <key>:stopped_at',
    'align' => {
        'agent_name' => 'left+1',
        'stopped_at' => 'left'
    },
    'filters' => { 'stopped_at' => 'root.parser.manually_stopped_tstamp' }
};

<list.dependency> = {
    'var'      => 'data',
    'key'      => 'dependency.object',
    'sort_key' => 'agent_name',
    'descr'    => 'agent dependency status',
    'mask'     => 'agent_name <key>:depends_on_agents <key>:status',
    'align'    => {
        'agent_name'        => 'center',
        'depends_on_agents' => 'center-5',
        'status'            => 'left'
    },
    'filters' => {
        'depends_on_agents' => 'root.parser.dependency_chain',
        'status'            => 'root.parser.dependency_status'
    }
};

return 0;
