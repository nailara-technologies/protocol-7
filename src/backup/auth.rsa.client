# >:]

# name       = auth.rsa.client

if ( not defined $_[0] ) {
    <[base.log]>->(
        0,
        "auth.rsa.client: "
            . "supplied filehandle is undefined, won't work on that!"
    );
    return undef;
}

my $new_cipher = 'twofish';
my ( $backend_socket, $smiley, $answer ) = ( $_[0], '', '' );
my $id = $data{'handle'}{ $_[0] }{'cid'};

if ( not defined $id or !$id ) {
    <[base.log]>->(
        0,
        "auth.rsa.client: "
            . "no client id 'cid' for '$_[0]', no initialized session?"
    );
    return undef;
}

my $key_id = 0;    ###

my $output = \$data{'session'}{$id}{'buffer'}{'output'};

if ( sysread( $backend_socket, $smiley, 4 ) ) {
    if ( $smiley =~ />:\]\n/ ) {
        <[base.log]>->( 1, '[*] smiley ok :)' );
    } else {
        <[base.log]>->( 1, '[#] no valid smiley found! :(' );
        return undef;
    }
    <[base.log]>->( 1, '[#] selecting rsa authentication' );
    <[net.out]>->( $backend_socket, "select rsa\n" );
    if ( sysread( $backend_socket, $answer, 42 ) ) {

        if ( $answer =~ /^ACK continue\n$/ ) {
            <[base.log]>->( 1, '[+] requesting rsa public key..' );
            <[net.out]>->( $backend_socket, "get key\n" );

            $answer = '';

            if ( sysread( $backend_socket, $answer, 23542, length($answer) ) ) {

                my $key_data_length = 0;

                if ( $answer =~ s/RAW (\d+)\n// ) {
                    $key_data_length = $1;

                    if ( length($answer) == $key_data_length ) {
                        <[base.log]>->( 1, '[+] pub key received.' );

                        my $rsa_pub;

                        if (eval '$rsa_pub = '
                            . 'Crypt::OpenSSL::RSA->new_public_key($answer)' ) {

                            <[base.log]>->( 1, '[+] pub key is valid.' );
                            $rsa_pub->use_pkcs1_oaep_padding();
                            $rsa_pub->use_sha512_hash();
                            my $sk_size = 256;

                            <[base.log]>->(
                                1, "[+] generating $sk_size bit session key.."
                            );
                            my $session_key = <[crypt.random.bytes]>
                                ->( int( $sk_size / 8 ) );

                            $answer = '';

                            my $ciphered = $rsa_pub->encrypt($session_key);
                            my $hex_key = unpack( "H*", $ciphered );
                            <[base.log]>->(
                                1, "[+] transferring key to peer.."
                            );
                            <[net.out]>->(
                                $backend_socket, "set secret $hex_key\n"
                            );

                            if (sysread(
                                    $backend_socket, $answer,
                                    4096,            length($answer)
                                )
                                ) {

                                if ( $answer =~ s/^ACK session key set.\n$// ) {
                                    <[base.log]>->(
                                        0, '[+] session key has been accepted.'
                                    );

                                    <[net.out]>->(
                                        $backend_socket,
                                        "set cipher $new_cipher\n"
                                    );

                                    if (sysread(
                                            $backend_socket, $answer,
                                            4096,            length($answer)
                                        )
                                        ) {

                                        if ( $answer =~ /^ACK ([^\n]+)$/ ) {
                                            <[base.log]>->(
                                                0,
                                                "[+] initializing $new_cipher chain.."
                                            );

                                            $data{'handle'}{ $_[0] }
                                                {'encryption'} = $new_cipher;
                                            $data{'handle'}{ $_[0] }
                                                {'session_key'} = $session_key;

                                            my $enc_filter
                                                = <[filter.add_filter]>->(
                                                "${new_cipher}_enc",
                                                "crypt.$new_cipher.encrypt",
                                                $key_id
                                                );
                                            my $dec_filter
                                                = <[filter.add_filter]>->(
                                                "${new_cipher}_dec",
                                                "crypt.$new_cipher.decrypt",
                                                $key_id
                                                );

                                            my $chain_in
                                                = &{ $code{
                                                    'filter.compile_chain'} }
                                                ( 'twofish_dec', $dec_filter );
                                            my $chain_out
                                                = &{ $code{
                                                    'filter.compile_chain'} }
                                                ( 'twofish_enc', $enc_filter );

                                        } elsif ( $answer =~ /^NACK (.+)\n$/ ) {
                                            <[base.log]>->(
                                                1,
                                                "[#] cipher not accepted by remote host. [$1]"
                                            );
                                        }

                                    } elsif ( $answer =~ /^NACK (.+)\n$/ ) {
                                        <[base.log]>->(
                                            1,
                                            '[#] session key has been rejected. [$1]'
                                        );
                                    }
                                } elsif (
                                    $answer =~ s/^NACK ([\w\s\.\,\-]+)\n$// ) {
                                    <[base.log]>->(
                                        0,
                                        "[#] failed to agree on session key [ '$1' ] !"
                                    );
                                } else {
                                    <[base.log]>
                                        ->( 0, '[#] protocol error :(' );
                                }
                            }
                        } else {
                            <[base.log]>->(
                                0, "[#] received rsa key is invalid!"
                            );
                        }

                    } else {
                        <[base.log]>->( 1, '[#] pub key size mismatch' );
                    }
                }
                return $backend_socket;
            }
        } elsif ( $answer =~ /^NACK ([^\n]+)$/ ) {
            <[base.log]>->( 1, '[#] auth method rejected :( [$1]' );
            return undef;
        } else {
            <[base.log]>->( 0, '[#] protocol error :(' );
            return 0;
        }
    }
}
