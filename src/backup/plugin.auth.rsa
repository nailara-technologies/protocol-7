# >:]

# name       = plugin.auth.rsa

my $id = $_[0]->w->data;

my $buffer  = \$data{'session'}{$id}{'buffer'}{'input'};
my $handle  = \$data{'session'}{$id}{'handle'};
my $session = $data{'session'}{$id};

my $key_id = $data{'auth'}{'rsa'}{'key'}{'current'}{'id'};
my $key    = $data{'crypt'}{'rsa'}{'key'}{$key_id};
my $rsa    = $key->{'obj'};
my $maxlen = 1024;

if ( $$buffer =~ s/^get key\n// ) {

    <[base.log]>->( 2, "[$id] auth.rsa: client requested public key.." );

    if ( defined $key->{'public'} and $key->{'public'} ne '' ) {
        <[net.out]>->(
            $$handle,
            "RAW " . length( $key->{'public'} ) . "\n" . $key->{'public'}
        );
        return 1;
    } else {
        <[base.log]>->( 1, "[$id] auth.rsa: no pubkey loaded." );
        <[net.out]>->( $$handle, "NACK no pubkey found :(\n" );
    }
} elsif ( $$buffer =~ s/^set secret ([^\]]+)\n// ) {
    my $secret = $1;

    <[base.log]>->( 2, "[$id] auth.rsa: received new session key.." );

    if ( length($secret) < 1024 ) {

        #        <[base.log]>->( 1, "setting secret to '$secret'");
        # $$session{'auth'}{'session_key'} = pack("H*",$secret);

        # die " private : " . $rsa->get_private_key_string();

        # if( $rsa->check_key() ) { die "((( is valid )))" }

        if (
#       $$session{'auth'}{'session_key'} = eval(
#          '$data{\'crypt\'}{\'key\'}{$key_id}{\'rsa_obj\'}->decrypt(pack("H*",$secret));'
#        )

            #$$session{'auth'}{'session_key'} = $rsa->decrypt($plaintext)
            $$session{'auth'}{'session_key'}
            = $rsa->decrypt( pack( "H*", $secret ) )
            ) {
            <[net.out]>->( $$handle, "ACK session key set.\n" );
            <[base.log]>->( 2, "[$id] auth.rsa: session key accepted!" );
        } else {
            <[net.out]>->( $$handle, "NACK decryption failed\n" );
            <[base.log]>->( 1, "[$id] decryption of session secret failed!" );
        }
    } else {
        <[net.out]>->( $$handle, "NACK ciphered data too long!\n" );
        <[base.log]>->( 1, "[$id] auth.rsa: session key too long!" );
        return -1;
    }
} elsif ( $$buffer =~ s/^set cipher ([^\n]+)\n// ) {
    my $requested_cipher = $1;

    if ( $requested_cipher eq 'twofish' ) {

        <[net.out]>->( $$handle, "ACK initializing twofish chain!\n" );

        $data{'handle'}{$$handle}{'encryption'} = 'twofish';
        $data{'handle'}{$$handle}{'session_key'}
            = $$session{'auth'}{'session_key'};

        delete $$session{'auth'}{'session_key'};

        <[base.log]>->( 1, "[$id] initializing twofish chain!" );

    } else {
        <[net.out]>->( $$handle, "NACK unknown cipher requested!\n" );
        <[base.log]>->( 1, "[$id] unknown cipher requested!" );
    }

} elsif ( $$buffer =~ /\n/ ) {
    <[net.out]>->( $$handle, "NACK protocol error\n" );
    <[base.log]>->( 1, "[$id] auth.rsa: protocol error!" );
    return 2;
}

if ( length($$buffer) > $maxlen ) {
    <[base.log]>->( 1, "[$id] maxlen reached" );
    <[net.out]>->( $$handle, "BLOAT ERROR >:[\a" );
    $$session{'shutdown'} = 1;
    return -1;
}

return 1;
