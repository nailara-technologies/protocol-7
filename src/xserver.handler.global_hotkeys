# >:]

# name  = xserver.handler.global_hotkeys

my $watcher = shift->w;

<xserver.hotkeys>            //= {};
<xserver.hotkeys.configured> //= {};
<xserver.hotkeys.triggered>  //= {};
<xserver.hotkeys.last_key>   //= {};
<xserver.loglevel.keys>      //= 2;

my $qkmap = eval { <xserver.x11>->QueryKeymap };

if ( not defined $qkmap ) {    # LLL: implement reconnect / restart procedure!!
    <[base.log]>->(
        0, "<!> X11 protocol mismatch during 'QueryKeymap' command <!>"
    );
    return;
}

my $dq_e = [ <xserver.x11>->dequeue_event ];

if ( @{$dq_e} ) {
    $watcher->now;             # <- again, there might be more events queued..
} else {
    return;                    # <- no, there weren't
}

my $no_key_pressed = $qkmap =~ /^\0+$/ ? 1 : 0;

my %event = @$dq_e;

# print STDERR Dumper( \%event );

my $event_type = $event{'name'} =~ /^Key(Press|Release)$/ ? lc($1) : undef;

return if not defined $event_type;

my $keycode     = $event{'detail'};
my $mod_state   = $event{'state'};
my $triggered   = <xserver.hotkeys.triggered>;
my $is_modifier = exists <xserver.keycodes.modifiers>->{$keycode} ? 1 : 0;

return if $is_modifier;    # <- modifier keys skipped ( for now )

$triggered->{$event_type}{'keycode'}{$keycode}{'mod_state'}{$mod_state} = 1;
$triggered->{$event_type}{'mod_state'}{$mod_state}{'keycode'}{$keycode} = 1;
<xserver.hotkeys.last_key> = {
    'keycode'    => $keycode,
    'mod_state'  => $mod_state,
    'event_type' => $event_type
};

my $mod_str
    = $is_modifier
    ? '  [' . <xserver.keycodes.modifiers>->{$keycode} . ']'
    : '';

<[base.log]>->(
    <xserver.loglevel.keys>,
    sprintf(
        "<KEY> %-8s [ keycode  : %3s  ]  modifier : %d%s",
        $event_type, $keycode, $mod_state, $mod_str
    )
);

# LLL: process key ...

<xserver.hotkeys.active> //= {};
if ( defined <xserver.hotkeys.recording> and $event_type eq 'press' ) {
    my ( $command_str, $params_str )
        = split( / +/, delete <xserver.hotkeys.recording>, 2 );
    my $hotkey_id = <[base.gen_id]>->(<xserver.hotkeys.active>);

    # LLL: filter duplicates

    <xserver.hotkeys.active>->{$hotkey_id} = {
        'keycode'   => $keycode,
        'mod_state' => $mod_state,
        'action'    => $command_str,
        'params'    => $params_str // '',
    };

    <[base.log]>->( 1, "recorded '$command_str' hot key [key:$keycode] ..." );

    foreach my $reply_id ( @{<xserver.hotkeys.rec_reply_ids>} ) {
        <[base.callback.cmd_reply]>->(
            $reply_id,
            {   'mode' => 'ack',
                'data' => "recorded as hotkey $hotkey_id"
            }
        );

        <[base.proto.nailara.command.send.local]>->(
            {   'command'   => "core.notify.info",
                'call_args' => { 'args' => "hotkey configured" }
            }
        );

        delete <xserver.hotkeys.rec_reply_ids>;
        delete <xserver.hotkeys.recording>;
    }
} elsif ( $event_type eq 'press' ) {

    foreach my $h_id ( keys %{<xserver.hotkeys.active>} ) {
        if (    <xserver.hotkeys.active>->{$h_id}->{'keycode'} == $keycode
            and <xserver.hotkeys.active>->{$h_id}->{'mod_state'} == $mod_state )
        {
            my $cmd_str = <xserver.hotkeys.active>->{$h_id}->{'action'};
            <[base.log]>->( 1, "[HOTKEY] sending command '$cmd_str' .." );
            my @params
                = length( <xserver.hotkeys.active>->{$h_id}->{'params'} )
                ? ( 'call_args' =>
                    { 'args' => <xserver.hotkeys.active>->{$h_id}->{'params'} }
                )
                : ();
            <[base.proto.nailara.command.send.local]>->(
                {   'command' => "core.$cmd_str",
                    @params
                }
            );
        }
    }

}

if ($no_key_pressed) {

    # LLL: process key ...

    delete <xserver.hotkeys.last_key>;
    delete <xserver.hotkeys.triggered>;
}
