# >:]

# name  = base.log
# descr = generate a log entry
# args  = log_level log_msg [log_buffer]

my ( $log_level, $log_msg, $log_buffer ) = ( $_[0], $_[1], $_[2] );

$log_level  = 0        if not defined $log_level  or $log_level !~ /^\d+$/;
$log_buffer = 'system' if not defined $log_buffer or $log_buffer eq '';
$log_msg = 'LOG MESSAGE UNDEFINED' if not defined $log_msg or !length($log_msg);

$log_msg =~ s/\r/\\r/g;
$log_msg =~ s/\n/\\n/g;
$log_msg =~ s/\0/\\0/g;
$log_msg =~ s/\e/\\e/g;

# prevent deep recursions in error log system:
my $fatal_exit
    = ( $log_msg =~ /Deep recursion / and $log_msg =~ /log|buffer/ ) ? 1 : 0;

$log_msg = "call to unknown subroutine while executing '$1'!"
    if $log_msg
    =~ /\$code\{'([^\']*)'\}.+Can't use string \(""\) as a subroutine/;

my $agent_prefix = join( '.', ' :' . <system.node.name>, <system.agent.name> );

my $log_txt;
if ( $log_level > 0 ) {
    $log_txt = "$agent_prefix $log_msg\n";
} else {
    $log_txt = "$agent_prefix $ANSI{bold}$log_msg$ANSI{normal}\n";
}

if ($fatal_exit) {
    print STDERR $log_txt
        . "$agent_prefix EMERGENCY SHUTDOWN!"
        . " [anticipated deep recursion in log system!]\n";
    exit 2;
}

my $log_stamp = join( ' ', <[base.time]>->(5), $log_level, $log_msg );

# write to system log buffer
if ( exists <system.internal_verbosity>
    and $log_level <= <system.internal_verbosity> ) {
    <[base.buffer.add_line]>->( $log_buffer, $log_stamp );
}

# print to console
if ( exists <system.verbosity> and $log_level <= <system.verbosity> ) {
    print $log_txt;
}
