# >:]

# name = events.handler.event_triggered

my $watcher     = shift->w;
my $event       = $watcher->data;
my $ev_id       = $event->{'id'};
my $ev_type     = $event->{'type'};
my $ev_data     = <events.setup>->{$ev_id};
my $event_name  = $ev_data->{'name'};
my $action      = $ev_data->{'action'};
my $action_type = $action->{'type'};

if ( not exists <events.enabled>->{$event_name}
    or !<events.enabled>->{$event_name} ) {
    <[base.log]>->( 2, "[IGNORED] event '$event_name' not enabled (setup)" );
    return;
}

if ( defined $ev_data->{'dep_id'}
    and !<[dependency.ok]>->( $ev_data->{'dep_id'}, $ev_id ) ) {
    <[base.log]>->(
        1, "[IGNORED] '$event_name' event (unresolved dependencies)"
    );
    return;
} elsif ( defined $ev_data->{'dep_id'} ) {
    <[base.log]>->( 2, "[OK] dependencies resolved [event '$event_name']" );
}

<[base.log]>->( 1, "<$action_type> '$event_name' [" . uc($ev_type) . "]" );

if ( $action_type eq 'agent_running' ) {
    my $command;
    my $agent_name = $action->{'agent_name'};
    die "parameter agent_name not defined in event $ev_id setup"
        if not defined $agent_name;
    $command = 'start_once'    if $ev_type eq 'start';
    $command = 'stop_implicit' if $ev_type eq 'end';
    $command = 'start_once'    if $ev_type eq 'at';
    die "event $ev_id action command undefined" if not defined $command;

    <[base.proto.nailara.command.send.local]>->(
        {   'command'   => 'core.root.' . $command,
            'call_args' => { 'args' => $agent_name }
        }
    );
} elsif ( $action_type eq 'send_command' ) { #XXX: need param check during setup
    map {
        die "'$_' param is invalid for action type '$action_type'"
            . ", expected <at>-parameter"
            if $ev_type eq $_
    } ( 'start', 'end' );
    die "setup parameter 'at' is missing for action type '$action_type'"
        if $ev_type ne 'at';
    die "'command' parameter is missing from '$action_type' setup"
        if not defined $action->{'command'};

    ( my $target_route, my $args_str )
        = split( / +/, $action->{'command'}, 2 );
    my $args_ref = defined $args_str ? { 'args' => $args_str } : {};

    my $args_lstr = defined $args_str ? " ($args_str)" : '';
    <[base.log]>->( 1, "sending '$target_route' command" . $args_lstr );
    <[base.proto.nailara.command.send.local]>->(
        {   'command'   => "core.$target_route",
            'call_args' => $args_ref
        }
    );
} elsif ( $action_type eq 'playlist_show_entry' ) {
    my $b8id = $action->{'b8id'};
    die "'b8id' parameter is missing from '$action_type' setup"
        if not defined $b8id;
    <events.stack.playlist>->{$b8id}->{'visibility'} //= 0;
    my $change = $ev_type eq 'end' ? -1 : 1;
    <events.stack.playlist>->{$b8id}->{'visibility'} += $change;

} elsif ( $action_type eq 'playlist_hide_entry' ) {
    my $b8id = $action->{'b8id'};
    die "'b8id' parameter is missing from '$action_type' setup"
        if not defined $b8id;
    <events.stack.playlist>->{$b8id}->{'visibility'} //= 0;
    my $change = $ev_type eq 'end' ? -1 : 1;
    <events.stack.playlist>->{$b8id}->{'visibility'} -= $change;
}

if ( $ev_type eq 'at' or $ev_type eq 'end' ) {
    delete <events.unix.timetable>->{$ev_id};
    <event.timer.recalc>->cancel if defined <event.timer.recalc>;
    <event.timer.recalc> = <[event.add_timer]>
        ->( { 'at' => time + 1, 'handler' => 'events.recalc' } );
}

<[base.proto.nailara.command.send.local]>
    ->( { 'command' => "core.playlist.update" } )
    if index( $action_type, 'playlist_' ) == 0;
