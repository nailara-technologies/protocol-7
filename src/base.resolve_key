# >:]

# name  = base.resolve_key
# descr = resolve hash key and return reference to value or undef if not found

my $key_str  = shift;
my $hash_ref = shift // *data{HASH};

# allowing keys containing '.'s by single quoting them
$key_str =~ s/\'([^\']+)\'/my$k=$1;$k=~s|\.|\0|g;$k/ge;
my @key_tree = split( /\./, $key_str );
map { $_ =~ s/\0/./g } @key_tree;
while ( my $sub_key = shift @key_tree ) {
    if ( ref($hash_ref) ne 'HASH' or not defined ${$hash_ref}{$sub_key} ) {
        return undef;
    }
    if ( @key_tree and ref( ${$hash_ref}{$sub_key} ) eq 'HASH' ) {
        $hash_ref = \%{ $$hash_ref{$sub_key} };
    } elsif ( !@key_tree ) {
        return \${$hash_ref}{$sub_key};
    } else {
        return undef;
    }
}
return undef;

# ______________________________________________________________________________
#\\OR3S7RTMW5NZ6JFZWUP2IPTCLF5DK3MQUEQJBK6LF27RGPK7Q7S2KZBOMC3ZUIXWLWWV55U4W5RUE
# \\ UAEUSJJ4BZRPUWF7DQ646EWPSHQXOLQ7ZVLWR4KPPNWEGPVXOMWY \\// C25519-BASE-32 //
#  \\// SJYZLV27ARYYUT3SOZWMZD56UT572L2THXVR76QUGH6LCRCGACA \\ CODE SIGNATURE \\
#   ````````````````````````````````````````````````````````````````````````````
