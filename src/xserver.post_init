# >:]

# name = xserver.post_init

<xserver.initialized>         //= 0;
<xserver.host_mode_unchanged> //= 1;

if ( <xserver.mode> !~ /^(host|xorg|xephyr|xvfb)$/ ) {
    <[base.log]>->(
        0, "invalid xserver mode '" . <xserver.mode> . "' in agent config!"
    );
    exit(2);
}
<xserver.params>->{<xserver.mode>} //= '';
<xserver.host_mode_unchanged> = 0 if <xserver.host_mode_unchanged> eq 'no';
<xserver.host_mode_unchanged> = 1 if <xserver.host_mode_unchanged> eq 'yes';
if ( <xserver.mode> eq 'host' ) {
    if (<xserver.host_mode_unchanged>) {
        <xserver.keep_unchanged>  = 1;
        <xserver.keep_background> = 1;
    }
    <xserver.display.host> //= defined $ENV{'DISPLAY'} ? $ENV{'DISPLAY'} : ':0';
} else {
    <xserver.display>->{<xserver.mode>} //= ':1';
    <xserver.keep_unchanged> = 0;
}
<[base.log]>->(
    0,
    "warning: xserver mode changed to '"
        . <xserver.mode>
        . "', restart required!"
) if defined <xserver.old_mode> and <xserver.mode> ne <xserver.old_mode>;

return 0 if <xserver.initialized>;

<xserver.connect_timeout> //= 7.7;
<xserver.orientation>     //= 'normal';
<xserver.old_mode> = <xserver.mode>;
my $mode     = <xserver.mode>;
my $bg_col   = <xserver.bg_color>;
my $bg_image = <xserver.bg_image>;
my $bin_name;
my $server_bin;
my $server_pid;
my $server_params;

<xserver.params>->{'xephyr'} .= ' -glamor'
    if $mode eq 'xephyr'
    and <xserver.orientation> eq 'normal'
    and !<xserver.disable_glamor>;

## startup / connect ##

if ( $mode ne 'host' ) {
    if ( not defined $mode or !length($mode) ) {
        die "xserver.mode not defined (expected 'xorg' or 'xephyr')";
    } elsif ( $mode eq 'xorg' or $mode eq 'xephyr' or $mode eq 'xvfb' ) {
        $bin_name = $mode eq 'xorg' ? 'Xorg' : 'Xephyr';
        $bin_name = 'Xvfb' if $mode eq 'xvfb';
        chomp( $server_bin = qx(which $bin_name) );
        die "xserver binary '$bin_name' not found. (not installed?)"
            if not defined $server_bin or !-x $server_bin;

        $server_params
            = join( ' ', <xserver.display>->{$mode},
            <xserver.params>->{$mode} );
    } else {
        die "invalid mode '$mode' (xserver.mode)";
    }

    my $cmd_line = "$server_bin $server_params 2>&1 |";

    <[base.log]>->( 1, "starting $bin_name-Server..." );

    # XXX: change uid for 'xephyr'...
    $server_pid = open( my $out_fh, $cmd_line );

    if ( not defined $server_pid or $@ ) {
        my $err_reason = ( defined $! and length($!) ) ? ": \"$!\"" : '!';
        <[base.log]>->( 0, ": failed to spawn $bin_name-server" . $err_reason );
        exit(2);
    } else {
        <[base.log]>->(
            1, ": $bin_name-Server process started (pid=$server_pid)"
        );
        <xserver.pid> = $server_pid;
        push( @{<system.kill_list>}, <xserver.pid> );
        <[base.renice]>->( <xserver.renice_priority>, <xserver.pid> );
    }

    <[event.add_io]>->(
        {   'fd'      => $out_fh,
            'handler' => 'xserver.handler.server_output',
            'data'    => { 'bin' => $bin_name, 'pid' => $server_pid }
        }
    );
} else {
    $bin_name = '(host) x11';
    <xserver.connect_timeout> = 15 if <xserver.connect_timeout> < 15;
    <[base.log]>->( 1, "running in host mode ( using existing X11-server )" );
}

<xserver.x11_bin_name> = $bin_name;

<[base.log]>->( 1, ": connecting to X display " . <xserver.display>->{$mode} );

<[xserver.connect_x11]>;

<[base.log]>->( 1, ": : $bin_name-server ok! (responding)" );

<xserver.x11>->{'error_handler'} = sub {
    my ( $self, $err_data ) = @_;
    chomp( my $err_str = $self->format_error_msg($err_data) );
    $err_str =~ s|\s*\n+\s*| --- |g;
    warn( $err_str, '<{C7}>' );
};

## extensions ##

# <[base.log]>->( 1, ": initializing extensions ..." );
# <xserver.x11>->init_extensions;
# print STDERR Dumper( keys( %{ <xserver.x11>->{'ext'} } ) );

<xserver.x11>->init_extension('RANDR')
    or die "[!] failed to initialize RANDR extension!\n";
<xserver.x11>->RRQueryVersion( 1, 0 );

<xserver.x11>->init_extension('DPMS')
    or die "[!] failed to initialize DPMS extension!\n";
<xserver.x11>->DPMSGetVersion();

if ( <xserver.x11>->DPMSCapable ) {
    <[base.log]>->( 1, ": : DPMS is supported :)" );
    <xserver.has_dpms> = 1;
} else {
    <[base.log]>->( 1, ": : DPMS not supported :|" );
    <xserver.has_dpms> = 0;
}

## display connected? ##

<xserver.display_connected.any> //= 1;

<[xserver.init_display_states]> if <xserver.mode> eq 'xorg';

if ( <xserver.mode> eq 'xorg' and !<xserver.display_connected.any> ) {

    <xserver.wait_for_display.callback> = 'xserver.callback.display_connected';
    <[base.log]>->( 0, "<!> display is off / not connected <!>" );

    # polling for screen sizes, otherwise drm display status never gets updated!
    <xserver.timer.wait_for_display> = <[event.add_timer]>->(
        {   'after'    => 1,
            'interval' => 1,
            'handler'  => 'xserver.handler.poll_size_list'
        }
    );
    <[base.log]>->( 0, "    : waiting for a display to restart xserver!" );

    if ( defined <xserver.host_mode.min_size>
        and <xserver.host_mode.min_size> =~ /^\d+x\d+$/ ) {
        <[base.log]>->(
            0, "    : setting min_size [" . <xserver.host_mode.min_size> . "]"
        );
        <[xserver.cmd.set_screen_size]>
            ->( { 'args' => <xserver.host_mode.min_size> } );
    }

} elsif ( <xserver.mode> eq 'xorg' ) {
    <[base.log]>->( 1, ": : display is on / connected :)" );

    my @max_size = <[xserver.max_screen_size]>;
    if (   $max_size[0] > <xserver.x11>->width_in_pixels
        or $max_size[1] > <xserver.x11>->height_in_pixels ) { # check start size
        <[base.log]>->(
            0, "<!> xserver failed to select highest screen size <!>"
        );
        <[base.log]>->( 0, " :. fixing it! ( reloading gfx kernel module )" );
        <[event.add_timer]>->(
            {   'after'   => 0.13,
                'handler' => 'xserver.callback.force_driver_reload'
            }
        );
    } else {
        <xserver.display_status.handler>
            = 'xserver.handler.display_power_state';
    }
}

## orientation ##

<[xserver.cmd.rotate_screen]>->( { 'args' => <xserver.orientation> } )
    if !<xserver.keep_unchanged>;

## custom xrandr ##

map {
    system( '/usr/bin/xrandr', split( / +/, <xserver.custom_xrandr>->{$_} ) )
    }
    sort {
    $a <=> $b
    } keys %{<xserver.custom_xrandr>}
    if <xserver.mode> eq 'xorg'
    and defined <xserver.custom_xrandr>
    and ref(<xserver.custom_xrandr>) eq 'HASH';

## keyboard ##

<xserver.kbd> = X11::Keyboard->new(<xserver.x11>);

<xserver.keycodes.modifiers> = <[xserver.get_modifier_map]>;

#  my $any_key = <xserver.kbd>->KeysymToKeycode('AnyKey');
#  my $any_mod = <xserver.kbd>->KeysymToKeycode('AnyModifier');

<xserver.x11>->{'event_handler'} = 'queue';
<[event.add_io]>->(
    {   'fd'      => <xserver.x11>->{'connection'}->fh,
        'handler' => 'xserver.handler.global_hotkeys'
    }
);

<[xserver.grab_key]>
    if !<xserver.keep_unchanged>
    and defined <xserver.keybd.grab_all_keys>
    and ( <xserver.keybd.grab_all_keys> eq '1'
    or <xserver.keybd.grab_all_keys> eq 'yes' );

## screensaver / blanking ##

if (    <xserver.has_dpms>
    and !<xserver.keep_unchanged>
    and defined <xserver.disable_blanking>
    and (  <xserver.disable_blanking> eq 'yes'
        or <xserver.disable_blanking> eq '1' )

    ) {
    <[base.log]>->( 1, ": deactivating screen blanking ..." );

    <xserver.x11>->DPMSDisable();
    <xserver.x11>->SetScreenSaver( 0, 0, 1, 0 );
}

## GPU load statistics (intel only) ##
<xserver.collect_intel_gpu_stats> //= 0;
<xserver.collect_gpu_stats_on_4K> //= 0;
<[xserver.start_gpu_top]> if <xserver.video_driver> =~ /^i/i    # i9xx <?>
    and ( <xserver.collect_intel_gpu_stats>
    or <xserver.collect_gpu_stats_on_4K>
    and <xserver.x11>->width_in_pixels >= 3840 );

## background image / color ##

<xserver.keep_background> //= 0;
if (<xserver.keep_background>) {    # <- don't touch background image and color
    <xserver.initialized> = 1;
    return 0;
}

## XXX: testing simple fade in
if ( defined $bg_col and $bg_col =~ /^#?FFFFFF$/i ) {
    <[xserver.fade_in_bg_col]>;
} elsif ( defined $bg_col and $bg_col =~ /^\#?[0-9A-F]{6}$/i ) {
    $bg_col = "#$bg_col" if $bg_col =~ /^[0-9A-F]{6}$/i;
    <[base.log]>->( 1, "setting background color '$bg_col'" );
    X11::Protocol::XSetRoot->set_background( 'color' => $bg_col );
}
##

my @hsetroot_params;    # XXX: hsetroot call will be replaced soon...
my $hsetroot_bin = '/usr/bin/hsetroot';    # XXX: -> config || `which`

## OLD METHOD ## ( still here because of compton glitch! )
if ( defined $bg_col and $bg_col =~ /^\#?[0-9A-F]{6}$/i ) {
    $bg_col = "#$bg_col" if $bg_col =~ /^[0-9A-F]{6}$/i;
    if ( !-x $hsetroot_bin ) {
        <[base.log]>->( 0, "cant't set bg color: '$hsetroot_bin' not found!" );
        return -1;
    }
    <[base.log]>->( 1, "setting background color '$bg_col'" );
    @hsetroot_params = ( '-solid', $bg_col );
    if ( system( $hsetroot_bin, @hsetroot_params ) != 0 ) {
        <[base.log]>->( 0, "failed to execute 'hsetroot' ( returned $? )" );
    }
}
##
my $bg_mode = <xserver.bg_mode>;
if ( defined $bg_image ) {
    if ( !-x $hsetroot_bin ) {
        <[base.log]>->( 0, "cant't set bg image: '$hsetroot_bin' not found!" );
        return -1;
    }
    ( my $img_txt = $bg_image ) =~ s,^.+/,,g;
    <[base.log]>->( 1, "setting background image '$img_txt'" );
    @hsetroot_params = ( "-$bg_mode", $bg_image ); # <- no -cover on arch linux!
    if ( system( $hsetroot_bin, @hsetroot_params ) != 0 ) {
        <[base.log]>->( 0, "failed to execute 'hsetroot' ( returned $? )" );
    }
}

<xserver.initialized> = 1;

# success
return 0;
