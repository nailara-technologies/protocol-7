# >:]

# name = root.callback.install_bin_unx

my $gcc_bin  = <root.gcc_bin>;
my $src_path = <system.root_path> . '/bin/src/unix_client.c';
my $bin_path = <root.cfg.unx_bin_path>;
die "gcc_bin not found"                  if !-x $gcc_bin;
die "source file '$src_path' not found!" if !-f $src_path;

( my $sha1_file = $bin_path ) =~ s|/([^/]+)$|/.sha1.src.$1|;

if ( -f $bin_path and -f $sha1_file ) {
    chomp( my $src_sha1 = ${ <[file.slurp]>->($sha1_file) } // '' );
    unlink($sha1_file) if !length($src_sha1);
    if ( <[digest.sha.file_hex]>->($src_path) ne $src_sha1 ) {
        <[base.log]>->( 0, "updating '$bin_path'.. [source has changed]" );
        unlink($bin_path) or die "unlink($bin_path): $!";
    }
} elsif ( -f $bin_path ) {
    <[base.log]>->( 0, "updating '$bin_path'.. [no src sha1 file found]" );
    unlink($bin_path) or die "unlink($bin_path): $!";
} else {
    my $cfg_val = <root.cfg.install_bin_unx>;
    <[base.log]>->( 0, "installing '$bin_path'.. [install_bin_unx=$cfg_val]" );
}

if ( !-f $bin_path ) {
    system( $gcc_bin, '-o', $bin_path, $src_path );  # XXX: add error handling..
    <[file.put]>->( $sha1_file, <[digest.sha.file_hex]>->($src_path) . "\n" );
} else {
    <[base.log]>->( 2, "'$bin_path' is up to date, nothing to do here..." );
}
