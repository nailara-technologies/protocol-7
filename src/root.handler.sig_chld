# >:]

# name  = root.handler.sig_chld

<[base.log]>->( 2, 'SIGCHLD received.. collecting children...' );
local ( $!, $? );
while ( ( my $pid = waitpid( -1, WNOHANG() ) ) > 0 ) {

    my $instance_id;
    my $instance;
    my $agent_name;
    my $agent_subname;

    if ( my $child = <root.child>->{$pid} ) {
        $instance_id   = $child->{'instance_id'};
        $instance      = <root.agent.instance>->{$instance_id};
        $agent_name    = $instance->{'agent_name'};
        $agent_subname = $instance->{'subname'};
    }

    # determine exit status
    my $log_level = 1;
    my $e_val     = $? >> 8;
    my $e_sig     = $? & 127;
    my $e_sig_str = $e_sig ? ", signal $e_sig" : '';
    $log_level = 0 if $e_sig_str =~ s|(signal 11)$|$1 (((SEGFAULT)))|;
    my $e_dmp = $? & 128 ? ' [with a core dump!]' : '';
    $log_level = 0 if $e_val or $? & 128;
    my $agent_str = defined $agent_name ? "< $agent_name > " : '';
    <[base.log]>->(
        $log_level,
        $agent_str
            . "child pid=$pid terminated"
            . " ( exit code $e_val$e_sig_str )$e_dmp"
    );

    <[root.cancel_status_timer]>->($instance_id) if defined $instance_id;

    <[root.terminate_process]>->($pid);    # <- cleans up children!

    if ( my $child = <root.child>->{$pid} ) {

        <[base.log]>->( 2, ": was instance $instance_id ..." );

        delete <root.child>->{$pid};

        delete $instance->{'restart_pids'}->{$pid}
            if exists $instance->{'restart_pids'};

        my $old_status = $instance->{'status'} || 'undefined';

        <[base.log]>->( 2, ": was '$old_status' ..." );

        ## record browser segfaults (for crash mitigation) ##
        if ( $e_sig == 11 and $agent_name eq 'browser' ) {
            my $browser_uname = 'nobody';    # XXX: determine automatically ...
            my $sn_hash
                = ( defined $agent_subname and length($agent_subname) )
                ? '.' . encode_base64url($agent_subname)
                : '';
            my $file_name = "/tmp/.nailara.browser.crash_pid$sn_hash";
            <[file.put]>->( $file_name, "$pid\n" ) or warn("$file_name: $!");
            chmod( 0644, $file_name ) or warn("$file_name: $!");
            my @pwn = getpwnam($browser_uname);
            chown( $pwn[2], $pwn[3], $file_name ) or warn("$file_name: $!");
        }

        my $next_status = (
                   $old_status eq 'online'
                or $old_status eq 'starting'
                or $old_status eq 'failed'
        ) ? 'failed' : 'offline';

        $next_status = 'restart' if $old_status eq 'restart';

        if ( $old_status eq 'online' and defined <root.ondemand_agents> ) {
            map { $next_status = 'offline' if $_ eq $agent_name }
                @{<root.ondemand_agents>};
        }

        if ( <[root.instance_pid_count]>->($instance_id) ) {
            <[agent.change_status]>->( $instance_id, 'delayed' )
                if $old_status eq 'restart';
            $instance->{'pid_check_timer'} = <[event.add_timer]>->(
                {   'after'    => 0.07,
                    'interval' => '0.1',
                    'handler'  => 'root.handler.children_left',
                    'data'     => {
                        'instance_id' => $instance_id,
                        'next_status' => $next_status
                    }
                }
            );
        } else {
            <[agent.change_status]>->( $instance_id, $next_status )
                if $old_status ne $next_status;
            <[root.init_respawn_timer]>->($instance_id);
        }
    }
}
