# >:]

# name = mpv.open_player

$SIG{'PIPE'} = sub {
    <[base.log]>->( 0, "SIGPIPE received! shutting down..." );
    exit(2);
};

my $target_geometry;
my $abort_startup = 0;
<mpv.audio_only> = 0;
my $mpv_params = <mpv.params>;

<mpv.audio_only> = 1
    if <system.agent.mode> eq 'stand-alone'
    and defined <system.agent.subname>
    and <system.agent.subname> eq 'audio';

<mpv.playlist_type> = 'audio' if <mpv.audio_only>; # <- run with 'audio' subname

if ( !<mpv.audio_only> ) {

    $ENV{'DISPLAY'} = <x11.display>;

    if (    <x11.mode> eq 'xephyr'
        and defined <mpv.cfg.xephyr.vo>
        and <mpv.vo_backend> ne <mpv.cfg.xephyr.vo> ) {
        <mpv.vo_backend> = <mpv.cfg.xephyr.vo>;
        <mpv.hwdec> = <mpv.cfg.xephyr.hwdec> if defined <mpv.cfg.xephyr.hwdec>;
        <[base.log]>->(
            1,
            sprintf( "switching vo_backend to '%s' [xephyr mode]",
                <mpv.vo_backend> )
        );
    }

    if ( not defined <mpv.geometry> or exists <x11.geometry_was_undefined> ) {
        <[base.log]>->( 1, "<!> geometry was undefined..." );
        if (<mpv.autoresize>) {
            <[base.log]>->( 1, " : disabled 'autoresize' function.." );
            <mpv.autoresize> = 0;
        }
        if ( <mpv.fade_in> and <mpv.auto_fs> ) {
            <[base.log]>->( 1, " : disabled 'fade_in' (auto_fs active).." );
            <mpv.fade_in> = 0;
        }
    }
    if ( <system.agent.mode> eq 'media-child' and <mpv.fade_in> ) {
        <[base.log]>->( 1, " : disabled 'fade_in' (media-child).." );
        <mpv.fade_in> = 0;
    }

    if (<mpv.fade_in>) {
        $target_geometry = <mpv.geometry>;
        <mpv.geometry> = <mpv.fade_start_geom>;
    }

    $mpv_params .= ' --geometry=' . <mpv.geometry> if defined <mpv.geometry>;

    <mpv.geometry> = $target_geometry if defined $target_geometry;

    if ( ( not defined <mpv.geometry> or exists <x11.geometry_was_undefined> )
        and exists <mpv.auto_fs>
        and <mpv.auto_fs> ) {
        $mpv_params .= ' -fs';
        if (<mpv.autoresize>) {
            <[base.log]>->( 1, " : disabled 'autoresize' function.." );
            <mpv.autoresize> = 0;
        }
        <[base.log]>->( 1, " : fullscreen mode is enabled (auto_fs).." );
        <mpv.current.window_width>  = <x11.coordinates.right>;
        <mpv.current.window_height> = <x11.coordinates.bottom>;
        <mpv.current.box_width>     = <x11.coordinates.right>; # XXX: check, fix
        <mpv.current.box_height>    = <x11.coordinates.bottom>;
    }

    $mpv_params .= ' -vo ' . <mpv.vo_backend> if defined <mpv.vo_backend>;
    $mpv_params .= ' --hwdec=' . <mpv.hwdec>  if defined <mpv.hwdec>;

    if (    defined <mpv.geometry>
        and exists <x11.coordinates>
        and exists <mpv.autoresize>
        and <mpv.autoresize> ) {
        my ( $width, $height ) = (
            <x11.coordinates>->{'right'} - <x11.coordinates>->{'left'},
            <x11.coordinates>->{'bottom'} - <x11.coordinates>->{'top'}
        );
        <[base.log]>->( 1, "auto resize is enabled (${width}x${height})" );
        $mpv_params .= " --autofit=${width}x${height} --no-keepaspect";
    }
} else {
    $mpv_params = <mpv.audio_params>;
    map { <[base.disable_command]>->($_) }
        ( 'zoom', 'align-x', 'align-y', 'change_subname' );
}

my $socket_path = "/tmp/.mpv.socket.$$";
$mpv_params .= " --input-ipc-server $socket_path";

my $mpv_title_str = <mpv.agent_title>;
$mpv_title_str .= '[' . <system.agent.subname> . ']'
    if exists <system.agent.subname> and length(<system.agent.subname>);
$mpv_title_str .= ' ( ${?media-title:${media-title}}${!media-title:no file} )';

<[base.log]>->(
    2, "current mpv parameters: " . <mpv.bin_path> . " $mpv_params"
);

<[base.log]>->( 1, 'starting mpv player..' );

<mpv.started_with_params> = $mpv_params . ' --title="' . $mpv_title_str . '"';

<mpv.pid> = open3( <mpv.fh.stdin>, <mpv.fh.stdout>, <mpv.fh.stderr>,
    ( <mpv.bin_path>, split( / +/, $mpv_params ), '--title', $mpv_title_str ) );

if ( !<mpv.pid> ) {
    <[base.log]>->( 0, "[!] failed to start mpv [$!]" );
    <[base.log]>->( 1, " : aborting agent startup .." );
    exit(1);
} else {
    push( @{<system.kill_list>}, <mpv.pid> );
    <[base.agents.report_child_pid]>->(<mpv.pid>);
}

END {    # cleaning up left over process on lost socket
    do { <[base.sleep]>->(0.13); kill( 9, <mpv.pid> ) }
        if defined <mpv.pid>
        and kill( 15, <mpv.pid> );
}

<[base.log]>->( 1, ": mpv process spawned [PID=<mpv.pid>]" );

close( delete(<mpv.fh.stdin>) );

goto no_window if <mpv.audio_only>;

<x11.window_timeout> //= 7;

my $wait_title_str = <mpv.agent_title>;
$wait_title_str .= '[' . <system.agent.subname> . ']'
    if exists <system.agent.subname> and length(<system.agent.subname>);
$wait_title_str =~ s|([\[\]\.])|\\$1|g;
if ( not defined <[base.x11.wait_for_window]>->($wait_title_str) ) {
    <[base.log]>->( 0, "[!] mpv window creation timed out!" );
    $abort_startup = 1;
    goto abort;
} else {
    <[base.x11.assign_window]>->(<x11.id>);
    if ( <system.agent.mode> eq 'media-child' ) {
        <[base.proto.nailara.command.send.local]>->(
            {   'command'   => "core.xserver.hide_window",
                'call_args' => { 'args' => <x11.id> }
            }
        );
    }
}

no_window:

my $max_retries = 42;
while ( $max_retries-- ) {
    last if -e $socket_path;
    <[base.sleep]>->(0.1);
    <[base.log]>->( 2, ": waiting for $socket_path .." )
        if !-e $socket_path;
}
if ( not -e $socket_path ) {
    <[base.log]>->(
        0, "[!] mpv socket creation failed ['$socket_path' does not exist]"
    );
    $abort_startup = 1;
} else {
    <[base.log]>->( 1, "opening unix domain socket '$socket_path'.." );
    <mpv.socket> = <[base.open]>->( 'unix', 'out', $socket_path );
    <[base.log]>->( 1, "unlinking socket $socket_path.." );
    unlink($socket_path) or warn("unlink($socket_path): $!");
}

if (   !$abort_startup and not defined <mpv.socket>
    or !$abort_startup and !-S <mpv.socket> ) {
    <[base.log]>->( 0, "[!] mpv socket creation failed [opened handle valid]" );
    $abort_startup = 1;
}

abort:

if ($abort_startup) {
    <[base.log]>->( 1, " : aborting agent startup .." );
    <[base.log]>->( 1, " : terminated mpv process " . <mpv.pid> . ".." )
        if kill( 9, <mpv.pid> );
    exit(1);
}

if ( <mpv.fade_in> and !<mpv.audio_only> ) {
    <[base.x11.set_window_opacity]>->( <x11.id>, 0 );
    <[base.proto.nailara.command.send.local]>->(
        {   'command'   => 'core.xserver.set_geometry',
            'call_args' => { 'args' => join( ' ', <x11.id>, $target_geometry ) }
        }
    );
    <mpv.opacity> = 0;
    Event->idle(
        cb => sub {
            <mpv.opacity>++;
            return 0 if <mpv.opacity> > 100;
            <[base.x11.set_window_opacity]>->( <x11.id>, <mpv.opacity> );
            return 1;
        },
        repeat => 1
    );
}

<[event.add_io]>->(
    {   'fd'      => <mpv.fh.stdout>,
        'handler' => 'mpv.handler.stdout',
        'data'    => {
            'pid'           => <mpv.pid>,
            'log_whitelist' => [
                'Creating non-video VO',
                '\[ipc',
                '.{5}Video ',
                '.{5}Audio ',
                'Waiting for XShm',
                'Exiting... \(Quit\)',
                '\[VDPAU SUNXI\] Presentation time not supported',
                'XIO:  fatal IO error 11',
                'XIO:  fatal IO error 104',
                'after \d+ requests',
                'libva info: VA-API version',
                'libva info: .+returns 0',
                'libva info: Trying to open /usr/lib/',
                'libva info: Found init function __vaDriverInit_',
                'No protocol specified',
                'WARNING: Invalid RefPicListX',
                'xcb_connection_has_error\(\) returned true'
            ]
        }
    }
);

<[event.add_io]>->(
    {   'fd'      => <mpv.socket>,
        'handler' => 'mpv.handler.pipe_output',
        'data'    => { 'pid' => <mpv.pid> }
    }
);

<[base.log]>->( 1, "player startup successful.." );
