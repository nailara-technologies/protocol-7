# >:]

# name = events.init_code
# note = event.* and events.* namespaces have entirely different meanings! ;)

use Date::Parse;

<events.setup>     //= {};
<events.enabled>   //= {};
<events.timetable> //= {};
<events.day_regex> //= {
    0 => qr/^Su(n(day)?)?$/i,
    1 => qr/^Mo(n(day)?)?$/i,
    2 => qr/^Tu(e(sday)?)?$/i,
    3 => qr/^We(d(nesday)?)?$/i,
    4 => qr/^Th(u(rsday)?)?$/i,
    5 => qr/^Fr(i(day)?)?$/i,
    6 => qr/^Sa(t(urday)?)?$/i,
};
<events.intervals> //= {};
<events.weekdays>  //= {};
<events.dates>     //= {};
<events.timers>    //= {};

if ( keys %{<events.timetable>} ) {
    <[base.log]>->( 1, "skipping event setup (already initialized).." );
    return 0;
}

my $config_data = <[base.load_section_config]>->('events.setup.example');

<[base.init_modules]>->('config.json');

<[config.json.import_file]>->('events.config.json');
$config_data = merge( $config_data, <import.playlist> );
$config_data = merge( $config_data, <import.layout> );

map { <events.enabled>->{$_} = 1 }
    ( keys %{<import.playlist.events>}, keys %{<import.layout.events>} );

my @enabled;
map { <events.enabled>->{$_} = 1; push( @enabled, $_ ) }
    split( / +/, $config_data->{'events'}->{'enabled'} )
    if defined $config_data->{'events'}->{'enabled'};

if (@enabled) {
    <[base.log]>->( 1, sprintf( "enabled : '%s'", join( "', '", @enabled ) ) );
} else {
    <[base.log]>->( 0, "no events enabled in configuration!" );
}

<[dependency.install_callbacks]>->('events');

<event.dep_id.weekdays>
    //= <[dependency.add_object]>->( { 'type' => 'weekday' } );
<event.dep_id.date_frame>
    //= <[dependency.add_object]>->( { 'type' => 'date_frame' } );

foreach my $event_name ( keys %{ $config_data->{'events'} } ) {
    next if ref $config_data->{'events'}->{$event_name} ne 'HASH';

    my $ev_id = <[base.gen_id]>->(<events.setup>);
    <events.setup>->{$ev_id} = {
        'name'   => $event_name,
        'action' => $config_data->{'events'}->{$event_name}->{'action'},
        'dep_id' => <[dependency.add_object]>->( { 'type' => 'event' } ),
        'days'   => undef
    };

    if ( defined $config_data->{'timetable'}->{$event_name}->{'days'} ) {
        my @selected_days;
        my $day_ref
            = delete $config_data->{'timetable'}->{$event_name}->{'days'};
        @selected_days = sort keys %{$day_ref} if ref($day_ref) eq 'HASH';
        @selected_days = sort @{$day_ref}      if ref($day_ref) eq 'ARRAY';
        @selected_days = sort split( / +/, $day_ref ) if ref($day_ref) eq '';
        foreach my $day_name (@selected_days) {
            map {
                <events.setup>->{$ev_id}->{'days'}->{$_} = 1
                    if $day_name =~ <events.day_regex>->{$_};
            } ( keys %{<events.day_regex>} );
        }
    }
    map {
        <[dependency.add]>->(
            <events.setup>->{$ev_id}->{'dep_id'},
            <event.dep_id>->{$_}
            )
    } ( 'weekdays', 'date_frame' );
    if ( exists $config_data->{'timetable'}->{$event_name} ) {
        <events.timetable>->{$ev_id}
            = $config_data->{'timetable'}->{$event_name};
    }
}

### test event ###

# my $ev_id = <[base.gen_id]>->(<events.setup>);
#
# <events.setup>->{$ev_id} = {
#     'name'   => 'soon_soon',
#     'action' => { 'type' => 'agent_running', 'agent_name' => 'xclock' }
# };
#
# my $next_start = strftime "%H:%M:%S", localtime( time + 23 );
# my $next_end   = strftime "%H:%M:%S", localtime( time + 42 );
#
# <events.timetable>->{$ev_id} = {
#     'name'  => 'soon_soon',
#     'start' => $next_start,
#     'end'   => $next_end,
# };
# ###

<[events.calc_unix_table]>;
<[events.set_up_timers]>;

0;
