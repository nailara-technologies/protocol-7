# >:]

# name  = layout.cmd.remove_overlay
# param = <layout_name[s]>
# descr = remove previously added layout overlay

my $overlay_str = $$call{'args'} // '';

<layout.transition_queue> //= [];
<layout.overlays.current> //= [];
<layout.overlays.previous> = [ @{<layout.overlays.current>} ];

return {
    'mode' => 'nak',
    'data' => "no layout overlay is active"
    }
    if !@{<layout.overlays.current>};
map {
    return {
        'mode' => 'nak',
        'data' => "layout '$overlay_str' is not active"
        }
        if <layout.current_layout> !~ /$_/;
} split / +/, $overlay_str;

my %del_overlays = map { $_ => 1 } split / +/, $overlay_str;
my @del_overlays = sort keys %del_overlays;

map {
    return {
        'mode' => 'nak',
        'data' => "expected valid layout name"
        }
        if not defined $_ or !length($_);
    return {
        'mode' => 'nak',
        'data' => "layout \"$overlay_str\" not found!"
        }
        if not exists <layout.config.layouts>->{$_};
    push( @{<layout.overlays.current>}, $_ );
} @del_overlays;

( my $current_one = <layout.current_layout> ) =~ s|\+.*$||;

my $prev_count = scalar @{<layout.overlays.current>};

my %active = map { $_ => 1 }
    grep { length($_) and $_ ne $current_one } @{<layout.overlays.current>};
map { delete $active{$_} if exists $active{$_} } @del_overlays;
@{<layout.overlays.current>} = sort keys %active;

return {
    'mode' => 'nak',
    'data' => "no match for layout '$overlay_str'"
    }
    if scalar @{<layout.overlays.current>} == $prev_count;

my $merged_name = join( '+', $current_one, @{<layout.overlays.current>} );

<[base.log]>->( 2, "creating merged [overlay] layout '$merged_name'" );

<layout.config.layouts>->{$merged_name}
    = <layout.config.layouts>->{$current_one};

map {
    <layout.config.layouts>->{$merged_name}
        = merge( <layout.config.layouts>->{$merged_name},
        <layout.config.layouts>->{$_} );
} @{<layout.overlays.current>};

return <[layout.cmd.switch_to]>->( { 'args' => $merged_name } );
