# >:]

# name = httpd.handler.download_transfer

my $watcher  = $_[0]->w;
my $id       = $watcher->data->{'id'};
my $session  = $data{'session'}{$id};
my $download = $session->{'download'};
my $clients  = <httpd.downloads.in_progress> ||= 1;

my $min_buf_size = 4096;
my $max_buf_size
    = sprintf( "%.0f", <httpd.downloads.total_bufsize_max> / $clients );
$max_buf_size = $min_buf_size if $max_buf_size < $min_buf_size;
$max_buf_size = <httpd.downloads.max_buffer_size>
    if $max_buf_size > <httpd.downloads.max_buffer_size>;

# $session->{'buffer'}->{'output'} //= '';    # LLL: track down undef...

my $read_size = $max_buf_size - length( $session->{'buffer'}->{'output'} );
$read_size = $download->{'bytes_to_go'}
    if $download->{'bytes_to_go'} < $read_size;

if ( $read_size < 1 ) {
    $watcher->stop;
    return 1;
}

$download->{'bytes_to_go'} -= <[base.s_read]>->(
    $download->{'content_fh'},
    \$session->{'buffer'}->{'output'},
    $read_size, length( $session->{'buffer'}->{'output'} )
);

if ( $download->{'bytes_to_go'} <= 0 ) {
    <[base.log]>->( 1, "[$id] download complete." );
    $watcher->cancel;
    close( $download->{'content_fh'} );
    delete $session->{'watcher'}->{'download_handler'};
    delete $session->{'download'};

    <[httpd.update_download_count]>;

    if ( $session->{'http'}->{'close'} ) {
        $session->{'flush_shutdown'} = 1;
    } else {
        $session->{'watcher'}->{'input_handler'}->timeout(<httpd.timeout>);
    }
    return 0;

} else {
    return 1;
}

# ______________________________________________________________________________
#\\AGCXJYBCWDSTLJO4GX7TFFCANKDZ6EK46IVHBTZ44UTYNIBNJJHMY6XACGATUSK5FCVM6L3UJXWPO
# \\ DLII5UPX5VZKXIYFQ5X34HHJFACI5I7TVSBVZWWP3QNAU4S2MIYN \\// C25519-BASE-32 //
#  \\// 7F7KGZA3IQWWV5WDUT3JICXJIO4VVEPGPS4TPBYBGMFNM6XFSBY \\ CODE SIGNATURE \\
#   ````````````````````````````````````````````````````````````````````````````
