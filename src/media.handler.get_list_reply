# >:]

# name = media.handler.get_list_reply

my $reply = shift;

<media.playlist_sha1>         //= '';
<media.playlist.files>        //= [];
<media.playlist.error_logged> //= {};
<media.cfg.fade_on_switch>    //= 0;

if ( $reply->{'cmd'} eq 'NAK' ) {
    <[base.log]>->( 0, ": unable to fetch playlist!" );
    <[media.stop_loadsplash]> if <media.loadsplash_running>;
    return;
}

my @file_list;
my %file_types = ( '[PAUSE]' => 'pause' );
foreach my $rep_line ( split( "\n", $reply->{'data'} ) ) {
    my ( $type, $file ) = split( / /, $rep_line, 2 );
    next if not exists <media.content.agent_map>->{$type} or $file eq '[PAUSE]';
    if (    $type eq 'video'
        and $file ne '[PAUSE]'
        and $file !~ /^\w+:\/\//
        and !-f $file ) {
        <[base.log]>->( 0, "<!> video file '$file' not found!" )
            if not exists <media.playlist.error_logged>->{$file};
        <media.playlist.error_logged>->{$file} = 1;
        next;
    }
    $file_types{$file} = $type;
    push( @file_list, $file );
}
my $playlist_sha1 = <[digest.sha.1]>->( join( ' ', @file_list ) );

if ( $reply->{'call_args'}->{'args'} == 0 ) {
    <[base.log]>->( 1, "received empty playlist!" );

    my $max_retries = <media.counter.empty_list_max_retries> //= 5;
    <media.counter.empty_list_retries>--
        if defined <media.counter.empty_list_retries>;
    my $retries_left = <media.counter.empty_list_retries> //= $max_retries;

    if ($retries_left) {
        <media.timer.playlist_retry>->cancel
            if defined <media.timer.playlist_retry>
            and <media.timer.playlist_retry>->is_active;
        my $retry_secs
            = sprintf( "%.2f", ( 1 + $max_retries - $retries_left ) * 0.42 );
        <[base.log]>->( 1, ": retrying update in ${retry_secs} seconds.." );
        <media.timer.playlist_retry> = <[event.add_timer]>->(
            {   'after'   => $retry_secs,
                'repeat'  => 0,
                'handler' => 'media.cmd.playlist_update'
            }
        );
    } else {

        if ( defined <media.counter.empty_list_retries> ) {
            delete <media.counter.empty_list_retries>;
            <[base.log]>->(
                0, "giving up on playlist update as it remained empty!"
            );
        }

        if ( !<media.declared_online> ) {
            <media.declared_online>++;
            <[base.async.get_session_id]>;
            <[base.log]>->(
                1,
                "reported agent as online,"
                    . " skipping sub-agent startup [empty playlist]"
            );
        }

        <[media.stop_loadsplash]> if <media.loadsplash_running>;

        <media.playlist.files> = [];
        map { <media.playlist.agent>->{$_} = [] } @{<media.display_agents>};
        foreach my $hide_agent ( keys %{<media.child>} ) {
            my $hide_wid = <media.child>->{$hide_agent}->{'window_id'};
            next if not defined $hide_wid;
            <[base.log]>->( 2, ": hiding '$hide_agent' ($hide_wid)" );
            <[base.proto.nailara.command.send.local]>->(
                {   'command'   => "core.xserver.hide_window",
                    'call_args' => { 'args' => $hide_wid }
                }
            );
            <media.child>->{$hide_agent}->{'visible'} = 0;
        }
        <media.playlist_was_empty> = 1;
        <media.playlist_sha1>      = $playlist_sha1;
        map {
            <[base.proto.nailara.command.send.local]>
                ->( { 'command' => "$_.playlist_update" } )
        } @{<media.display_agents>};
    }
    return;
}

return <[base.log]>->( 1, ": playlist not changed, doing nothing.." )
    if $playlist_sha1 eq <media.playlist_sha1>;
<media.playlist_sha1> = $playlist_sha1;

my $last_type
    = @{<media.playlist.files>}
    ? <media.playlist.types>->{ <media.playlist.files>->[0] }
    : '';

<media.playlist.files> = \@file_list;
<media.playlist.types> = \%file_types;
<media.playlist.agent>
    = { map { $_ => [] } @{<media.display_agents>} };
<media.sequence.position>     = 0;
<media.sequence.switch_order> = [];

my $index = 0;
my $last_agent;
my $first_agent;
my $switch_count = 0;
my $switched_map = {};
my $last_index   = scalar @file_list - 1;
my $new_type     = scalar @file_list ? $file_types{ $file_list[0] } : '';

foreach my $file (@file_list) {
    my $type = $file_types{$file};
    next if not exists <media.content.agent_map>->{$type};
    my $agent = <media.content.agent_map>->{$type};
    $switched_map->{$agent} //= 0;
    if ( defined $last_agent and $agent ne $last_agent ) {
        push( @{ <media.playlist.agent>->{$last_agent} }, '[PAUSE]' );
        $switched_map->{$last_agent}++;
        $switch_count++;
    }
    push( @{ <media.playlist.agent>->{$agent} }, $file );
    my $switch_agent = $agent;
    if ( not defined $last_agent or $agent ne $last_agent ) {
        if ( $index == $last_index ) {
            my $_file  = $file_list[$last_index];
            my $_type  = $file_types{$_file};
            my $_agent = <media.content.agent_map>->{$_type};
            $switch_agent = $_agent;
        }
        push( @{<media.sequence.switch_order>}, "$switch_agent" )
            if not defined $last_agent
            or $agent ne $last_agent and ( $index != $last_index
            or <media.content.agent_map>->{ $file_types{ $file_list[0] } } ne
            <media.content.agent_map>
            ->{ $file_types{ $file_list[$last_index] } } );
    }
    $first_agent = $agent if not defined $first_agent;
    $last_agent  = $agent;
    $index++;
}
push( @{ <media.playlist.agent>->{$last_agent} }, '[PAUSE]' )
    if $switch_count
    and ( !$switched_map->{$last_agent}
    or $file_types{ $file_list[0] } ne $file_types{ $file_list[$last_index] } );

<media.playlist.change_count> //= 0;
<[base.log]>->( 1, ": playlist changed.." );

if (<media.playlist.change_count>
    and ( $switch_count
        or !$switch_count and @file_list and $new_type ne $last_type )
    ) {    # temporary (anti-desync) workaround
    <[media.self_restart]>;
}
<media.playlist.change_count>++;

if ( @file_list and <media.playlist_was_empty> ) {
    <[media.self_restart]>;
} elsif (
    <media.agents_started>
    and (  !<media.cfg.fade_on_switch>
        or !$switch_count )
) {
    map {
        <[base.proto.nailara.command.send.local]>
            ->( { 'command' => "$_.playlist_update" } )
    } @{<media.display_agents>};
} elsif ( !<media.cfg.fade_on_switch> ) {
    <[media.startup_sub_agents]>;
} else {
    <[media.collect_video_frames]>;    # need to extract video frames first..
}
