# >:]

# name = root.process.get_children

my $chk_pid = shift;
if ( not defined $chk_pid or $chk_pid !~ /^\d+$/ ) {
    ( my $caller_str = [ (caller) ]->[1] ) =~ s|^.+\.||g;
    die "[$caller_str] expected parent process id";
}

### old method ### (heavy, non-portable, to be removed..)

my $proc_table = new Proc::ProcessTable;

my %ppids;
my %start_times;
foreach my $proc ( @{ $proc_table->table } ) {
    $ppids{ $proc->{'pid'} }       = $proc->{'ppid'};
    $start_times{ $proc->{'pid'} } = $proc->{'start'};
}

my %children;

my $found = 0;
foreach my $pid ( keys(%ppids) ) {
    if ( $ppids{$pid} == $chk_pid ) {
        $children{$pid}->{'checked'} = 0;
        $found++;
    }
}

while ($found) {
    $found = 0;
    foreach my $child_pid ( keys(%children) ) {
        next if $children{$child_pid}->{'checked'} == 1;
        foreach my $pid ( keys(%ppids) ) {
            if ( $ppids{$pid} == $child_pid ) {
                $children{$pid}->{'checked'} = 0;
                $found++;
            }
        }
        $children{$child_pid}->{'checked'} = 1;
    }
}

### new method ### (requires strict child registration)
my $instance_id;
map {
    $instance_id = $_
        if $chk_pid == <root.agent.instance>->{$_}->{'process'}{'id'}
} keys %{<root.agent.instance>};
if ( defined $instance_id ) {
    map { $children{$_} = 1 } ( <[root.instance_child_pids]>->($instance_id) );
}
###

return [
    sort { $start_times{$b} // 0 <=> $start_times{$a} // 0 }
    sort keys %children
];
