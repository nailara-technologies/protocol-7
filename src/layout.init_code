# >:]

# name = layout.init_code

<[base.perlmod.load]>->( 'File::Path', qw| make_path | );
<[base.perlmod.load]>->( 'FreezeThaw', qw| cmpStr | );

<list.layouts> = {
    'var'   => 'data',
    'key'   => 'layout.config.layouts',
    'mask'  => '<key>:name',
    'align' => { 'name' => 'left' },
    'descr' => 'configured layouts'
};

<layout.config_name>          //= 'default';
<layout.cfg_directory>        //= '/etc/nailara/nailara.layout';
<layout.hash_file>            //= <layout.cfg_directory> . '/layout_file.sha1';
<layout.startup.initializing> //= 1;
<layout.transition_in_progress> //= 0;
<layout.restore_layout_enabled> //= 0;
<layout.restore_layout_timeout> //= 300;    # seconds

# monitoring tile activity (colors) [default disabled]
<layout.watch_tiles.poll_tile_color>  //= 0;
<layout.watch_tiles.inactive_timeout> //= 300;
<layout.watch_tiles.inactive_action>  //= 'warn';

if ( !<layout.watch_tiles.poll_tile_color>
    and defined <layout.timer.poll_tile_color> ) {
    my $timers = <layout.timer.poll_tile_color>;
    <[base.log]>->( 0, "stopping tile activity poll timers [config changed]" );
    map { $timers->{$_}->cancel if $timers->{$_}->is_active } keys %{$timers};
}

delete <layout.config.ticker_agent_type>
    if defined <layout.config.ticker_agent_type>
    and <layout.config.ticker_agent_type> !~ /^gtk|sdl$/;
<layout.config.ticker_agent_type> //= 'gtk';

if ( !-d <layout.cfg_directory> ) {
    my $cfg_dir = <layout.cfg_directory>;
    my $perms   = '0750';
    if ( !-d $cfg_dir ) {
        <[base.log]>->( 1, "creating config directory '$cfg_dir'.. [$perms]" );
        my ( undef, undef, $uid, $gid ) = getpwnam(<system.privs.user>)
            or die "user '" . <system.privs.user> . "' not in passwd file";
        make_path( $cfg_dir,
            { mode => oct($perms), 'uid' => $uid, 'group' => $gid } )
            or die "make_path: $!";
    } else {
        my $old_perms = <[base.file_perm]>->($cfg_dir);
        if ( $old_perms ne $perms ) {
            <[base.log]>->(
                0, "<!> fixing config dir permissions [ $old_perms -> $perms ]"
            );
            chmod( oct($perms), $cfg_dir ) or warn("chmod($cfg_dir): $!");
        }
    }
}

goto skip_load if defined <layout.config.layouts>;

## loading layout configuration ##

my $config_name     = <layout.config_name>;
my $cfg_root_path   = <system.conf_path>;
my $config_filename = "agents/layout/layout-setup.$config_name";
my $config_file_path;
$config_file_path = <layout.import_path> if defined <layout.import_path>;
$config_file_path //= <system.conf_path>;
$config_file_path .= "/$config_filename";

die "<!> layout setup '$config_file_path' not found <!>"
    if !-f $config_file_path;

<[base.log]>->( 1, "<!> loading layout configuration '$config_name' <!>" );

<[file.put]>->(
    <layout.hash_file>, <[digest.sha.file_hex]>->($config_file_path) . "\n"
);
{
    local <system.conf_path> = "$cfg_root_path/agents/" . <system.agent.name>;
    <layout.config> = <[base.load_section_config]>->($config_filename);
}

<[base.log]>->( 0, "<!> layout loading not successful [ no data ] <!>" )
    if !keys %{<layout.config>};

<[base.log]>->( 0, "<!> layout loading not successful [ empty layout ] <!>" )
    if keys %{<layout.config>}
    and defined <layout.config.layouts>
    and not keys %{<layout.config.layouts>};

# use Data::Dumper 'Dumper'; print Dumper(<layout.config>);

skip_load:    # <- jumping here if layout has already been imported as json!

my $current_cfg = <layout.cfg_directory> . '/layout.current';
my $default_cfg = <layout.cfg_directory> . '/layout.default';
my $restore_layout_name;

if ( -f $default_cfg ) {

    if ( defined <layout.default_layout>
        and <layout.default_layout> ne ${ <[file.slurp]>->($default_cfg) } ) {
        <[base.log]>->( 0, "<!> default layout has changed <!>" );
        unlink($current_cfg) or warn "unlink($current_cfg): $!";

    } else {
        unlink($default_cfg) or warn "unlink($default_cfg): $!";
    }
}

if ( <layout.restore_layout_enabled> and -f $current_cfg ) {
    <[base.log]>->( 1, "loading 'layout.current' file ..." );
    my $cfg_content = ${ <[file.slurp]>->($current_cfg) };
    if ( $cfg_content =~ /^(\d+(\.\d+)?) +([^\n]+)\n$/s ) {
        ( my $t_stamp, my $layout_name ) = ( $1, $3 );
        my $timeout_secs = <layout.restore_layout_timeout>;
        my $delta_t      = sprintf( "%.4f", <[base.time]>->(4) - $t_stamp );
        if ( $delta_t >= $timeout_secs ) {
            <[base.log]>->(
                1,
                "stored layout selection has timed out (${timeout_secs}s),"
                    . " ignoring.."
            );
            unlink($current_cfg) or warn("unlink($current_cfg): $!");
        } else {
            <[base.log]>->( 2, "processing 'layout.current' config..." );

            if ( defined <layout.default_layout>
                and <layout.default_layout> ne $layout_name ) {
                <[base.log]>->(
                    0, "restoring previous layout '$layout_name'..."
                );
                $restore_layout_name = $layout_name;
            }

            my @overlays;
            @overlays = split( /\+/, $1 ) if $layout_name =~ s/\+(.+)$//;
            if (@overlays) {
                my $s = @overlays > 1 ? 's' : '';
                <[base.log]>->(
                    0,
                    "restoring previous overlay$s: "
                        . join( ', ', @overlays ) . " .."
                );
                <layout.restore.overlays> = \@overlays;
            }
        }
    } else {
        <[base.log]>->( 0, ": <!> syntax error in 'layout.current' config..." );
    }
} elsif ( -f $current_cfg and !<layout.restore_layout_enabled> ) {
    <[base.log]>->( 1, "(!) restoring of current layout is disabled (!)" );
}

<[base.log]>->( 0, "no default layout configured!" )
    if not exists <layout.default_layout>
    or not defined <layout.default_layout>
    or !length(<layout.default_layout>);

my $layout_name = $restore_layout_name // <layout.default_layout>;
my $log_level   = 1;
my $default_str = ' default ';
if ( not exists <layout.config.layouts>->{$layout_name} ) {
    my $cfg_name_str = defined $config_name ? " '$config_name'" : '';
    <[base.log]>->(
        0,
        "default layout '$layout_name' "
            . "does not exist in layout config$cfg_name_str!"
    );
    if ( -f $current_cfg ) {
        <[base.log]>->( 2, ": removing '$current_cfg' ..." );
        unlink($current_cfg) or warn "unlink($current_cfg): $!";
    }
    ($layout_name) = sort keys %{<layout.config.layouts>};
    $default_str = ' _fallback_ ';
    $log_level   = 0;
}

$default_str //= ' default ';
$layout_name //= <layout.default_layout>;
<layout.current_layout> = $layout_name;

<[base.log]>->( $log_level, "selected${default_str}layout '$layout_name'" );

if ( defined <layout.default_layout> ) {
    ( my $fname = $default_cfg ) =~ s|^.*/||g;
    <[base.log]>->(
        2, 'writing default "' . <layout.default_layout> . "\" to '$fname'.."
    );
    <[file.put]>->( $default_cfg, <layout.default_layout> );
}

map {
    <base.watcher.signal>->{$_}->cancel
        if defined <base.watcher.signal>->{$_};
    my $uc_sig = uc($_);
    delete $SIG{$uc_sig} if defined $SIG{$uc_sig};
    <base.watcher.signal>->{$_} = <[event.add_signal]>
        ->( { 'signal' => $uc_sig, 'handler' => 'layout.handler.sig_term' } );
} ( 'int', 'term', 'quit' );

0;

# ______________________________________________________________________________
#\\W6D27ECZ6444IQICTRSHBIUUTMNVIJQY2OUVDJX52WFOAVT4RHL4NYCI455KKJYBSHY6MIB2EVSGO
# \\ DXCGANTJ6D5CJEE635F74TZZ4R7LQCKCGH5GMW63AC7I73QSUUTE \\// C25519-BASE-32 //
#  \\// X4PUAWA2ZFUB4MOYCIGFOZ6LQD3T7SMMYYPNEBI4LGW5PMSWWBA \\ CODE SIGNATURE \\
#   ````````````````````````````````````````````````````````````````````````````
