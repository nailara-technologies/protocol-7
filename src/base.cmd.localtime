# >:]

# name  = base.cmd.localtime
# param = [unix|ntime[-b32]]
# descr = return local date string [in host's timezone]

my $unix_time = $$call{'args'} // time();

my $ntime_decoded;
my $utime_copy = $unix_time;

## ntime base32 case ##
eval { $ntime_decoded = decode_b32r($unix_time) }
    if $unix_time =~ m|[A-Z]|
    and length($unix_time) >= 10;

if ( defined $ntime_decoded ) { ## contains network time with arbitary precision
    my @nt_val = unpack( 'w*', $ntime_decoded );
    $nt_val[1] =~ s|^7|| if @nt_val == 2;    ## <-- saves 0 prefixes
    $unix_time = join( '.', @nt_val )        ## needs error handling
}

$unix_time = $utime_copy    # <<[?]>> deal with false positives <<[?]>>
    if $$call{'args'} =~ m|[A-Z]| and ( not defined $unix_time or $@ );

return {
    'mode' => 'nak',
    'data' => "submitted parameter string is not valid"
    }
    if $@
    or not defined $unix_time
    or $unix_time !~ /^\d{1,17}(\.\d{1,20})?$/;

$unix_time = <[base.n2u_time]>->($unix_time)
    if length( int($unix_time) ) >= 13;    # <-- nailara network time

my $subseconds = $unix_time =~ s|(\.\d+)$|| ? $1 : undef;

return {
    'mode' => 'nak',
    'data' => "queried value is out of range"
    }
    if $unix_time > 67767976233316804;

my $ltime_str = scalar localtime $unix_time;

$ltime_str =~ s| (\d\d:\d\d:\d\d) (\d{4})$| $2 $1|; # swapping time with year ##

$ltime_str .= " [ +0${subseconds} ]" if defined $subseconds;

return {
    'mode' => 'nak',
    'data' => "unix_time value is too high"
    }
    if not defined $ltime_str or !length($ltime_str);

return {
    'mode' => 'ack',
    'data' => $ltime_str
    }

# ______________________________________________________________________________
#\\6ZIRSMODUSQ62FA3SBVQAQE6OA5AHGL2SOOYGOHOUGTY3I55ATNOIANXXUZAXEU43MGLXWTRAS3YC
# \\ SPJGHUJA624HHMMVOXS3Z5JTAQZCMRENAPBMZVQNFSJ3L4K4HVA7 \\// C25519-BASE-32 //
#  \\// H6XVPDFVKIVRMB6EZ2KKWMDPGHF5XLLT3ZXWB5JHC2GF6EEMODQ \\ CODE SIGNATURE \\
#   ````````````````````````````````````````````````````````````````````````````
