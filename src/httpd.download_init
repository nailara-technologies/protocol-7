# >:]

# name = httpd.download_init

my $id;
my $params;
my $file_path;
if ( ref( $_[0] ) eq 'HASH' ) {
    $params    = shift;
    $id        = $params->{'sid'};
    $file_path = $params->{'path'};
} else {
    $id        = shift;
    $file_path = shift;
}

my $session   = $data{'session'}{$id};
my $response  = $session->{'response'};
my $request   = $session->{'http'}->{'request'};
my $client_fh = $session->{'handle'};

my $header = $params->{'header'};

$file_path = readlink($file_path) if -l $file_path and -f $file_path;    ##

my $file_stat    = File::stat::stat($file_path);
my $content_size = $header->{'Content-Length'} // $file_stat->size;
my $content_type = $header->{'Content-Type'} // mimetype($file_path);

my $content_fh;
if ( not open( $content_fh, '< :raw', $file_path ) ) {
    warn "<!> $file_path: $!";    # LLL: error handling..,
    return 2;
}

my $status_code = 200;
if ( exists $request->{'range'} ) {
    my @ranges = @{ $request->{'range'} };
    $status_code = 206;
    if ( @ranges == 1 ) {
        my $start = $ranges[0]->{'start'};
        my $end   = $ranges[0]->{'end'};
        sysseek( $content_fh, $start, 0 ) if $start;
        $header->{'Content-Range'}  = "bytes $start-$end/$content_size";
        $header->{'Content-Length'} = $content_size = 1 + $end - $start;
    } else {
        <[base.log]>->(    # LLL: implement multipart byte ranges..,
            0, "[$id] multiple range segments requested [ Not Implemented ]"
        );
        close($content_fh);
        return <[httpd.send_error_page]>->( $id, 501 );
    }
}

<[base.log]>->(
    1, "[$id] initializing transfer of $content_size bytes [$content_type]"
);

if ( $session->{'http'}->{'close'} ) {
    $session->{'watcher'}->{'input_handler'}->cancel;
} else {
    $session->{'watcher'}->{'input_handler'}->timeout(undef);
}

$session->{'buffer'}->{'output'}
    .= <[httpd.new_header]>->( $status_code, $header );

$session->{'download'} = {
    'content_fh'  => $content_fh,
    'bytes_to_go' => $content_size,
};

<[httpd.update_download_count]>;

$session->{'watcher'}->{'download_handler'} = <[event.add_io]>->(
    {   'fd'         => $client_fh,
        'handler'    => 'httpd.handler.download_transfer',
        'poll'       => 'w',
        'prio'       => 4,
        'timeout'    => <httpd.timeout> * 3,
        'timeout_cb' => sub {
            <[base.log]>->( 1, "[$id] file download timed out.," );
            $data{'session'}{$id}{'shutdown'} = 1;
        },
        'data' => { 'id' => $id }
    }
);

$session->{'watcher'}->{'download_handler'}->now;

return 0;

# ______________________________________________________________________________
#\\PL7EQO5TIGLIR3AOQJKQIGCLHLAFV4EFE75OZC444KUTHBCPANRCIAJIJ56WQJ3EJP4LAGWGR24MW
# \\ MSMP5I3SEPTDLS5VRXXVCTJTZGXFXM3JVQMNQ4PDSZGBJWUYSOSQ \\// C25519-BASE-32 //
#  \\// G5GJTG4AZ5OU5S64JTBS62HWWP672US5KBPO4TMHAO5WZP6Z2DA \\ CODE SIGNATURE \\
#   ````````````````````````````````````````````````````````````````````````````
