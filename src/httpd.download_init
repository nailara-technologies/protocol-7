# >:]

# name = httpd.download_init

my $id;
my $params;
my $file_path;
if ( ref( $_[0] ) eq 'HASH' ) {
    $params    = shift;
    $id        = $params->{'sid'};
    $file_path = $params->{'path'};
} else {
    $id        = shift;
    $file_path = shift;
}

my $session   = $data{'session'}{$id};
my $response  = $session->{'response'};
my $request   = $session->{'http'}->{'request'};
my $client_fh = $session->{'handle'};

my $stat
    = ( defined $params and defined $params->{'stat'} and ref($params) )
    ? $params->{'stat'}
    : [ stat($file_path) ];

my $content_size = $stat->[7];
my $content_date = time2str( $stat->[9] );
my $server_date  = time2str(time);

my $content_type;
if ( $file_path =~ /\.htm(l)?$/ ) {
    $content_type = 'text/html';
} else {
    $content_type = mimetype($file_path);
}

my $content_fh;
if ( not open( $content_fh, '< :raw', $file_path ) ) {
    warn "<!> $file_path: $!";    # XXX: error handling...
    return 2;
}

my $status_code = 200;
if ( exists $request->{'range'} ) {
    my @ranges = @{ $request->{'range'} };
    $status_code = 206;
    if ( @ranges == 1 ) {
        my $start = $ranges[0]->{'start'};
        my $end   = $ranges[0]->{'end'};
        sysseek( $content_fh, $start, 0 ) if $start;
        $response->{'params'}->{'Content-Range'}
            = "bytes $start-$end/$content_size";
        $content_size = 1 + $end - $start;
    } else {
        <[base.log]>->(    # XXX: implement multipart byte ranges...
            0, "[$id] multiple range segments requested ( Not Implemented! )"
        );
        close($content_fh);
        return <[httpd.error_page]>->( $id, 501 );
    }
}

<[base.log]>->(
    1, "[$id] initializing transfer of $content_size bytes [$content_type]"
);

if ( $session->{'http'}->{'close'} ) {
    $session->{'watcher'}->{'input_handler'}->cancel;
} else {
    $session->{'watcher'}->{'input_handler'}->timeout(undef);
}

$session->{'download'} = {
    'content_fh'  => $content_fh,
    'bytes_to_go' => $content_size,
};

$session->{'buffer'}->{'output'} .= <[httpd.new_header]>->(
    $status_code,
    {   'Content-Type'   => $content_type,
        'Last-Modified'  => $content_date,
        'Content-Length' => $content_size,
        'Connection'     => $session->{'http'}->{'close'}
        ? 'close'
        : 'keep-alive',
        'Accept-Ranges' => 'bytes',
        %{ $response->{'params'} }
    }
);

$session->{'watcher'}->{'download_handler'} = <[event.add_io]>->(
    {   'fd'         => $client_fh,
        'handler'    => 'httpd.handler.download_transfer',
        'poll'       => 'w',
        'prio'       => 4,
        'timeout'    => <httpd.timeout> * 3,
        'timeout_cb' => sub {
            <[base.log]>->( 1, "[$id] file download timed out!" );
            $data{'session'}{$id}{'shutdown'} = 1;
        },
        'data' => { 'id' => $id }
    }
);

return 0;
