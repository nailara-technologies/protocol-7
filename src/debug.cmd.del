# >:]

# name  = debug.cmd.del
# param = <key>
# descr = delete a %data key

my $del_key = $$call{'args'};
my $cid     = $$call{'session_id'};

return { 'mode' => 'nack', 'data' => 'no key specified' }
    if not defined $del_key or !length($del_key);
return { 'mode' => 'nack', 'data' => 'invalid key' }
    if $del_key =~ /^\.|\.$/
    or $del_key !~ /^[\w\d_\-\[\]\.']+$/
    or $del_key =~ /~\0/;
my $_del_key = $del_key;
$_del_key =~ s/'(([^']|\.)+)'/my$k=$1;$k=~s|\.|\0|g;$k/ge;
return { 'mode' => 'nack', 'data' => 'invalid key' } if $_del_key =~ /\'/;

my $del_key_ref = <[base.resolve_key]>->($del_key);
if ( not defined $del_key_ref ) {
    <[base.log]>->( 0, "[$cid] del: no such key ($del_key)" );
    return { 'mode' => 'nack', 'data' => 'no such key' };
}

my $deleted    = 0;
my $parent_ref = <[base.resolve_key_parent]>->($del_key);

my @del_key_chain = split /\./, $_del_key;
map { $_ =~ s/\0/./g } @del_key_chain;

while ( my $sub_key = pop(@del_key_chain) ) {
    $deleted++ if !$deleted and delete $parent_ref->{$sub_key};
    $_del_key =~ s/\.\Q$sub_key\E$//;
    my $key_ref = <[base.resolve_key]>->($_del_key);
    $deleted++ if delete $$key_ref->{$sub_key};
    $deleted++
        if !@del_key_chain
        and ref( $data{$sub_key} ) eq 'HASH'
        and !keys %{ $data{$sub_key} }
        and delete $data{$sub_key};
    last if keys %{$$key_ref};
}

if ($deleted) {
    <[base.log]>->( 1, "[$cid] del: key \"$del_key\" deleted" );
    return { 'mode' => 'ack', 'data' => 'deleted' };
} else {
    <[base.log]>->( 0, "[$cid] del: failed to delete key \"'$del_key\"" );
    return { 'mode' => 'nack', 'data' => 'failed' };
}
