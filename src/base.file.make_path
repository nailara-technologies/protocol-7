# >:]

# name  = base.file.make_path
# descr = recursively create a directory path

my ( $path, $mode, $owner ) = @_;
$mode //= 0700;    # <- strict default
$mode = oct($mode) if $mode =~ m|^0|;
die "expected absolute path [ to create ]"
    if not defined $path or $path !~ m|^/[^/]+|;

$path =~ s|/[^/]+/\.\./||g;
$path =~ s|//|/|g;
$path =~ s|/$||;

die "invalid path '$path'" if $path !~ m|^/[^/]+|;

if ( -d $path ) {
    <[base.log]>->( 2, ":. present =) .: ['$path']" );
    return $path;
}

my ( $uid, $gid );
if ( defined $owner ) {
    die "invalid username '$owner'" if $owner !~ <regex.base.usr>;
    ( undef, undef, $uid, $gid ) = getpwnam($owner)
        or die "owner $owner not in passwd file";
}

my $install_root = <system.root_path>;
( my $report_path = $path ) =~ s|^$install_root/?||;

<[base.log]>->( 2, ":. creating.. .: ['$report_path']" );

my $current_path = '';
foreach my $_dir ( split m|/|, $path ) {
    next if !length($_dir);
    $current_path .= '/' . $_dir;
    next if -d $current_path;

    mkdir( $current_path, $mode ) or die " mkdir '$current_path' : [ $! ]";
    if ( defined $owner ) {
        chown( $uid, $gid, $current_path )
            or die " chown [$uid:$gid] '$current_path' : [ $! ]";
    }
}

return $path;

# ______________________________________________________________________________
#\\QE4X756XO6JFIZ53QVQNUC4LHU5HPDR6BZQSFPNZW6R2FELTFWLVWTB26IHSOV25JK5NAIVVOHGMM
# \\ V4BIKYILTNAFVDAVARAUSXFFVZRTM2NWEIOXGABYWZ4NL2Z33EMD \\// C25519-BASE-32 //
#  \\// RQU3EO7NK7VKXZ7F23WBWGHP32RI644PH4H34OTS7IERJFHRMBQ \\ CODE SIGNATURE \\
#   ````````````````````````````````````````````````````````````````````````````
