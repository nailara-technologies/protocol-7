# >:]

# name  = base.file.make_path
# descr = recursively create a directory path

my ( $path, $mode, $owner ) = @_;
$mode //= 0700;    # <- strict default
$mode = oct($mode) if $mode =~ m|^0|;
die "expected absolute path [ to create ]"
    if not defined $path or $path !~ m|^/[^/]+|;

$path =~ s|/[^/]+/\.\./||g;
$path =~ s|//|/|g;
$path =~ s|/$||;

die "invalid path '$path'" if $path !~ m|^/[^/]+|;

if ( -d $path ) {
    <[base.log]>->( 2, ":. present =) .: ['$path']" );
    return $path;
}

my ( $uid, $gid );
if ( defined $owner ) {
    die "invalid username '$owner'" if $owner !~ <regex.base.usr>;
    ( undef, undef, $uid, $gid ) = getpwnam($owner)
        or die "owner $owner not in passwd file";
}

my $install_root = <system.root_path>;
( my $report_path = $path ) =~ s|^$install_root/?||;

<[base.log]>->( 2, ":. creating.. .: ['$report_path']" );

my $current_path = '';
foreach my $_dir ( split m|/|, $path ) {
    next if !length($_dir);
    $current_path .= '/' . $_dir;
    next if -d $current_path;

    mkdir( $current_path, $mode )
        or die " mkdir '$current_path' : [ $OS_ERROR ]";
    if ( defined $owner ) {
        chown( $uid, $gid, $current_path )
            or die " chown [$uid:$gid] '$current_path' : [ $OS_ERROR ]";
    }
}

return $path;

# ______________________________________________________________________________
#\\4Z7672QNU4U2N4JMU7MGK4AGVVZMOF6HDCD4VA4FG3WQCCNX4IIH7YV75O5WWQLV4KRYDQUCBTBIW
# \\ XICNDE5J5PBI4544VVP356KRSTFMSKBE36JQ3SCEL6MOHPKOR5LF \\// C25519-BASE-32 //
#  \\// ZOTYR6GR2PWZPV3GZ5PL6W3K3UGU4SUXGMBJXRKG4WR5Z5HDWDQ \\ CODE SIGNATURE \\
#   ````````````````````````````````````````````````````````````````````````````
