# >:]

# name  = playlist.cmd.get_list_types
# param = [type]
# descr = return current playlist items (with types)

my $subname;
my %file_types;
my $reply_string   = '';
my $type_list      = <playlist.file_types>;
my $file_types_str = $$call{'args'} || '';
$subname = $1 if $file_types_str =~ s| *\[([^\]]+)\]$||;

map { $file_types{$_} = 1 } split / +/, $file_types_str;

my $index = -1;
foreach my $file ( @{<playlist.file_list>} ) {
    $index++;
    next
        if defined $subname
        and exists <playlist.agent_subnames>->{$index}
        and not exists <playlist.agent_subnames>->{$index}->{$subname};
    next
        if defined <playlist.b8id>->{$index}
        and grep {/^$data{playlist}{b8id}{$index}$/} @{<playlist.hidden_b8id>};

    my @url_flags;
    map {
        if ( exists <playlist.url_flags>->{$_}->{$file} ) {
            my $flag_str = $_;
            $flag_str .= '=' . <playlist.url_flags>->{$_}->{$file}
                if $_ eq 'delay';
            push( @url_flags, $flag_str );
        }
        }
        keys %{<playlist.url_flags>};
    my $url_flags_str
        = @url_flags ? '#[' . uc( join( '|', sort @url_flags ) ) . ']#' : '';

    my $type_str = $type_list->{$file};
    foreach my $req_type ( keys %file_types ) {
        $reply_string .= "$type_str $file$url_flags_str\n"
            if !length($req_type)
            or index( $type_str, $req_type ) != -1;
    }

    $reply_string .= "$type_str $file$url_flags_str\n" if !keys(%file_types);
}

return { 'mode' => 'raw', 'data' => $reply_string }
