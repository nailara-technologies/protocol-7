# >:]

# name = playlist.handler.weather_urls_reply

my $reply = shift;

if ( $reply->{'cmd'} eq 'NAK' ) {
    return <[base.log]>->(
        0, "failed to fetch url [" . $reply->{'call_args'}->{'args'} . "]"
    );
}

my $city    = $reply->{'params'}->{'city'};
my $subname = $reply->{'params'}->{'subname'};
$reply->{'data'} =~ s|\n$||;
my @weather_urls = split( /\n/, $reply->{'data'} );
map { $_ =~ s|^file://|| } @weather_urls;

my $changes = 0;
my @new_list;

my $file_index = 0;
foreach my $list_item ( @{<playlist.file_list>} ) {
    my $type = <playlist.file_types>->{$list_item};
    next if not defined $type;
    if ( $type eq ':waiting:' and $list_item =~ /^\[weather:$city\]$/ ) {
        <[base.log]>->( 1, "received weather urls for '$city'.." );
        delete <playlist.file_types>->{$list_item};
        delete <playlist.agent_subnames>->{$file_index}
            if defined <playlist.agent_subnames>->{$file_index};
        push( @new_list, @weather_urls );

        if ( defined <playlist.agent_subnames>
            and @{<playlist.file_list>} > ( $file_index + 1 ) ) {
            my $index_offset = @weather_urls;
            my $file_count   = @{<playlist.file_list>};
            foreach
                my $idx_2 ( reverse( ( $file_index + 1 ) .. $file_count - 1 ) )
            {
                <playlist.agent_subnames>->{ $idx_2 + $index_offset - 1 }
                    = delete <playlist.agent_subnames>->{$idx_2};
            }
        }
        my $content_type = 'html';
        map {
            <playlist.file_types>->{$_} = $content_type;
            <playlist.type_cache>->{$_} = $content_type
                if <playlist.cfg.cache_content_types>;
            <playlist.agent_subnames>->{$file_index}->{$subname} = 1
                if defined $subname;
            $file_index++;
        } @weather_urls;

        $changes++;
    } else {
        push( @new_list, $list_item );
        $file_index++;
    }
}

if ($changes) {
    <playlist.file_list> = \@new_list;
    <[base.log]>->( 1, "weather urls added to playlist, updating..." );

    # LLL: extract to seperate subroutine:
    my $update_cmd = <update.notify_command> || 'playlist_update';
    my $count = 0;
    map {
        # LLL: check agent name syntax [+response]!
        <[base.proto.nailara.command.send.local]>
            ->( { 'command' => "core.$_.$update_cmd" } );
        $count++;
    } split( / +/, <update.notify_agents> );
    my $s = $count == 1 ? '' : 's';
    my $notify_str = $count ? ", $count agent$s notified" : '';
    <[base.log]>->( 1, 'playlist updated' . $notify_str );
}
