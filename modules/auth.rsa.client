# >:]

# name       = auth.rsa.client

my $new_cipher = 'twofish';
my ( $backend_socket, $smiley, $answer ) = ( $_[0], '', '' );
my $id = $data{'handle'}{ $_[0] }{'cid'};

&{$code{'base.log'}}(0, "no client id 'cid' for $_[0], no initialized session?") if
    not defined $id or !$id;

my $key_id = 0;    ###

my $output = \$data{'session'}{$id}{'buffer'}{'output'};

if ( sysread( $backend_socket, $smiley, 4 ) ) {
    if ( $smiley =~ />:\]\n/ ) {
        &{ $code{'base.log'} }( 1, '[*] smiley ok :)' );
    } else {
        &{ $code{'base.log'} }( 1, '[#] no valid smiley found! :(' );
        return undef;
    }
    &{ $code{'base.log'} }( 1, '[#] selecting rsa authentication' );
    &{ $code{'net.out'} }( $backend_socket, "select rsa\n" );
    if ( sysread( $backend_socket, $answer, 42 ) ) {

        if ( $answer =~ /^ACK continue\n$/ ) {
            &{ $code{'base.log'} }( 1, '[+] requesting rsa public key..' );
            &{ $code{'net.out'} }( $backend_socket, "get key\n" );

            $answer = '';

            if ( sysread( $backend_socket, $answer, 23542, length($answer) ) ) {

                my $key_data_length = 0;

                if ( $answer =~ s/RAW (\d+)\n// ) {
                    $key_data_length = $1;

                    if ( length($answer) == $key_data_length ) {
                        &{ $code{'base.log'} }( 1, '[+] pub key received.' );

                        my $rsa_pub;

                        if ( eval '$rsa_pub = '
                            . 'Crypt::OpenSSL::RSA->new_public_key($answer)' ) {

                            &{ $code{'base.log'} }( 1, '[+] pub key is valid.' );
                            $rsa_pub->use_pkcs1_oaep_padding();
                            $rsa_pub->use_sha512_hash();
                            my $sk_size = 256;

                            &{ $code{'base.log'} }( 1,
                                "[+] generating $sk_size bit session key..");
                            my $session_key =
                              &{ $code{'crypt.random.bytes'} }( int( $sk_size / 8 ) );

                            $answer = '';

                            my $ciphered = $rsa_pub->encrypt($session_key);
                            my $hex_key = unpack( "H*", $ciphered );
                            &{ $code{'base.log'} }( 1, "[+] transferring key to peer..");
                            &{ $code{'net.out'} }( $backend_socket, "set secret $hex_key\n" );

                            if ( sysread( $backend_socket, $answer, 4096, length($answer) ) ) {

                                if ( $answer =~ s/^ACK session key set.\n$// ) {
                                    &{ $code{'base.log'} }(
                                        0, '[+] session key has been accepted.'
                                    );

                                    &{ $code{'net.out'} }(
                                        $backend_socket, "set cipher $new_cipher\n"
                                    );

                                    if ( sysread( $backend_socket, $answer,
					    4096, length($answer) ) ) {

                                        if ( $answer =~ /^ACK ([^\n]+)$/ ) {
                                            &{ $code{'base.log'} }(
                                                0, "[+] initializing $new_cipher chain.."
                                            );

                                            $data{'handle'}{ $_[0] }
                                              {'encryption'} = $new_cipher;
                                            $data{'handle'}{ $_[0] }
                                              {'session_key'} = $session_key;

                                            my $enc_filter =
                                              &{ $code{'filter.add_filter'} }(
                                                "${new_cipher}_enc",
                                                "crypt.$new_cipher.encrypt",
                                                $key_id
                                              );
                                            my $dec_filter =
                                              &{ $code{'filter.add_filter'} }(
                                                "${new_cipher}_dec",
                                                "crypt.$new_cipher.decrypt",
                                                $key_id
                                              );

                                            my $chain_in =
                                              &{ $code{
                                                    'filter.compile_chain'} }(
                                                'twofish_dec', $dec_filter );
                                            my $chain_out =
                                              &{ $code{
                                                    'filter.compile_chain'} }(
                                                'twofish_enc', $enc_filter );

                                        } elsif ( $answer =~ /^NACK (.+)\n$/ ) {
                                            &{ $code{'base.log'} }( 1,
                                                "[#] cipher not accepted by remote host. [$1]"
                                            );
                                        }

                                    } elsif ( $answer =~ /^NACK (.+)\n$/ ) {
                                        &{ $code{'base.log'} }(
                                            1, '[#] session key has been rejected. [$1]'
                                        );
                                    }
                                } elsif ( $answer =~ s/^NACK ([\w\s\.\,\-]+)\n$// ) {
                                    &{ $code{'base.log'} }(
                                        0, "[#] failed to agree on session key [ '$1' ] !"
                                    );
                                }
                                else {
                                    &{ $code{'base.log'} }(0,'[#] protocol error :(');
                                }
                            }
                        } else {
                            &{ $code{'base.log'} }( 0, "[#] received rsa key is invalid!" );
                        }

                    } else {
                        &{ $code{'base.log'} }( 1, '[#] pub key size mismatch' );
                    }
                }
                return $backend_socket;
            }
        } elsif ( $answer =~ /^NACK ([^\n]+)$/ ) {
            &{ $code{'base.log'} }( 1, '[#] auth method rejected :( [$1]' );
            return undef;
        } else {
            &{ $code{'base.log'} }( 0, '[#] protocol error :(' );
            return 0;
        }
    }
}
