## >:] ##

# name  = base.exit
# descr = end zenka process, has optional command-reply handler mode

my $exit_msg;
my $log_level;
my $exit_code;

## called as protocol-7 reply-handler ##
##
if ( ref( $ARG[0] // '' ) eq qw| HASH | and exists $ARG[0]->{'cmd'} ) {
    my $reply_p = shift;

    $exit_code = $reply_p->{'return-code'}
        if defined $reply_p->{'return-code'};

    $exit_msg = $reply_p->{'log-message'}
        if defined $reply_p->{'log-message'};

    $log_level = $reply_p->{'log-lvl'} if defined $reply_p->{'log-lvl'};

    if ( $reply_p->{'cmd'} eq qw| FALSE | ) {   ##  warn on command errors  ##
        if ( not exists $reply_p->{'ignore-errors'} ) {
            $exit_code = 1;
            $log_level = 0;
            $exit_msg  = $reply_p->{'call_args'}->{'args'};
        }
    } else {
        $exit_msg //= sprintf( ': success : %s',
            $reply_p->{'call_args'}->{'args'} );
    }

} else {    ## regular procedural mode ##

    $exit_code = shift @ARG if @ARG and $ARG[0] =~ m|^\d+$|;
    ( $exit_msg, $log_level ) = @ARG;
}

$exit_code //= 0;
$log_level //= 1;
$exit_msg  //= sprintf( '.. exit [ %s ] called .,', $exit_code );

<[base.log]>->( $log_level, $exit_msg );

##  resetting terminal input  ##
eval 'ReadMode(0)' if defined &main::ReadMode;

##  resetting terminal output  ##
print STDOUT $colors{'reset'};
print STDERR $colors{'reset'};

CORE::exit($exit_code);

#,,,.,,,.,,.,,,,,,,..,...,..,,.,.,..,,..,,,..,..,,...,...,,,.,,,.,,,,,,,,,,,,,
#UVR2O7KAXSWNG4PUQEOETU5CUF7YKQCP237R4BKGC5WV2PQRB2ANMKIVMVUDCG2I63DO5B4VJZR4W
#\\\|L4T77SBRD5XJ6EJGWHTGLQ5SZKOTOUJYS3QXNXJJS53USA5EOF5 \ / AMOS7 \ YOURUM ::
#\[7]VGQWV5RKVWFVVHQWUTMIERLJRAJF7NRL4YAC2CCIIZPB53WQEMDI 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
