# >:]

# name = browser.load_uri

return if defined <browser.shutdown> and <browser.shutdown>;

my $load_uri = shift;

if ( not defined $load_uri or !length($load_uri) ) {
    <[base.log]>->( 0, "load_uri: uri parameter required!" );
    return;
}

if (<window.scrolling>) {
    <window.scroll.stop>          = 1;
    <browser.slideshow.running>   = 0;
    <browser.load_at_scroll_stop> = $load_uri;
    return;
}

$load_uri = "file://$load_uri" if $load_uri =~ m|^/|;
$load_uri = "http://$load_uri" if $load_uri !~ m|^\w+:|;

my $bg_index = <browser.overlay.index.bg>;
my $view     = <browser.gtk_obj.view>->{$bg_index};

<browser.current_view> = $view;
<browser.url_flags>    = {};

if ( $load_uri =~ s|#\[([\w+\_\|]+)\]#$|| ) {
    map { <browser.url_flags>->{ lc($_) } = 1 } split( /\|/, $1 );
}

<browser.load_uri> = $load_uri;

<[browser.process_url_flags]>;

<[base.log]>->( 2, "loading uri '$load_uri'.." );

<browser.time.load_start> = <[base.time]>->(3);

if ( not <browser.zoom_text_only> and defined <browser.skip_content_zoom_path> )
{
    my $skip_pattern = qr{^file://<browser.skip_content_zoom_path>};
    if ( $load_uri =~ $skip_pattern ) {
        $view->set_full_content_zoom(0);
    } else {
        $view->set_full_content_zoom(1);
    }
}

<browser.signal_id.load_status> = $view->signal_connect(
    'notify::load-status' => $code{'browser.handler.load_status_signal'} );

<browser.signal_id.load_timeout>
    = Glib::Timeout->add_seconds( 1, $code{'browser.handler.load_timeout'},
    undef, 10 );

# store current url in /tmp in case browser engine segfaults
my $url_file     = '/tmp/.nailara.browser.' . $$;
my $file_content = "current_url : $load_uri\nurl_flags   : "
    . join( ', ', sort keys %{<browser.url_flags>} ) . "\n";
<[file.put]>->( $url_file, $file_content ) or warn "$url_file: $!";
#

$view->load_uri($load_uri);

return 0;
