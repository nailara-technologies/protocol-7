# >:]

# name = browser.load_uri

my $load_uri = shift;

if ( not defined $load_uri or !length($load_uri) ) {
    <[base.log]>->( 0, "load_uri: uri parameter required!" );
    return;
}

$load_uri = "file://$load_uri" if $load_uri =~ m|^/|;
$load_uri = "http://$load_uri" if $load_uri !~ m|^\w+:|;

my $bg_index = <browser.overlay.index.bg>;
my $view     = <browser.gtk_obj.view>->{$bg_index};

<[browser.cmd.scroll_stop]> if <window.scolling>;

<[base.log]>->( 2, "loading uri '$load_uri'.." );

<browser.time.load_start> = <[base.time]>->(3);
<browser.load_uri>        = $load_uri;

if ( not <browser.zoom_text_only> and defined <browser.skip_content_zoom_path> )
{
    my $skip_pattern = qr{^file://<browser.skip_content_zoom_path>};
    if ( $load_uri =~ $skip_pattern ) {
        $view->set_full_content_zoom(0);
    } else {
        $view->set_full_content_zoom(1);
    }
}

<browser.signal_id.load_status> = $view->signal_connect(

    'notify::load-status' => sub {

        my $view        = shift;
        my $bg_index    = <browser.overlay.index.bg>;
        my $frame       = $view->get_main_frame;
        my $load_uri    = <browser.load_uri>;
        my $n_res       = $frame->get_network_response;
        my $message     = $n_res->get_message;
        my $load_status = $view->get_load_status;
        my $title       = $view->get_title // '';
        my $status_code
            = defined $message ? $message->get('status-code') : undef;

        return if $load_status ne 'finished' and $load_status ne 'failed';

        my $signal_id_load_status  = delete <browser.signal_id.load_status>;
        my $signal_id_load_timeout = delete <browser.signal_id.load_timeout>;

        Glib::Source->remove($signal_id_load_timeout)
            if defined $signal_id_load_timeout;

        if (    $load_status eq 'finished'
            and defined $status_code
            and $status_code =~ /^(20)?0$/ ) {

            <browser.time.load_finished> = <[base.time]>->(3);
            my $load_time = sprintf( "%.2f",
                <browser.time.load_finished> - <browser.time.load_start> );
            <[base.log]>->( 2, "[$load_uri] loaded in $load_time seconds." );

            $view->signal_handler_disconnect($signal_id_load_status);

            <browser.fade.reply_mode> = 'ack';
            <browser.fade.reply_msg>  = 'finished loading';

            my $swap_delay
                = exists <browser.time.scroll_complete>
                ? <browser.slideshow.swap_delay>
                - ( <[base.time]>->(3) - <browser.time.scroll_complete> )
                : 0;
            $swap_delay = 0 if $swap_delay < 0;
            <browser.timer.swap_views> = <[event.add_timer]>->(
                {   'after'   => $swap_delay,
                    'handler' => 'browser.swap_views'
                }
            );

        } else {
            $view->signal_handler_disconnect($signal_id_load_status)
                if defined $signal_id_load_status;

            $view->signal_handler_disconnect(
                delete <browser.signal_id.load_progress> )
                if exists <browser.signal_id.load_progress>;

            my $st_txt = defined $status_code ? " ($status_code)" : '';
            my $reason_txt = $st_txt;

            $reason_txt .= " [$title]" if $title eq '404 Not Found';
            $reason_txt = " [$1]"
                if $title =~ /^proxy error:.+failed: ([\w\.\:\/\s]{1,42})\.$/i;

            if (    <browser.init_proxy>
                and not defined $status_code
                and !length($reason_txt)
                and !length($title) ) {
                my $check_sock = IO::Socket::INET->new(
                    PeerAddr => <browser.cfg.proxy_addr>,
                    PeerPort => <browser.cfg.proxy_port>,
                    Proto    => 'tcp',
                    Timeout  => 0.2
                );
                if (   not defined $check_sock
                    or !-S $check_sock
                    or !$check_sock->connected() ) {
                    $reason_txt = ' [proxy unreachable!]';
                } else {
                    $check_sock->close();
                }
            }

            <[base.log]>->( 0, "failed to load uri '$load_uri'" . $reason_txt );

            <browser.slideshow.temp_delay> = <browser.slideshow.err_delay>;

            <browser.fade.reply_mode> = 'nack';
            <browser.fade.reply_msg>  = 'loading failed';

            #<[base.callback.cmd_reply]>->(
            #    $reply_id,
            #    { 'mode' => 'nack', 'data' => "failed to load" . $reason_txt }
            #);
            my $fail_page_ref = <[file.slurp]>->(<browser.error_page>);
            $$fail_page_ref =~ s|\[ERR_MSG\]|<locales.string.failed_to_load>|sg;
            Glib::Idle->add(
                sub {
                    my $bg_index = <browser.overlay.index.bg>;
                    my $bg_view  = <browser.gtk_obj.view>->{$bg_index};
                    $bg_view->load_string( $$fail_page_ref, 'text/html',
                        'UTF-8', '' );
                    <[browser.swap_views]>;
                    return 0;
                }
            );
        }
    }
);

<browser.signal_id.load_timeout> = Glib::Timeout->add_seconds(
    <browser.cfg.load_timeout>,
    sub {
        my $bg_index = <browser.overlay.index.bg>;
        my $view     = <browser.gtk_obj.view>->{$bg_index};
        my $load_uri = <browser.load_uri>;
        <[base.log]>->( 0, "load timeout for '$load_uri', aborting.." );
        $view->stop_loading();
        return 0;
    },
    undef,
    -10
);

$view->load_uri($load_uri);
