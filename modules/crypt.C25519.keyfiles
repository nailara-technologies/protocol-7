## [:< ##

# name  = crypt.C25519.keyfiles
# descr = return all \ requested keyfiles for current user
# todo  = root keys must be included ..,

my $name       = shift;    ##  optional  ##
my $type_param = shift;    ##  optional  ##

if ( defined $type_param and $type_param !~ m{(encrypted|plain)} ) {
    <[base.s_warn]>->(
        'type %s not recognized [encrypted|plain]', $type_param
    );
    return undef;
}

my $key_vars_ref = <[crypt.C25519.key_vars]>;

my $key_dir = $key_vars_ref->{'key_dir'};
my $key_usr = $key_vars_ref->{'usr_name'};

my $keys_re   = <crypt.C25519.regex>;
my $re_kfiles = $keys_re->{'key_files'};

my @k_files;

foreach my $file ( grep {m{$re_kfiles}} <[file.all_files]>->($key_dir)->@* ) {
    next if defined $name and $name ne <[crypt.C25519.get_keyname]>->($file);

    if ( not defined $type_param ) {
        push @k_files, $file;
    } elsif ( $type_param eq qw| encrypted | ) {
        push @k_files, $file if <[crypt.C25519.encrypted_key]>->($file);
    } elsif ( $type_param eq qw| plain | ) {
        push @k_files, $file if not <[crypt.C25519.encrypted_key]>->($file);
    }

    last if defined $name;    ## skip rest \ have matched key ##
}

return <[base.sort]>->(@k_files);

#,,.,,.,.,.,,,..,,.,,,.,,,,,,,,.,,,..,,,,,,.,,..,,...,...,..,,,.,,,,,,,,.,,.,,
#OBRQ72CPRIVH6XTABW5E4IQSH44MB3PJEB6ZPWENBFFBUHDCDNDGE72XY62CW4CU3YI4MF5PS6SIM
#\\\|42XUYNR4D2EOYBAIIDC5UL22J7IXOXLHOJZ4NJR2HGDCQI33IRU \ / AMOS7 \ YOURUM ::
#\[7]HWGLUHKWJ5DR55ZKQIUR3ERBYMSJJJD3L2IHAFS35CCIF7HDA6DY 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
