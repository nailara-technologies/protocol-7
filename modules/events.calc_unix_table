# >:]

# name = events.calc_unix_table

<events.unix.timetable> = {};

my $new_events = 0;
<[base.log]>->( 2, "[re]calculating (unix) timetable.." );

# use event ID if its name was not defined
map { <events.timetable>->{$_}->{'name'} //= $_ } keys( %{<events.timetable>} );

foreach my $ev_id ( keys( %{<events.timetable>} ) ) {
    my $ev_name = <events.timetable>->{$ev_id}->{'name'};

    next if exists <events.unix.timetable>->{$ev_id};
    $new_events++;

    my $hour_or_day = 86400;    # day (seconds)

    my %time_str;
    map {
        $time_str{$_} = <events.timetable>->{$ev_id}->{$_}
            if defined <events.timetable>->{$ev_id}->{$_};
        $hour_or_day = 3600 if $time_str{$_} =~ /HH/; # <- special 'hourly' case
    } ( 'start', 'end' );

    ## special syntax 'HH' == current hour ##
    my $current_hour = strftime( "%H", localtime(time) );
    map { $time_str{$_} =~ s|HH|$current_hour| } keys %time_str;

    foreach my $key ( 'start', 'end' ) {
        if ( $key eq 'start'
            and not defined $time_str{$key} ) {
            <[base.log]>->(
                0,
                "<!> event '$ev_name' start not defined in time table, skipped!"
            );
            next;
        }
        my $time;
        if ($key eq 'end'    # 'duration' used instead of 'end'
            and not defined $time_str{$key}
            and defined <events.timetable>->{$ev_id}->{'duration'}
            ) {
            $time = $time_str{'start'}
                + <events.timetable>->{$ev_id}->{'duration'};
        } else {
            $time = str2time( $time_str{$key} );
        }
        if ( not defined $time ) {
            <[base.log]>->(
                0,
                "<!> '$key' value for event '$ev_name' is undefined, skipped!"
            );
            next;
        }

        my $time_now = <[base.time]>->(5);
        $time_now++ if $time_now !~ /\./;

        my $utime_start = str2time( $time_str{'start'} );
        my $utime_end   = str2time( $time_str{'end'} );

        # event passed already, prepare one on next hour/day
        if (    $utime_start < $time_now
            and $utime_end < $time_now ) {
            $time += $hour_or_day

        } elsif (
            $key eq 'start'    # 'start' is previous hour/day
            and $utime_start > time
            and $utime_end > time
            and $utime_end < $utime_start
            ) {

            $time -= $hour_or_day;

        } elsif (
            $key eq 'end'      # 'end' is next hour/day
            and <events.unix.timetable>->{$ev_id}->{'start'} > time
            and $utime_end < $utime_start
            ) {

            $time += $hour_or_day;
        }

        # 'start' events will be triggered again on restart if they're <= time !
        <events.unix.timetable>->{$ev_id}->{'start'} = $time
            if $key eq 'start';
        <events.unix.timetable>->{$ev_id}->{'end'} = $time
            if $key eq 'end';
    }
}
<[base.log]>->( 2, ": nothing to do.." ) if !$new_events;
