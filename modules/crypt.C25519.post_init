## [:< ##

# name = crypt.C25519.post_init
# note = use <crypt.C25519.base_key_name> to override the '<user>.base' pattern

my $key_vars_ref = <[crypt.C25519.key_vars]>;

my $uid          = $key_vars_ref->{'uid'};
my $gid          = $key_vars_ref->{'gid'};
my $key_dir      = $key_vars_ref->{'key_dir'};
my $key_name     = $key_vars_ref->{'key_name'};
my $home_dir     = $key_vars_ref->{'usr_home'};
my $key_usr      = $key_vars_ref->{'usr_name'};
my $key_basepath = $key_vars_ref->{'key_basepath'};
my $key_filename = $key_vars_ref->{'key_filename'};

if ( not <crypt.C25519.auto_load_keys> //= TRUE ) {
    <[base.log]>->( 2, ': autoload disabled, skipped key loading .,' );
    <crypt.C25519.initialized>++;
    return 0;
}

if ( not defined $home_dir or not -r $home_dir ) {
    if ( not <base.parser.config.reloading> ) {
        <[base.logs]>->(
            0, '<< no access to home directory >> [ %s ]', $key_usr
        );
        <[base.log]>->( 0, '  :.. skipping C25519 key initialization ..,' );
    } else {
        <[base.log]>->( 1, ': skipped key reload., [ home-dir ]' );
    }
    return 0;    # state still valid
}

##  creates directory if missing  ##
return -1 if not <[crypt.C25519.chk_key_dir]> == TRUE;

my $private_key_file = $key_filename->{'private'};
my $public_key_file  = $key_filename->{'public'};

if ( index( <system.zenka.name>, qw| source |, 0 ) == -1 ) {
    if (    <[base.cfg_bool]>->(<crypt.C25519.autocreate-user-key>)
        and not -f $private_key_file
        and not -f $public_key_file
        and -w $key_dir ) {
        <[base.logs]>->(
            0, "generating C25519 'base' key pair for '%s' ..,", $key_usr
        );
        my %key_b32 = ( 'private' => '', 'public' => '' );
        if (<[crypt.C25519.gen_keys]>) {
            <[crypt.C25519.write_keys]>->( undef, undef, FALSE );
        }
        <[crypt.C25519.sign_keys]>;

    } elsif ( not defined $keys{'C25519'}{$key_name}
        or keys( $keys{'C25519'}{$key_name}->%* ) != 2 ) {
        <[crypt.C25519.load_keypair]>;
    }
}

while ( glob $key_basepath . qw| .{spk,sig}.* | ) {    ##  key signatures  ##
    if (m{([^\/]+\.(spk|sig)\.(.+))$}) {
        my ( $fname, $type, $rkname ) = @{^CAPTURE};
        <[base.logs]>->( ": : %s : '%s'", $type, $fname );
        $type = qw|public| if $type eq qw| spk |;  ## <-- [ root-key-pub ] ###
        chomp( $keys{'C25519'}{$key_name}{'root'}{$rkname}{$type}
                = <[file.slurp]>->($ARG)->$* );
    }
}

if ( defined <system.zenka.type>
    and <system.zenka.type> eq qw| cube | )    # <<< ! >>>
{
    my $s_key_name = <system.zenka.name>;
    <[crypt.C25519.generate_session_keypair]>
        if not defined $keys{'C25519'}{'session'}{$s_key_name};
}

<crypt.C25519.initialized>++;

0;

#,,,,,,,.,,,.,,..,.,,,,,.,,,,,..,,,,.,,..,,.,,..,,...,...,...,.,,,.,.,.,,,.,,,
#LVVN3JX346JZ76BPX2GPS37ENNX4IYK7NCWH6UMAPE477E6KETK2ZZLQDVL32BJGOMBFDGLFQG2FE
#\\\|3Q6YLMAA5Q43Z6YKE5LDL256QBQKL2W4MNRRHXBQTTQY46WC33W \ / AMOS7 \ YOURUM ::
#\[7]E46II3MJ6G5VXLCM2XPCQSI5FHITGNDQMY6DJC5GJZ3T42H332DY 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
