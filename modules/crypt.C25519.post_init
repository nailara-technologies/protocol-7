## >:] ##

# name = crypt.C25519.post_init
# note = use <crypt.C25519.base_key_name> to override the '<user>.base' pattern

if ( not <crypt.C25519.auto_load_keys> //= 1 ) {
    <[base.log]>->( 2, ': autoload disabled, skipped key loading .,' );
    <crypt.C25519.initialized>++;
    return 0;
}

my $key_vars = <[crypt.C25519.key_vars]>;

my $uid          = $key_vars->{'uid'};
my $gid          = $key_vars->{'gid'};
my $key_dir      = $key_vars->{'key_dir'};
my $key_name     = $key_vars->{'key_name'};
my $home_dir     = $key_vars->{'usr_home'};
my $key_usr      = $key_vars->{'usr_name'};
my $key_basepath = $key_vars->{'key_basepath'};
my $key_filename = $key_vars->{'key_filename'};

if ( not defined $home_dir or !-r $home_dir ) {
    if ( not <base.parser.config.reloading> ) {
        <[base.logs]>->(
            0, '<< no access to home directory >> [ %s ]', $key_usr
        );
        <[base.log]>->( 0, '  :.. skipping C25519 key initialization ..,' );
    } else {
        <[base.log]>->( 1, ': skipped key reload., [ home-dir ]' );
    }
    return 0;    # state still valid
}

return -1 if not <[crypt.C25519.chk_key_dir]>;    # <-- creates if missing ..,

<[crypt.C25519.auto_convert]>->($key_dir);   #<--[ update filename structure ]

my $secret_key_file = $key_filename->{'secret'};
my $public_key_file = $key_filename->{'public'};

if (    index( <system.zenka.name>, qw| source |, 0 ) == -1
    and <[base.cfg_bool]>->(<crypt.C25519.autocreate-user-key>)
    and not -f $secret_key_file
    and not -f $public_key_file
    and -w $key_dir ) {
    <[base.logs]>->(
        0, "generating C25519 'base' key pair for '%s' ..,", $key_usr
    );
    my %key_b32 = ( 'secret' => '', 'public' => '' );
    if (<[crypt.C25519.gen_keys]>) {
        <[crypt.C25519.write_keys]>;
    }
    <[crypt.C25519.sign_keys]>;

} elsif ( not defined $keys{'C25519'}{$key_name}
    or keys( $keys{'C25519'}{$key_name}->%* ) != 2 ) {
    <[crypt.C25519.load_keypair]>;
}

while ( glob $key_basepath . '.{rkp,sig}.*' ) {
    if (m{([^\/]+\.(rkp|sig)\.(.+))$}) {
        my ( $fname, $type, $rkname ) = ( $1, $2, $3 );
        <[base.logs]>->( ": : %s : '%s'", $type, $fname );
        $type = qw|public| if $type eq qw| rkp |;  ## <-- [ root-key-pub ] ###
        chomp( $keys{'C25519'}{$key_name}{'root'}{$rkname}{$type}
                = ${ <[file.slurp]>->($ARG) } );
    }
}

if ( defined <system.zenka.type>
    and <system.zenka.type> eq qw| cube | )    # <<< ! >>>
{
    my $s_key_name = <system.zenka.name>;
    <[crypt.C25519.generate_session_keypair]>
        if not defined $keys{'C25519'}{'session'}{$s_key_name};
}

<crypt.C25519.initialized>++;

0;

#,,..,,,,,...,,,.,,.,,,..,...,,,,,,..,.,,,,..,..,,...,..,,.,.,,.,,,.,,,..,.,,,
#O4XSAGIFHS57QGAHRPPTHJYOO37U7HPOXXVC3CPIIGMF4K2HXNLLA7O2GVU5NPD5CD5QYX46ZIZ4C
#\\\|R7EL55MAPRVUBBVZGE3POTXV3M3OGDWK7PL4FW5EQ7TEK57TEC2 \ / AMOS7 \ YOURUM ::
#\[7]MZ7Y2OMYEUXHFQK54SEGAWK2LUACT5I764M2EMEJFV3NWG6PBODQ 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
