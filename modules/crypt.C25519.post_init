## [:< ##

# name = crypt.C25519.post_init
# note = use <crypt.C25519.base_key_name> to override the '<user>.base' pattern

my $key_vars_ref = <[crypt.C25519.key_vars]>;

my $uid          = $key_vars_ref->{'uid'};
my $gid          = $key_vars_ref->{'gid'};
my $key_dir      = $key_vars_ref->{'key_dir'};
my $key_name     = $key_vars_ref->{'key_name'};
my $home_dir     = $key_vars_ref->{'usr_home'};
my $key_usr      = $key_vars_ref->{'usr_name'};
my $key_basepath = $key_vars_ref->{'key_basepath'};
my $key_filename = $key_vars_ref->{'key_filename'};

##[  updating filename structure  ]##
<[crypt.C25519.auto_convert_names]>->($key_dir)
    if -d $key_dir and -r $key_dir;

if ( not <crypt.C25519.auto_load_keys> //= TRUE ) {
    <[base.log]>->( 2, ': autoload disabled, skipped key loading .,' );
    <crypt.C25519.initialized>++;
    return 0;
}

if ( not defined $home_dir or not -r $home_dir ) {
    if ( not <base.parser.config.reloading> ) {
        <[base.logs]>->(
            0, '<< no access to home directory >> [ %s ]', $key_usr
        );
        <[base.log]>->( 0, '  :.. skipping C25519 key initialization ..,' );
    } else {
        <[base.log]>->( 1, ': skipped key reload., [ home-dir ]' );
    }
    return 0;    # state still valid
}

##  creates directory if missing  ##
return -1 if not <[crypt.C25519.chk_key_dir]> == TRUE;

my $private_key_file = $key_filename->{'private'};
my $public_key_file  = $key_filename->{'public'};

if ( index( <system.zenka.name>, qw| source |, 0 ) == -1 ) {
    if (    <[base.cfg_bool]>->(<crypt.C25519.autocreate-user-key>)
        and not -f $private_key_file
        and not -f $public_key_file
        and -w $key_dir ) {
        <[base.logs]>->(
            0, "generating C25519 'base' key pair for '%s' ..,", $key_usr
        );
        my %key_b32 = ( 'private' => '', 'public' => '' );
        if (<[crypt.C25519.gen_keys]>) {
            <[crypt.C25519.write_keys]>->( undef, undef, FALSE );
        }
        <[crypt.C25519.sign_keys]>;

    } elsif ( not defined $keys{'C25519'}{$key_name}
        or keys( $keys{'C25519'}{$key_name}->%* ) != 2 ) {
        <[crypt.C25519.load_keypair]>;
    }
}

while ( glob $key_basepath . qw| .{rkp,sig}.* | ) {
    if (m{([^\/]+\.(rkp|sig)\.(.+))$}) {
        my ( $fname, $type, $rkname ) = ( $1, $2, $3 );
        <[base.logs]>->( ": : %s : '%s'", $type, $fname );
        $type = qw|public| if $type eq qw| rkp |;  ## <-- [ root-key-pub ] ###
        chomp( $keys{'C25519'}{$key_name}{'root'}{$rkname}{$type}
                = ${ <[file.slurp]>->($ARG) } );
    }
}

if ( defined <system.zenka.type>
    and <system.zenka.type> eq qw| cube | )    # <<< ! >>>
{
    my $s_key_name = <system.zenka.name>;
    <[crypt.C25519.generate_session_keypair]>
        if not defined $keys{'C25519'}{'session'}{$s_key_name};
}

<crypt.C25519.initialized>++;

0;

#,,,.,,,,,,.,,,,,,.,,,.,,,,..,.,,,...,,,.,.,,,..,,...,...,..,,,.,,,.,,,,,,,,,,
#MPZF3CA62KVKXLUM5ADVS2VLQ3VZWISQ6RMS72IGIYZ4YYDLERLG5ZMOZ2VM5LKFOY2XXWLKF77ZE
#\\\|SUCSWR6F2Y5AOC2EPVMQRTQAEZXRULPNLVWKSYDXH6QPTPWKMCN \ / AMOS7 \ YOURUM ::
#\[7]FX2GEK7RP4QRQ32FOOCJTQJSL3CJ3XX5WJAZKNYD6QHN6HYL6WAY 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
