## >:] ##

# name = crypt.C25519.load_keypair

my $key_name_param     = shift;         ##  optional  ##
my $key_password       = shift;         ## optional ##
my $pwd_retry_on_error = shift // 0;    ##  false  ##

my $key_vars_ref = <[crypt.C25519.key_vars]>->($key_name_param);

my $key_dir      = $key_vars_ref->{'key_dir'};
my $key_usr      = $key_vars_ref->{'usr_name'};
my $key_name     = $key_vars_ref->{'key_name'};
my $key_filename = $key_vars_ref->{'key_filename'};

my $private_key_file = $key_filename->{'private'};
my $public_key_file  = $key_filename->{'public'};

if ( -r $private_key_file and -r $public_key_file ) {

    my $u_str = $key_name =~ m|^$key_usr(?:\..+)$| ? '' : " [usr:$key_usr]";
    <[base.logs]>->( 1, ":. C25519-key .:. '%s'%s", $key_name, $u_str );

    my $encoded_private_key = <[file.slurp]>->($private_key_file)->$* // '';
    my $encoded_public_key  = <[file.slurp]>->($public_key_file)->$*  // '';

    if ( not length $encoded_private_key or not length $encoded_public_key ) {
        <[base.logs]>->( 0, "cannot load '%s' key data ..,", $key_name );
        return 0;
    } else {
        chomp($encoded_public_key);
        chomp($encoded_private_key);
    }

    my $key_encrypted = 0;    ##  false  ##

    ## decode [ base 32 ] ##
    $keys{'C25519'}{$key_name}{'private'} = decode_b32r($encoded_private_key);
    $keys{'C25519'}{$key_name}{'public'}  = decode_b32r($encoded_public_key);

    ## checking for encryption [ '.:' prefix encrypted or 'U:' for plain ] ##
    ##
    if (length($encoded_private_key) == 106    ##[  has no linefeed  ]##
        and index( $encoded_private_key,                  qw| FY5 |, 0 ) == 0
        and index( $keys{'C25519'}{$key_name}{'private'}, qw| .: |,  0 ) == 0
    ) {
        $key_encrypted = 5;                    ## true ##
        substr( $keys{'C25519'}{$key_name}{'private'}, 0, 2, '' );

    } elsif ( length($encoded_private_key) == 106
        and index( $encoded_private_key,                  qw| KU5 |, 0 ) == 0
        and index( $keys{'C25519'}{$key_name}{'private'}, qw| U: |, 0 ) == 0 )
    {
        $key_encrypted = 0;                    ## false ##
        substr( $keys{'C25519'}{$key_name}{'private'}, 0, 2, '' );

    } elsif ( length($encoded_private_key) == 103 ) { ##[  old key format  ]##
        $key_encrypted = 0;                           ## false ##

    } else {    ##[  not a valid key format  ]##
        undef $keys{'C25519'}{$key_name}{'private'};
        delete $keys{'C25519'}{$key_name}{'private'};    ##  renove  ##
        <[base.logs]>->(
            0, "private key format not recognized ['%s']", $key_name
        );
    }

    foreach my $type (qw|  private  public  |) {
        <[base.logs]>->( 0, "BASE32 decoding failed [ %s key ]", $type )
            if not defined $keys{'C25519'}{$key_name}{$type};
    }

    if (   not defined $keys{'C25519'}{$key_name}{'public'}
        or not defined $keys{'C25519'}{$key_name}{'private'} ) {
        <[base.logs]>->( 0, "cannot load key '%s'..,", $key_name );
        return FALSE;    ##  false  ##
    }

    ##  decrypt private key [ when password provided ]  ##
    ##
    if ($key_encrypted) {
    RE_READ_PWD:
        if ( not defined $key_password ) {
            say sprintf "%s:%s", $AMOS7::C{'0'}, $AMOS7::C{'R'};
            $key_password = AMOS7::TERM::read_password_single(
                sprintf( "'%s' key decryption password", $key_name ) );
        }

        if ( defined $key_password and length $key_password < 13 ) {
            say sprintf "%s:", $AMOS7::C{'0'};
            <[base.log]>->( 0, 'password is too short, retry or abort..,' );

            ## say sprintf "%s:", $AMOS7::C{'0'};

            undef $key_password;
            for ( 1 .. 7 ) {
                <[base.sleep]>->(0.1);
                <[event.once]>->(0.007);
            }
            goto RE_READ_PWD;
        } elsif ( not defined $key_password ) {
            undef $keys{'C25519'}{$key_name}{'private'};
            delete $keys{'C25519'}{$key_name}{'private'};
            <[base.log]>->( 0, 'cannot decrypt private key .,' );
            <[base.log]>->( 1, ':' );
            <[base.logs]>->( ": public key loaded ['%s']", $key_name );
            <[base.log]>->( 1, ':' );
            return 0;
        } else {
            say sprintf "%s:%s", $AMOS7::C{'0'}, $AMOS7::C{'R'};
        }

        my $enc_key = AMOS7::13::key_32( \$key_password );

        <[base.logs]>->( ": decrypting private key ., [ %s ]", $key_name );

        if ( not defined $enc_key or not length $enc_key ) {
            warn 'error during file enc key derivation <{C1}>';
            return undef;
        }
        my $status
            = AMOS7::Twofish::key_init( $enc_key, qw| decryption C25519 | );

        if ( not defined $status or not $status ) {
            warn 'error during initializing of '
                . 'key file decryption key <{C1}>';
            return undef;
        }
        my $decrypted_C25519_sref
            = AMOS7::Twofish::decrypt( qw| C25519 |,
            \$keys{'C25519'}{$key_name}{'private'} );

        if (   not defined $decrypted_C25519_sref
            or ref $decrypted_C25519_sref ne qw| SCALAR |
            or not length $decrypted_C25519_sref->$* ) {
            warn 'key decryption error <{C1}>';
            return undef;
        } elsif (
            not <[crypt.C25519.compare_keypair]>->(
                $keys{'C25519'}{$key_name}{'public'},
                $decrypted_C25519_sref->$*, 5    ##[ silent ]##
            ) // 0
        ) {
            <[base.log]>->( 1, ':' );
            <[base.log]>->( 0, ': password is not correct ..,' );
            <[base.log]>->( 1, ':' );

            undef $key_password;

            goto RE_READ_PWD if $pwd_retry_on_error;

            undef $keys{'C25519'}{$key_name}{'private'};
            delete $keys{'C25519'}{$key_name}{'private'};

            <[base.logs]>->( ": public key loaded ['%s']", $key_name );
            <[base.log]>->( 1, ':' );
            return 0;
        }
        $keys{'C25519'}{$key_name}{'private'} = $decrypted_C25519_sref->$*;
        my $key_checksum = <[chk-sum.amos]>->( $decrypted_C25519_sref->$* );
        <[base.logs]>->( ': :. done. [ %s ]', $key_checksum );

    } elsif ( defined $keys{'C25519'}{$key_name}{'private'} ) {
        ##[  verifying [ unencrypted ] key pair match  ]##

        if (not <[crypt.C25519.compare_keypair]>->(
                $keys{'C25519'}{$key_name}{'public'},
                $keys{'C25519'}{$key_name}{'private'}
            ) // 0
        ) {
            foreach my $type (qw| private public |) {
                undef $keys{'C25519'}{$key_name}{$type};
                delete $keys{'C25519'}{$key_name}{$type};
            }
            delete $keys{'C25519'}{$key_name};
            <[base.log]>->( 1, ':' );
            <[base.log]>->( 0, ': private and public keys do not match .,' );
            <[base.log]>->( 1, ':' );
            <[base.logs]>->( ": none of the keys loaded for %s", $key_name );
            <[base.log]>->( 1, ':' );

            return FALSE;    ##  false  ##
        }
    }
    return TRUE;             ## true ##

} else {
    delete $keys{'C25519'}{$key_name};
    delete $keys{'C25519'} if not keys $keys{'C25519'}->%*;
    <[base.logs]>->(
        0, "'%s' key pair not found or not readable ..,", $key_name
    );
    <[base.logs]>->( 0, " ::[ expected in : '%s' ]::", $key_dir );

    return FALSE;            ##  false  ##
}

#,,.,,...,,..,,,,,,,.,..,,...,.,,,,..,.,,,.,,,..,,...,...,..,,.,,,.,.,,,,,,,,,
#6RBRSB4R5HQK7MMUEIHO7B7P5D7H22EQ7RE6XDLF75V52XWJHXHVG3ENABW7ZM3EYTPACWPTLWC24
#\\\|N5ZKYYRH75VQRG7SO2EM67C6Z5Q6EELLBCSVJDMHZURVHAM5ZXK \ / AMOS7 \ YOURUM ::
#\[7]RMH4ELLMN6DKGCJVDXVAROHGG4WK5O4DSEGTKERMB3TNM4ZCQ2BI 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
