## >:] ##

# name  = base.cmd.localtime
# param = [unix|ntime[-b32]]
# descr = return local date string [ host timezone ]
# todo  = clean up ambiguous variable names, split \ extract functionality

my $unix_time = $call->{'args'} // time();

my $ntime_decoded;
my $utime_copy = $unix_time;

## ntime base32 case ##
if ( $unix_time =~ m|[A-Z]| and length($unix_time) >= 10 ) {
    eval { $ntime_decoded = decode_b32r($unix_time) };
    return {
        'mode' => qw| false |,
        'data' => 'encoded network time not valid [ BASE decoding error ]'
        }
        if not defined $ntime_decoded or length $EVAL_ERROR;
}

if ( defined $ntime_decoded ) {
    return {
        'mode' => qw| false |,
        'data' => 'decoded value not valid [ expected compressed integer ]'
        }
        if not <[base.comp-int.is_valid]>->($ntime_decoded);

    ## contains network time with arbitary precision
    my @nt_val = unpack( qw| w* |, $ntime_decoded );
    $nt_val[1] =~ s|^7|| if @nt_val == 2;     ## <-- saves 0 prefixes
    $unix_time = join( qw| . |, @nt_val );    ## needs error handling
}

$unix_time = $utime_copy    # <<[?]>> deal with false positives <<[?]>>
    if $call->{'args'} =~ m|[A-Z]|
    and ( not defined $unix_time or $EVAL_ERROR );

return {
    'mode' => qw| false |,
    'data' => 'submitted parameter string is not valid'
    }
    if length $EVAL_ERROR
    or not defined $unix_time
    or $unix_time !~ m|^\d{1,17}(\.\d{1,20})?$|;

$unix_time = <[base.n2u_time]>->($unix_time)
    if length( int $unix_time ) >= 13;    # <-- nailara network time

my $subseconds = $unix_time =~ s|(\.\d+)$|| ? ${^CAPTURE}[0] : undef;

return {
    'mode' => qw| false |,
    'data' => 'queried value is out of range'
    }
    if $unix_time > 67767976233316804;

my $ltime_str = scalar localtime $unix_time;

##  swapping time \ year value  ##
$ltime_str =~ s| (\d\d:\d\d:\d\d) (\d{4})$| $2 $1|;

##  adding sub second precision string  ##
$ltime_str .= sprintf( ' [ +0%s ]', $subseconds ) if defined $subseconds;

return {
    'mode' => qw| false |,
    'data' => 'unix_time value is too high'
    }
    if not defined $ltime_str or not length $ltime_str;

return {
    'mode' => qw| true |,
    'data' => $ltime_str
    }

#,,,.,,,.,..,,.,.,...,,..,,..,..,,,,.,.,,,..,,..,,...,...,..,,.,,,,,,,..,,,,.,
#HHD4A63B3VGSKH47M4OZMQYL3EZDMJRKBY73WVOJTZONVOHVMQGQJGWZIGZEVS4JYQ5N5XCQYGIIM
#\\\|RZBVQB7S2LMXRTJBS4K5QRLL2ZTZIWI4U3G25PVBCYWG6LKZ3TA \ / AMOS7 \ YOURUM ::
#\[7]Z7AGK3KUQP7PIACJA5V5QA335W74QE3AW6GZZSESYWGTVD46OSBA 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
