## >:] ##

# name  = v7.handler.sig_chld
# descr = clean up after terminated child process IDs

<[base.log]>->( 2, 'SIGCHLD received., collecting children..,' );

if ( @ARG and not length ref $ARG[0] ) {
    ( my $received_pid, my $received_exit_code ) = @ARG;
    if ( $received_pid =~ m|^\-?\d+$| ) {
        <base.process.waitpid_collected>->{$received_pid}
            = $received_exit_code;
    }
}

my @waitpid_pid;    ## collection from base.exists.sub-process ##
my $collected_child_pids = <base.process.waitpid_collected> //= {};
@waitpid_pid = <[base.reverse-sort]>->($collected_child_pids)
    if keys $collected_child_pids->%*;

my $end_pid;
local ( $OS_ERROR, $CHILD_ERROR );
while ( @waitpid_pid
    or ( $end_pid = waitpid( 0, WNOHANG() ) ) > 0 ) {

    my $child_error_val;
    if ( not defined $collected_child_pids->{$end_pid} ) {
        $child_error_val = $CHILD_ERROR;
    } else {
        $child_error_val = delete $collected_child_pids->{$end_pid};
    }

    my ( $instance, $zenka_name, $instance_id, $zenka_subname );

    if ( my $child = <v7.child>->{$end_pid} ) {
        $instance_id   = $child->{'instance_id'};
        $instance      = <v7.zenka.instance>->{$instance_id};
        $zenka_name    = $instance->{'zenka_name'};
        $zenka_subname = $instance->{'subname'};
    }

    $instance_id //= delete <v7.process.instance_cache>->{$end_pid};
    <[base.clean_hashref]>->(<v7.process.instance_cache>);

    $instance = <v7.zenka.instance>->{$instance_id}
        if not defined $instance
        and defined $instance_id
        and defined <v7.zenka.instance>->{$instance_id};

    # determine exit status
    my $log_level = 2;
    my $exit_val
        = $child_error_val != -1 ? $child_error_val >> 8 : $child_error_val;
    my $exit_sig     = $child_error_val != -1 ? $child_error_val & 127 : 0;
    my $exit_sig_str = $exit_sig ? sprintf( ', signal %s', $exit_sig ) : '';
    $log_level = 0
        if $exit_sig_str =~ s|(signal 11)$|$1 :: segmentation fault ::|;
    my $had_coredump
        = ( $child_error_val != -1 and $child_error_val & 128 ) ? 5 : 0;
    my $e_core_dump = $had_coredump ? ' and a core dump' : '';
    $log_level = 1 if $exit_val or $exit_sig == 9;
    $log_level = 0 if $had_coredump;
    my $zenka_str
        = defined $zenka_name
        ? sprintf( '< %s >', $zenka_name )
        : qw| child |;
    <[base.logs]>->(
        $log_level, '%s [PID:%d] shut down with exit code %s%s%s',
        $zenka_str, $end_pid, $exit_val, $exit_sig_str, $e_core_dump
    );

    <[v7.stop_heartbeat_timer]>->($instance_id) if defined $instance_id;

    <[v7.terminate_process]>->($end_pid);

    # <-- cleaning up children  .., [LLL]

    if (    defined $instance_id
        and $instance_id =~ <regex.base.iid>
        and defined $instance
        and my $child = <v7.child>->{$end_pid} ) {
        <[base.logs]>->( 2, ': was instance %d', $instance_id );

        delete <v7.child>->{$end_pid};
        delete $instance->{'restart_pids'}->{$end_pid}
            if exists $instance->{'restart_pids'};

        my $current_pid = $instance->{'process'}->{'id'};

        my $current_status = $instance->{'status'} // qw| undefined |;

        <[base.logs]>->( 2, ": had status : '%s'", $current_status );

        ## record web-browser segfaults [ for crash mitigation ] ##
        if ( $exit_sig == 11 and $zenka_name eq qw| web-browser | ) {
            my $web_browser_uname = <system.AMOS-user>;
            my $subname_b32
                = ( defined $zenka_subname and length($zenka_subname) )
                ? join( '', qw| . |, encode_b32r($zenka_subname) )
                : '';
            my $file_name = join( '',
                qw| /var/run/.7/web-browser.crash_pid |, $subname_b32 );

            <[file.put]>->( $file_name, sprintf( "%d\n", $end_pid ) )
                or warn join( qq| : |,
                $file_name, scalar <[base.format_error]>->($OS_ERROR) );
            chmod( 0644, $file_name )
                or warn join( qq| : |,
                $file_name, scalar <[base.format_error]>->($OS_ERROR) );
            my @pwn = getpwnam($web_browser_uname);
            chown( $pwn[2], $pwn[3], $file_name )
                or warn join( qq| : |,
                $file_name, scalar <[base.format_error]>->($OS_ERROR) );
        }

        my $next_status
            = $current_status =~ m,error|online|starting,
            ? qw|  error  |
            : qw| offline |;

        $next_status = qw| restart | if $current_status eq qw| restart |;

        if ( $current_status eq qw| online | and defined <v7.ondemand_zenki> )
        {
            map { $next_status = qw| offline | if $ARG eq $zenka_name }
                <v7.ondemand_zenki>->@*;
        }

        if ( <[v7.instance_pid_count]>->($instance_id) ) {

            <[zenka.change_status]>->( $instance_id, qw| delayed | )
                if $current_status eq qw| restart |;

            $instance->{'pid_check_timer'} = <[event.add_timer]>->(
                {   'after'    => 0.07,
                    'interval' => 0.13,
                    'handler'  => qw| v7.handler.children_left |,
                    'data'     => {
                        qw| instance_id | => $instance_id,
                        qw| next_status | => $next_status
                    }
                }
            );
        } else {
            <[zenka.change_status]>->( $instance_id, $next_status )
                if $current_status ne $next_status;

            <[v7.init_restart_timer]>->($instance_id)
                if $next_status !~ m,offline|shutdown,;
        }
    } elsif ( defined $instance_id and defined $instance ) {
        delete <v7.zenka.instance>->{$instance_id};
    }
}

#,,.,,,.,,,,,,,,,,...,,.,,...,,..,.,.,,.,,...,..,,...,...,.,.,,,,,,,.,,..,,,,,
#M5JZOORZOH5GLSHNYSHAKZ3W6E5L6FJUX4OVQPAZMSDPW4W2Q72IGA332RWDKQY4ZSKLWSDCY3EHE
#\\\|OKWG4GWLZRMJS66APO4E7AXZQY4OGIBUY3TK2EL4YIDEFXDOU4M \ / AMOS7 \ YOURUM ::
#\[7]Q6GCOHRLSQHCJQIIXQKPNT2V75NFCHAK2Q67ZCWTLTWVKPQ7NUDA 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
