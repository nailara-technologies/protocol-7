# >:]

# name  = base.del_key

my $params = shift || {};

my $data_ref = *data{HASH};
my $silent   = 1;
my $del_key;

$data_ref = $params->{'data_ref'} if exists $params->{'data_ref'};
$del_key  = $params->{'del_key'}  if exists $params->{'del_key'};
$silent   = $params->{'silent'}   if exists $params->{'silent'};

die 'no key specified' if not defined $del_key or !length($del_key);
die "invalid key '$del_key'"
    if $del_key =~ /^\.|\.$/
    or $del_key !~ /^[\w\d_\-\.']+$/
    or $del_key =~ /~/;
my $_del_key = $del_key;
$_del_key =~ s/'(([^']|\.)+)'/my$k=$1;$k=~s|\.|\0|g;$k/ge;
die 'invalid key' if $_del_key =~ /\'/;

my $del_key_ref = <[base.resolve_key]>->( $del_key, $$data_ref );
if ( not defined $del_key_ref ) {
    <[base.log]>->( 0, "base.del_key: no such key ($del_key)" ) if !$silent;
    return 0;
}

my $deleted = 0;
my @del_key_chain = split /\./, $_del_key;
map { $_ =~ s/\0/./g } @del_key_chain;

while ( my $sub_key = pop(@del_key_chain) ) {
    $_del_key =~ s/\.$sub_key$//;
    if ( !@del_key_chain ) {
        last
            if $deleted
            and ref( ${$$data_ref}{$sub_key} ) eq 'HASH'
            and keys( %{ ${$$data_ref}{$sub_key} } );
        $deleted++ if delete ${$$data_ref}{$sub_key};
    } else {
        my $parent_ref = <[base.resolve_key]>->( $_del_key, $$data_ref );
        $deleted++ if delete $$parent_ref->{$sub_key};
    }
}

if ($deleted) {
    <[base.log]>->( 1, "base.del_key: key ($del_key) deleted" ) if !$silent;
    $deleted;
} else {
    <[base.log]>->( 0, "base.del_key: failed to delete key ($del_key)" );
    return -1;
}
