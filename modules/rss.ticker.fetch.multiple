# >:]

# name = rss.ticker.fetch.multiple

my $rss_url_ref = shift;
die "expected hash reference containing RSS urls"
    if not defined $rss_url_ref
    or !length($rss_url_ref)
    or ref($rss_url_ref) ne 'HASH';
my $output_file = <rss.ticker.txt_data_path>;
( my $data_dir = <rss.data.tmp_path> . '/rssdata' ) =~ s,(/|\.\.)/,/,g;
my $join_type = <rss.ticker.join_type>;
$join_type //= 'mixed';
my $seperator = '.:.';

my @urls;
map { push( @urls, $rss_url_ref->{$_} ) } keys( %{$rss_url_ref} );
die "no urls set up (referenced hash is empty)" if !@urls;

<[base.log]>->( 2, "checking RSS feeds for new data..." );

my $got_updates = 0;

foreach my $rss_index ( keys( %{$rss_url_ref} ) ) {
    my $rss_url  = $rss_url_ref->{$rss_index};
    my $response = <rss.browser>->get($rss_url);
    if ( $response->code == 200 ) {
        <[base.log]>->( 2, ": got fresh RSS content..." );
        my $feed
            = <rss.parser>
            ->parse_string( encode( 'utf-8', $response->decoded_content ) );
        die <rss.parser>->errstr if not defined $feed;

        my @txt_data;
        foreach my $item ( $feed->query('//item') ) {
            my $node = $item->query('title');
            my $line = $node->text_content;
            push( @txt_data, $line );
        }
        my $url_hash = <[digest.sha1]>->($rss_url);
        if ( !-d $data_dir ) {
            mkdir($data_dir)
                or die "can't create rss data dir '$data_dir'! [$!]";
            chmod( 0700, $data_dir );
        }
        my $url_data_file .= "$data_dir/$url_hash.txt";
        open( my $txt_fh, '>' . $url_data_file )
            or die "can't write to feed data file [$!]";
        print {$txt_fh} join( "\n", @txt_data ) . "\n";
        close($txt_fh);
        $got_updates = 1;
        <[base.log]>->( 2, ": : wrote txt data to '$url_data_file'" );
        <rss.browser>->commit;

    } elsif ( $response->code == 304 ) {
        <[base.log]>->( 2, ": no new content since last request" );
    } else {
        <[base.log]>->(
            0, "failed to access RSS url '$rss_url' (",
            $response->status_line, ")"
        );
    }
}
return 0 if !$got_updates;
my %txt_data;
map {
    my $rss_url  = $rss_url_ref->{$_};
    my $url_hash = <[digest.sha1]>->($rss_url);
    my $url_data_file .= "$data_dir/$url_hash.txt";
    open( my $r_fh, '<' . $url_data_file )
        or die "can't open feed data file '$url_data_file'! [$!]";
    @{ $txt_data{$_} } = <$r_fh>;
    close($r_fh);
} keys( %{$rss_url_ref} );

open( my $txt_fh, '>' . $output_file )
    or die "can't write to ticker data file '$output_file' [$!]";
my @output_data;
if ( $join_type eq 'mixed' ) {
    while ( keys(%txt_data) ) {
        foreach my $txt_index ( sort keys(%txt_data) ) {
            push( @output_data, shift( @{ $txt_data{$txt_index} } ) );
            delete $txt_data{$txt_index} if !@{ $txt_data{$txt_index} };
        }
    }
    print {$txt_fh} join( " $seperator ", @output_data );
} elsif ( $join_type eq 'seperate' ) {
    foreach my $txt_index ( sort keys(%txt_data) ) {
        push( @output_data,
            join( " $seperator ", @{ $txt_data{$txt_index} } ) );
        push( @output_data, "^\n" );
    }
    pop(@output_data);
    print {$txt_fh} @output_data;
} else {
    <[base.log]>->(
        0, "unknown join type '$join_type' [expected 'mixed' or 'seperate']"
    );
    close($txt_fh);
    unlink($output_file);
    return -1;
}

close($txt_fh);
return 1;
