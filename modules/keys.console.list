## >:] ##

# name  = keys.console.list
# param = [nochecksums]
# descr = list C25519 key names \ files for current user
# note  = Protocol-7 keys list | grep ' : .*:' | sed 's|.* : ||'

my $param = shift;

my $display_checksums = TRUE;    ## true ##

$display_checksums = FALSE if defined $param and $param eq qw| nochecksums |;

my %C            = %AMOS7::C;
my $key_vars_ref = <[crypt.C25519.key_vars]>;

my $key_dir = $key_vars_ref->{'key_dir'};
my $key_usr = $key_vars_ref->{'usr_name'};

my $keys_re        = <keys.regex>;
my $key_re_public  = $keys_re->{'key_file'}->{'public'};
my $key_re_private = $keys_re->{'key_file'}->{'private'};

## warns when absent ##
my @k_files = grep {s|^.+/||} <[keys.get_keyfiles]> or return;

my %key_chksums;
if ($display_checksums) {    ## calculating key checksums ##
    my $calculating_message = 'calculating C25519 key checksums ..,';
    <[base.log]>->( 1, $calculating_message );
    if ( not <system.verbosity.console> ) {
        $OUTPUT_AUTOFLUSH = TRUE;
        printf "\n: %s%s\r", $C{0}, $calculating_message;
    }

    %key_chksums = ( <[keys.checksum_href]>->%* ); ##  uses cache look-ups  ##

    foreach my $name ( <[base.sort]>->( \%key_chksums ) ) {
        <[base.logs]>->( 0, "failed to acquire checksum for key '%s'", $name )
            if not defined $key_chksums{$name};
    }
}

my $key_name;
my %key_names;
my $max_nlen = 0;
foreach my $file (@k_files) {
    my $name = <[crypt.C25519.get_keyname]>->($file);
    $key_names{$file} = sprintf qw| '%s' |, $name;

    my $length = length $name;

    if ( not $display_checksums ) {
        my $spaces = ' ' x length $name;
        $key_names{$file} = sprintf ' %s ', $spaces
            if $file =~ m{$key_re_public};

    } elsif ( defined $key_chksums{$name} ) {
        $key_names{$file} = sprintf( ' %*s ', $length, $key_chksums{$name} )
            if $file =~ m{$key_re_public};
    }

    my $l = length $key_names{$file};
    $max_nlen = $l if $l > $max_nlen;

    $max_nlen = length $key_chksums{$name}
        if $display_checksums
        and length( $key_chksums{$name} // '' ) > $max_nlen;
}

<[base.logs]>->( "listing key files ['%s']", $key_dir );

my $linefeed        = $display_checksums ? '' : "\n";
my $key_list_string = join '',
    $linefeed, sprintf( "%40s\r :: keys for user %s :.\n :\n", '', $key_usr ),
    ( map { sprintf( " : %*s : %s\n", $max_nlen, $key_names{$ARG}, $ARG ) }
        @k_files ),
    "::\n";

## colorizing ##
##
if ( <system.ansi_color> or <system.force_colors> ) {
    $key_list_string =~ s|^(.+)$|$C{T}$1$C{R}|mg;
    $key_list_string =~ s|('.+')|$C{B}$1$C{R}$C{T}|mg;
    $key_list_string =~ s|(*plb:user)( \S+ )|$C{B}$C{b}$1$C{R}$C{T}|mg;
    $key_list_string =~ s,(<:.+:>|encrypted),$C{0}$C{b}$1$C{R}$C{T},mg;
}

return say $key_list_string;

#,,,.,..,,,,,,,..,.,.,,.,,,,.,,,,,,,,,,.,,,,.,..,,...,...,..,,,..,,,.,,,,,.,.,
#D6KSFHBMTBMNOS25UOIRNJEU2W4AOU2Q6OEDUKEFKHWR2KFLGP5Y6ZUJKAIZ4K74AN6GFGFZ2IVCU
#\\\|L55CZEYUDP22IUROODCDQM2CSJLQSU7GMVL4H7ZZCAPLVPG7K2G \ / AMOS7 \ YOURUM ::
#\[7]Y7ROHWPYXAEZHYKT6J5ZCTA442EOJVBQWSF2XBQERK4GCCGLB2DA 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
