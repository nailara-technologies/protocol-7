## [:< ##

# name  = keys.console.list
# param = [nochecksums]
# descr = list C25519 key names \ files for current user
# note  = Protocol-7 keys list | grep ' : .*:' | sed 's|.* : ||'

my $param = shift;

my $display_checksums = TRUE;    ## true ##

$display_checksums = FALSE if defined $param and $param eq qw| nochecksums |;

my %C            = %AMOS7::C;
my $key_vars_ref = <[crypt.C25519.key_vars]>;
my $name_regex   = qr|[0-9a-zA-Z\._\-]+|;
my $key_dir      = $key_vars_ref->{'key_dir'};
my $key_usr      = $key_vars_ref->{'usr_name'};

my $keys_re        = <keys.regex>;
my $key_re_public  = $keys_re->{'key_file'}->{'public'};
my $key_re_private = $keys_re->{'key_file'}->{'private'};

## warns when absent ##
my @k_files = grep {s|^.+/||} <[keys.get_keyfiles]> or return;

my %key_chksums;
if ($display_checksums) {    ## calculating key checksums ##
    my $calculating_message = 'calculating C25519 key checksums ..,';
    <[base.log]>->( 1, $calculating_message );
    if ( not <system.verbosity.console> ) {
        $OUTPUT_AUTOFLUSH = TRUE;
        if ( <system.ansi_color> or <system.force_colors> ) {
            printf "\n: %s%s\r", $C{0}, $calculating_message;
        } else {
            printf "\n: %s\r", $calculating_message;  ## todo : detect pipe ##
        }
    }

    %key_chksums = ( <[keys.checksum_href]>->%* ); ##  uses cache look-ups  ##

    foreach my $name ( <[base.sort]>->( \%key_chksums ) ) {
        <[base.logs]>->( 0, "failed to acquire checksum for key '%s'", $name )
            if not defined $key_chksums{$name};
    }
}

my @display_kfiles;

foreach my $file (@k_files) {
    push @display_kfiles, $file;
    if ( $file =~ m|([^/]+):seed-phrase$| ) { ## : todo :  add single keys  ##
        push @display_kfiles,
            sprintf( qw| :.virtual.::%s |, $LAST_PAREN_MATCH );
    }
}

my $key_name;
my %key_names;
my $max_nlen = 0;
foreach my $file (@display_kfiles) {
    my $name = <[crypt.C25519.get_keyname]>->($file);
    $name //= qw| read.err |;
    $key_names{$file} = sprintf qw| '%s' |, $name;

    my $length = length $name;

    if ( $file =~ m|::| or $file =~ m{$key_re_public} ) {
        if ( not $display_checksums ) {
            my $spaces = ' ' x length $name;
            $key_names{$file} = sprintf ' %s ', $spaces;
        } elsif ( defined $key_chksums{$name} ) {
            $key_names{$file}
                = sprintf( ' %*s ', $length, $key_chksums{$name} );
        }
    }

    my $l = length $key_names{$file};
    $max_nlen = $l if $l > $max_nlen;

    $max_nlen = length $key_chksums{$name}
        if $display_checksums
        and length( $key_chksums{$name} // '' ) > $max_nlen;
}

<[base.logs]>->( "listing key files ['%s']", $key_dir );

my $linefeed        = $display_checksums ? '' : "\n";
my $key_list_string = join '',
    $linefeed, sprintf( "%40s\r :: keys for user %s :.\n :\n", '', $key_usr ),
    ( map { sprintf( " : %*s : %s\n", $max_nlen, $key_names{$ARG}, $ARG ) }
        @display_kfiles ),
    "::\n";

## colorizing ##
##
if ( <system.ansi_color> or <system.force_colors> ) {
    $key_list_string =~ s|^(.+)$|$C{T}$1$C{R}|mg;
    $key_list_string =~ s|('.+')|$C{B}$1$C{R}$C{T}|mg;
    $key_list_string =~ s|(*plb:user)( \S+ )|$C{B}$C{b}$1$C{R}$C{T}|mg;
    $key_list_string =~ s,(<:.+:>|encrypted),$C{0}$C{b}$1$C{R}$C{T},mg;
    $key_list_string
        =~ s,($name_regex\Q:seed-phrase\E),$C{0}$colors{B01}$1$C{R}$C{T},mg;
    $key_list_string
        =~ s,(:.virtual.::),$C{0}$colors{B01}$1$C{R}$C{T}$C{B}$C{B02},mg;
}

return say $key_list_string;

#,,,,,,.,,,,.,,.,,,.,,...,.,.,,..,,,,,,..,,..,..,,...,...,.,,,,..,...,,..,,.,,
#HPOEMBIEPWCHCOGI4DZ65XC435HFO2AJHA3Y62LXPGDOT3ZTO6LITO5JEWG66CZEX24ZE2EH5ZQLK
#\\\|VMWHJ57ROTQFNNVAMZT4Z7XG2ETQ5Z67PL7AVEMMEBHPM4ADG3Y \ / AMOS7 \ YOURUM ::
#\[7]5CBMBO3P57IAUTOUKSNFWKLGVSRAQ6F2NLXVNFCDUPWU6V53CKAI 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
