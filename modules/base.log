## [:< ##

# name  = base.log
# descr = generate a log entry
# args  = log_level log_msg [log_buffer] [time-stamp]
# note  = used routines here need to be registered in protocol-7 [purge_code]

my ( $log_level, $log_msg, $log_buffer, $time_stamp )
    = ( $ARG[0] || 0, $ARG[1] // '', $ARG[2] // '', $ARG[3] );

if ( $log_level !~ m|^\d+$| ) {
    $log_level = 0;
    $log_msg   = sprintf 'LOG-LEVEL not numerical %s', scalar <[base.caller]>;
}
<system.verbosity.console>       //= 0;
<system.verbosity.zenka_buffer>  //= 1;
<system.verbosity.zenka_logfile> //= 0;

return TRUE    ## true ##
    if $log_level > <system.verbosity.console>
    and $log_level > <system.verbosity.zenka_buffer>
    and $log_level > <system.verbosity.zenka_logfile>;

$log_buffer = qw| zenka | if not length $log_buffer;

my $log_str;
if ( not length $log_msg ) {
    $log_msg = sprintf 'UNDEF LOG MSG %s', scalar <[base.caller]>;
}

## reducing calculation load., ##
##
my $h_override   = <base.ntime-harmony> // TRUE;
my $want_harmony = $log_level < 3 ? $h_override : FALSE;
##
$want_harmony = FALSE    ## skipping harmonizing when not to disk ##
    if $log_level > 1 or <system.verbosity.zenka_logfile> > 1;

$log_msg =~ s|\r|\\r|g;
$log_msg =~ s|\n|\\n|g;
$log_msg =~ s|\0|\\0|g;
$log_msg =~ s|\e|\\e|g;

## prevent deep recursions in error log system ###
##
my $fatal_exit
    = ( $log_msg =~ m|deep recursion |i and $log_msg =~ m,log|buffer, )
    ? TRUE
    : FALSE;

$log_msg = sprintf( "%scall to unknown subroutine while executing '%s'",
    $colors{'p7_fg_0002'}, ${^CAPTURE}[0] )
    if $log_msg
    =~ m|\$code\{'([^\']*)'\}.+ use string \(""\) as a subroutine|;

my $zenka_prefix = <[log.format_name]>;

## log colors ##
##
my $c_l = 2;
$c_l = 3 if $log_level == 0;
$c_l = 4 if $log_level == 1;
$c_l = 1 if $log_level == 2;
$c_l = 0 if $log_level > 2;
my $c_fg  = $colors{ sprintf qw| p7_fg_000%s |, $c_l };
my $col_b = $log_level == 0 ? $colors{'B02'} : $colors{'B01'};
##
if ( $log_level > 0 ) {
    $log_str = sprintf '%s %s%s%s%s',
        $zenka_prefix, $col_b, $c_fg, $log_msg, $colors{'reset'};
} else {
    $log_str = sprintf '%s %s%s%s%s%s', $zenka_prefix, $colors{'bold'},
        $col_b,
        $c_fg, $log_msg, $colors{'reset'};
}

if ($fatal_exit) {    ## improve detection ## [LLL]
    say STDERR sprintf( "%s%s%s\n<< EMERGENCY SHUTDOWN >> %s",
        $log_str, $zenka_prefix, $colors{'p7_fg_0002'},
        '[ anticipated deep recursion in log system ]' );
    exit 2;
}

##  zenka log buffer  ##
##
if ( defined $code{'base.buffer.add_line'} ) {

    $time_stamp //= <[base.anum_log_time]>->( 5, $want_harmony );
    <[base.buffer.add_line]>->(
        $log_buffer, join( ' ', $time_stamp, $log_level, $log_msg ),
        $log_level
        )
        if $log_level <= <system.verbosity.zenka_buffer>
        or $log_level <= <system.verbosity.zenka_logfile>;

} elsif ( not defined $code{'base.buffer.add_line'}
    and $log_level <= <system.verbosity.zenka_buffer> ) {

    $time_stamp //= <[base.anum_log_time]>->( 5, $want_harmony );

    push <system.start.zenka-buffer>->@*,
        join( ' ', $time_stamp, $log_level, $log_msg );
}

## console output ##
##
if ( length fileno(STDOUT) and $log_level <= <system.verbosity.console> ) {
    if ( utf8::is_utf8($log_str)
        and defined $code{'base.utf8.clean_str'} ) {
        <[base.utf8.clean_str]>->( \$log_str, 2, 2 ); ## warn level 2 ##
    }
    say $log_str;    ## clean UTF-8 passed through ##
}
##

return TRUE;

#,,,.,...,,,,,,,.,..,,.,.,.,,,...,,,,,,..,...,..,,...,...,,.,,.,.,,,.,..,,...,
#3BNBT45MOTEJUXBCZNBN7OFTGVM7LMXC6JNVMDQWSZBQUTDVQON7LEMYMMVGEZH2ZW2MRCJO34IL2
#\\\|CL4ARQDML3WWG4SWZW757KTBCNBUN5N3KZ57YDHVMJYKTAR3QEO \ / AMOS7 \ YOURUM ::
#\[7]E5VVLP4NDUE5D34NDCCOLHDKSXGUNP2KJVMXCS7V6ONCQNHHHCBY 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
