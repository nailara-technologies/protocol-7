## >:] ##

# name  = base.event.add_signal
# descr = assigns new signal handler and cancels old one if it existed

my $signal  = $ARG[0]->{'signal'};
my $handler = $ARG[0]->{'handler'};

my $callback;

if ( defined $handler and defined $code{$handler} ) {
    $callback = sub { $code{$handler}->() };
} elsif ( not defined $handler and defined $ARG[0]->{'cb'} ) {
    $callback = $ARG[0]->{'cb'};
} elsif ( defined $handler ) {
    <[base.s_warn]>->( "nonexistent callback '%s' configured", $handler );
    return undef;
} elsif ( not defined $handler and not defined $ARG[0]->{'cb'} ) {
    warn 'no handler \ callback for signal event defined <{C1}>';
    return undef;
}
<watcher.signal> //= {};

<watcher.signal>->{$signal}->cancel if exists <watcher.signal>->{$signal};

if ( defined $SIG{$signal} ) {
    <[base.logs]>->( 2, 'unregistering $SIG{%s} ..,', $signal );
    undef $SIG{$signal};
}
if ( defined $handler ) {
    <[base.logs]>->(
        2,        'setting up handler %s for signal %s .,',
        $handler, $signal
    );
} else {
    <[base.logs]>->(
        2, 'setting up signal %s handler with custom cb .,', $signal
    );
}

eval {
    <watcher.signal>->{$signal} = Event->signal(
        'signal' => $signal,
        'cb'     => $callback,
        'desc'   => "signal handler [$signal]",
        'prio'   => 0
    );
};

if ($EVAL_ERROR) {
    delete <watcher.signal>->{$signal};
    ( my $reason = "$EVAL_ERROR" ) =~ s| at .+$|<{C}>|;
    warn $reason;
    return undef;
}

return <watcher.signal>->{$signal};

#,,.,,..,,,..,..,,.,.,..,,,,.,,..,.,,,,,.,,,.,..,,...,...,,,.,,,,,.,,,.,,,,.,,
#WCD67TE7FRT2QE4YLBEL3MER7QJFACT72HABOVX6N6BHLRUUNBUKTYHKCEYBB2FEFGIR5GNVBGD3Y
#\\\|HPXWHQHPVQ66O2CQAUWMO5RFD6RUNCRG5NRPBQMVKBJVNE6N5PQ \ / AMOS7 \ YOURUM ::
#\[7]U2WFJH7SGXAUBONM6KOU7PBK475TT6CZW6LR6XGUTOWRTP5U7KAI 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
