# >:]

# name = root.handler.agent_status

my ( $instance_id, $status ) = @_;
die "no instance id specified" if not defined $instance_id;
die "no status submitted"      if not defined $status;
die "no such agent instance ($instance_id)"
    if not exists <root.agent.instance>
    or not exists <root.agent.instance>->{$instance_id};

my $globals      = <root.spawn_config.globals> || {};
my $instance     = <root.agent.instance>->{$instance_id};
my $old_status   = $instance->{'status'} || $status;
my $agent_id     = $instance->{'agent_id'};
my $object_id    = <[agent.get_object_id]>->($agent_id);
my $agent_name   = <root.agent.setup>->{$agent_id}->{'name'};
my $job_id       = $instance->{'job_id'};
my $agent_config = <root.spawn_config.agents.config>->{$agent_name};
$instance->{'respawn_delay'}
    //= $agent_config->{'respawn'}->{'min_delay'}
    || $globals->{'respawn'}->{'min_delay'}
    || 0.1;    # <-- minimum respawn delay default (in seconds)
my $max_respawn_delay
    = $agent_config->{'respawn'}->{'max_delay'}
    || $globals->{'respawn'}->{'max_delay'}
    || 300;    # <-- 5 minutes (internal default)
my $status_timer_delay
    = $agent_config->{'ping'}->{'after'}
    || $globals->{'ping'}->{'after'}
    || 2;      # <-- (initial) ping delay default
my $status_timer_interval
    = $agent_config->{'ping'}->{'interval'}
    || $globals->{'ping'}->{'interval'}
    || 5;      # <-- ping interval default
delete $agent_config->{'respawn'} if !keys %{ $agent_config->{'respawn'} };
delete $agent_config->{'ping'}    if !keys %{ $agent_config->{'ping'} };
delete $globals->{'respawn'}      if !keys %{ $globals->{'respawn'} };
delete $globals->{'ping'}         if !keys %{ $globals->{'ping'} };

# prevent undesired core shutdown (session.check.last)
if ( $status eq 'offline' and exists $instance->{'session_id'} ) {
    <[base.log]>->( 0, "removing session.close_last callback.." );
    delete <callback.session.close_last>;
}

# 'root-post-init' code
my $init_code = <root.spawn_config.agents.startup.init_code>->{$agent_name};
if ( $status eq 'online' and exists $init_code->{'root-post-init'} ) {
    <[base.log]>->( 2, "'$agent_name'-agent post-init-code.." );
    my @post_init_code = <[base.parser.config]>->(
        $init_code->{'root-post-init'},
        "\$data{'root'}{'agent'}{'instance'}{$instance_id}{'init_data'}"
    );
    map { $_ =~ s/<instance_id>/$instance_id/g } @post_init_code;
    <[base.execute_agent_code]>->(@post_init_code);
}
if (    $status eq 'online'
    and exists $init_code->{'root-post-init'}
    and exists $instance->{'init_data'} ) {
    my $init_status = $instance->{'init_data'}->{'status'} || {};
    if ( not exists $init_status->{'post-init'}
        or !$init_status->{'post-init'} ) {
        <[base.log]>->(
            0, "instance $instance_id : failure in post-init code!"
        );
        $status = 'failed';
    }
    <[base.log]>->( 2, "cleaning up instance $instance_id init_data" );
    delete $instance->{'init_data'};
}

$instance->{'status'} = $status;
<[base.log]>->( 1, "agent '$agent_name' changed status to '$status'" );

# quickly terminate leftover processes
if (    $status ne 'starting'
    and $status ne 'online'
    and exists $instance->{'process'} ) {
    my $pid = $instance->{'process'}->{'id'};
    <[base.log]>->( 1, "instance $instance_id : killed process $pid !" );
    my $proc_table = new Proc::ProcessTable;
    my @children;
    foreach my $proc ( @{ $proc_table->table } ) {
        push( @children, $proc->{'pid'} )
            if $proc->{'ppid'} == $pid;
    }
    <[base.log]>->( 1, "instance $instance_id : killed process $pid !" )
        if kill( 9, $pid );    # XXX: 15 + timeout
    my $ren = scalar @children == 1 ? '' : 'ren :';
    <[base.log]>->(
        1, ": terminating instance child$ren " . join( ', ', @children )
    ) if @children;
    kill( 9, @children );
}

# instance startup failure hooks
if (    $old_status eq 'starting'
    and $status eq 'failed' ) {
    $instance->{'respawn_delay'} *= 2;
    if ( exists $init_code->{'startup-failure'} ) {
        <[base.execute_agent_code]>
            ->( <[base.parser.config]>->( $init_code->{'startup-failure'} ) );
    } else {  # <- prevents a failure race condition (getting stuck in 'failed')
        delete $instance->{'core_sid'};
        <[agent.change_status]>->( $instance_id, 'offline' );
        return;
    }
}

# select correct target job queue
my $target_queue;
$target_queue = 'running' if $status eq 'online';
$target_queue = 'failed'  if $status eq 'failed';
$target_queue = 'queued'  if $status eq 'offline';

<[jobqueue.move_job]>->( $instance->{'job_id'}, $target_queue )
    if defined $target_queue and $target_queue ne 'queued';

# delayed respawning on startup failure (slowing down with failures..)
if ( defined $target_queue and $target_queue eq 'queued' ) {
    $instance->{'respawn_timer'}->cancel if exists $instance->{'respawn_timer'};
    $instance->{'respawn_delay'} = $max_respawn_delay
        if $instance->{'respawn_delay'} > $max_respawn_delay;
    <[base.log]>->(
        1,
        "instance $instance_id [$agent_name] respawn delay"
            . " = $instance->{respawn_delay}s"
    );
    $instance->{'respawn_timer'} = <[event.add_timer]>->(
        {   'after'   => $instance->{'respawn_delay'},
            'handler' => 'root.callback.instance.respawn',
            'data'    => $instance_id
        }
    );
}

if (    $status ne 'online'
    and $status ne 'starting'
    and $old_status eq 'online' ) {
    delete $instance->{'core_sid'};

    # shutdown instances with unresolved dependencies
    foreach my $dep_id ( <[dependency.get_reverse]>->($object_id) ) {
        next if <[dependency.ok]>->($dep_id);
        map { <[agent.instance.restart]>->($_) } @{
            <[agent.instance.get_ids]>->(
                <dependency.object>->{$dep_id}->{'agent_id'}
            )
        };
    }
}

if ( $old_status ne 'online' and $status eq 'online' ) {
    delete $instance->{'respawn_delay'};    # reset

    # installing a timer to check instance status
    <[base.log]>->(
        2, "setting up response timer for instance $instance_id [$agent_name].."
    );

    # cancel old timers first...
    $instance->{'status_timer'}->cancel
        if exists $instance->{'status_timer'}
        and $instance->{'status_timer'}->is_active;
    $instance->{'timeout_timer'}->cancel
        if exists $instance->{'timeout_timer'}
        and $instance->{'timeout_timer'}->is_active;

    # set up new status timer..
    $instance->{'status_timer'} = <[event.add_timer]>->(
        {   'after'    => $status_timer_delay,
            'interval' => $status_timer_interval + sprintf( "%.3f", rand(2) ),
            'handler'  => 'root.handler.status_timer',
            'data'     => $instance_id
        }
    );

    # clean up temporary agent instance startup data
    delete $instance->{'init_data'};

    # start next delayed agent of the same name ...
    foreach my $id ( @{ <[agent.instance.get_ids]>->($agent_id) } ) {
        next
            if $id == $instance_id
            or <root.agent.instance>->{$id}->{'status'} ne 'delayed';
        my $j_id = <root.agent.instance>->{$id}->{'job_id'};
        <[base.log]>->( 1, "starting delayed '$agent_name' agent instance .." );
        <[jobqueue.exec_job]>->($j_id);
        last;
    }
}

<[jobqueue.check_dependencies]>;
