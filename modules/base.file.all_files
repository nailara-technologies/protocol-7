## >:] ##

# name = base.file.all_files

my ( $path, $result_aref, $resolved ) = @ARG;

if ( not defined $path or not length $path ) {
    warn 'path param missing or undefined <{C1}>';
    return undef;
}

my $old_path;
my $recursive         = 0;
my $recursion_entered = 0;
$resolved //= 0;    # <-- resolve symlinks
$resolved = 5 if $resolved eq qw| resolved |;

if ( not defined $result_aref ) {
    $result_aref = [];
} elsif ( $result_aref eq qw| recursive | ) {
    $result_aref = [];
    $recursive   = 5;    ## true ##
} else {
    $recursion_entered = 5;    ## true ##
}

if ( not -d $path ) {
    <[base.s_warn]>->( "non existant path ['%s'] <{C1}>", $path );
    return undef;
} else {
    my $dir_fh;
    $path =~ s|/+$||;
    if ( not opendir( $dir_fh, $path ) ) {
        <[base.s_warn]>->(
            "directory path '%s' [ %s ] <{C1}>",
            $path, <[base.str.os_err]>
        );
        return undef;
    }
    foreach my $entry ( <[base.sort]>->( readdir($dir_fh) ) ) {
        next if $entry =~ m|^\.{1,2}$|;
        my $path_abs = catfile( $path, $entry );
        my $result_path
            = $resolved ? abs_path($path_abs) : canonpath($path_abs);
        push $result_aref->@*, $result_path if -f $path_abs;
        <[file.all_files]>->( $result_path, $result_aref, $resolved )
            if -d $path_abs and $recursive;
    }
}

return $result_aref if not $recursion_entered;

#,,,,,,.,,...,,.,,,..,...,,,.,,.,,,.,,,..,..,,..,,...,...,.,,,,..,...,.,,,..,,
#JL7GR63VQFM2XM7OERYZLIFPI7L2QL7CKEC3YNNO5TXITNF3AU5SNJX4PRA3WNUUVILI5O7Z3UDCC
#\\\|LHQIYC2J4Q3IGKTAEXED5F243WH3XHQO7GBDSFKDYRYUF4BS6LY \ / AMOS7 \ YOURUM ::
#\[7]KZTFBFPEDAFJY2BOR5WIJ7I55643547YWN33IILS2W7ORQR7BKBQ 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
