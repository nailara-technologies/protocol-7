## >:] ##

# name  = keys.console.get-encoded-key
# param = <name>
# descr = show encoded key string opt.: [private|public]

my $name = shift;
return print "\n  << expected <key_name> parameter >>\n\n"
    if not defined $name;
my $type;
( $name, $type ) = split m| +|, $name if index( $name, ' ' ) != -1;

return printf "\n  << key with name '%s' not found >>\n\n", $name
    if not <[crypt.C25519.key_exists]>->($name);

my $key_vars_ref = <[crypt.C25519.key_vars]>->($name);

my $maxlen
    = [ minmax map {length}
        grep { -e $key_vars_ref->{'key_filename'}->{$ARG} }
        keys $key_vars_ref->{'key_filename'}->%* ]->[1];

if ( defined $type and my $file = $key_vars_ref->{'key_filename'}->{$type} ) {
    my $key_file_ref = <[file.slurp]>->($file);
    chomp $key_file_ref->$*;
    return say $key_file_ref->$*;
} elsif ( defined $type ) {
    print "\n  <<  type parameter not understood  >>\n\n";
    say '  [ key types ]';
    say '  :';
    foreach my $type ( <[base.sort]>->( $key_vars_ref->{'key_filename'} ) ) {
        say sprintf "  :  %-*s  :", $maxlen, $type;
    }
    say '  :';
} else {
    foreach my $type ( <[base.sort]>->( $key_vars_ref->{'key_filename'} ) ) {
        my $file = $key_vars_ref->{'key_filename'}->{$type};
        next if not -e $file;    ## only existing types ##
        my $key_file_ref = <[file.slurp]>->($file);
        chomp $key_file_ref->$*;
        say '';
        say sprintf ':. %-*s .: %s ::', $maxlen, $type, $key_file_ref->$*;
    }
    say '';
}

#,,..,.,,,,,,,.,.,.,,,,.,,,.,,,,.,,.,,.,.,,,.,..,,...,..,,.,.,,..,,.,,.,.,,.,,
#K2MKXKUVPER6GBDGOS36BCBOICNP6UYNLG7E53HVEWM2UTFGAHHVUI7U6INDKAVYFEZESD5RY27CA
#\\\|KCTYZFIN6U4KPYWEZZHXGCMX42H4I6JDQMD2DFVTICQSOBW2C2S \ / AMOS7 \ YOURUM ::
#\[7]F34VPN7GAFE4NSAGSQQY6RHTBLUVT6OYWWRTG62LI5T62YOUFYDQ 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
