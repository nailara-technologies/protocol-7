## >:] ##

# name  = debug.cmd.exec-sub
# param = <sub_name>
# descr = run subroutine and return output

my $support_params = <debug.exec-sub.allow-params> // 0;    ##  config  ##
( my $sub_name, my @params )
    = split( m| +|, $call->{'args'} );    ## quotes not supported ##

return {
    'mode' => qw| false |,
    'data' => 'expected subroutine name parameter'
    }
    if not length $sub_name;
return {
    'mode' => qw| false |,
    'data' => 'subroutine parameters are not supported'
    }
    if @params and not $support_params;

return { 'mode' => qw| false |, 'data' => 'no such subroutine' }
    if not exists $code{$sub_name};

my @sub_output = eval { $code{$sub_name}->(@params) };

my $err_str;
if ( length $EVAL_ERROR ) {
    $err_str = <[base.format_error]>->($EVAL_ERROR);
    $err_str = 'undefined error' if not length $err_str;
}

my $err_msg;
$err_msg = 'errors during subroutine execution' if $EVAL_ERROR;
$err_msg = 'undefined subroutine output'
    if not defined $err_msg and @sub_output == 0
    or @sub_output == 1 and not defined $sub_output[0];
return { 'mode' => qw| false |, 'data' => $err_msg } if defined $err_msg;

map { $ARG //= 'UNDEF' } @sub_output if @sub_output > 1;

map { ( $ARG = Dumper($ARG) . "\n" ) =~ s|^\$VAR1 =|| if length( ref $ARG ) }
    @sub_output;

my $rep_mode = qw| true |;
if ( @sub_output == 1 ) {
    $sub_output[0] =~ s|\n$|| if $sub_output[0] =~ m|\n| <= 1;
    $rep_mode = 'data' if $sub_output[0] =~ m|\n|;
}

return { 'mode' => $rep_mode, 'data' => join( ', ', @sub_output ) };

#,,..,.,.,,..,,.,,.,.,,..,,,.,,..,,..,,..,,..,..,,...,..,,..,,..,,,.,,,,.,..,,
#6ZPNZUPTHZVKAKQF65XXZJBAPNWYUIAMUZGAGUZYWSY25EDDQ7MSAIYDFTZ3F4T6DNTHOOIVYD3GA
#\\\|DD3LH6QE23RBZ4DLCX56B36FYAZOSCJ45G7Z47ZLTAZM5FHTIPB \ / AMOS7 \ YOURUM ::
#\[7]L6FTP3H4E5SUP7R3QWDEJHD7HT7MYLGZ6TDPEN6WRCVOHPKRV2AQ 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
