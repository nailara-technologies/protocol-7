## [:< ##

# name = ssh.connection.start
# todo = config validation ( check for syntax + missing keys/values )

my $con_id;
my $link_name;
my $connection;
my $profile_name;
if ( @ARG == 1 and $ARG[0] =~ m|^\d+$| ) {
    $con_id       = shift;
    $connection   = $data{'ssh'}{'connections'}->{$con_id};
    $link_name    = $connection->{'name'};
    $profile_name = $connection->{'profile'};
} else {
    $profile_name = shift // '';
    $link_name    = shift // '';
}
my $ssh_timeout = <ssh.cfg.globals>->{'connections.timeout'};
$ssh_timeout //= 10;    # default timeout (seconds)
die "expected ssh profile name\n" if not length $profile_name;
die "expected ssh link name\n"    if not length $link_name;
die "ssh profile '$profile_name' does not exist\n"
    if not exists <ssh.cfg.profiles>->{$profile_name};
my $profile_data = <ssh.cfg.profiles>->{$profile_name};
die "link '$link_name' not found in ssh profile '$profile_name'\n"
    if not exists $profile_data->{$link_name};

my $link_setup = $profile_data->{$link_name};

my $ssh_addr = $link_setup->{'ssh.addr'};
my $ssh_port = $link_setup->{'ssh.port'};

<[base.logs]>->(
    ": link start-up : '%s' [%s:%u]",
    $link_name, $ssh_addr, $ssh_port
);

if ( not defined $con_id ) {
    $con_id = <[base.gen_id]>->( $data{'ssh'}{'connections'} );
    $data{'ssh'}{'connections'}->{$con_id} //= {};
    $connection = $data{'ssh'}{'connections'}->{$con_id};

    $connection->{'name'}        = $link_name;
    $connection->{'profile'}     = $profile_name;
    $connection->{'target_host'} = $ssh_addr;
    $connection->{'target_port'} = $ssh_port;

    $data{'ssh'}{'profiles'}->{$profile_name}->{$link_name} //= [];
    push
        $data{'ssh'}{'profiles'}->{$profile_name}->{$link_name}->@*,
        $con_id;

    <ssh.status.connections>->{$con_id} = qw| offline |;
}

my $ssh = Net::SSH2->new();
$ssh->timeout( $ssh_timeout * 1000 );

my $sock = IO::Socket::IP->new(
    PeerHost => $ssh_addr,
    PeerPort => $ssh_port,
    Timeout  => $ssh_timeout,
);

if ( not $sock ) {
    <[base.logs]>->(
        0, ': : tcp connection error [ %s ]',
        <[base.str.os_err]>
    );
    goto error;
}

$sock->sockopt( SO_LINGER(), pack( 'SS', 0, 0 ) );

if ( not $ssh->connect($sock) ) {
    <[base.log]>->(
        0, ': : ssh connection error [ %s ]',
        <[base.str.os_err]>
    );
    $sock->shutdown(qw| NOW |) if $sock->connected;
    goto error;
}

<[base.log]>->( 2, ": : ssh connection established.." );

my $configured_hostkey = join( qw| + |,
    $link_setup->{'ssh.hostkey.elf'},
    $link_setup->{'ssh.hostkey.bmw'} );

my $remote_hostkey_bin = $ssh->remote_hostkey;
my $ELF7   = encode_b32r pack qw| w |, elf_chksum($remote_hostkey_bin);
my $BMW224 = encode_b32r bmw_224($remote_hostkey_bin);

my $host_key = join qw| + |, $ELF7, $BMW224;

if ( $host_key ne $configured_hostkey ) {
    <[base.logs]>->(
        0, ': : << ! >> SSH HOSTKEY [%s] IS NOT VALID', $host_key
    );
    $ssh->disconnect;
    $sock->shutdown(qw| NOW |);
    goto error;
} else {
    my $hk_str = $host_key;
    substr( $hk_str, 10, 35, '..,' );
    <[base.logs]>->( ': : hostkey accepted [%s]', $hk_str );
}

my $ssh_user = $link_setup->{'ssh.user'};

my %auth_methods = map { $ARG => TRUE } $ssh->auth_list($ssh_user);

<[base.log]>->( 2, ": : password auth. is enabled.,[!]" )
    if exists $auth_methods{'password'};
if ( not exists $auth_methods{'publickey'} ) {
    <[base.logs]>->(
        0, ": : << ! >> no public key auth. for user '%s' available ..,",
        $ssh_user
    );
    $ssh->disconnect;
    $sock->shutdown(qw| NOW |);
    goto error;
} else {
    <[base.log]>->( 2, ': : public key auth. is available..' );
}

my $ssh_keyfile = $link_setup->{'ssh.keyfile'};
my $ssh_privkey = $ssh_keyfile;
my $ssh_pubkey  = sprintf qw| %s.pub |, $ssh_keyfile;

foreach my $key_type ( 'private', 'public' ) {
    my $key_file = $key_type eq 'private' ? $ssh_privkey : $ssh_pubkey;
    if ( !open( my $test_fh, '<' . $key_file ) ) {
        <[base.logs]>->(
            0,         ": : SSH AUTH ERROR [ unable to open %s key : %s ]",
            $key_type, <[base.str.os_err]>
        );
        $ssh->disconnect;
        $sock->shutdown(qw| NOW |);
        goto error;
    }
}

if ( !$ssh->auth_publickey( $ssh_user, $ssh_pubkey, $ssh_privkey ) ) {
    my ( $err_code, $err_name, $err_str ) = $ssh->error;
    <[base.logs]>->( 0, ': : SSH AUTH ERROR [ %s ]', lcfirst $err_str );
    $ssh->disconnect;
    $sock->shutdown(qw| NOW |);
    goto error;
}
<[base.log]>->( 1, ": : ssh auth. successful.." );

my $proto_7_addr = $link_setup->{'proto-7.remote.addr'};
my $proto_7_port = $link_setup->{'proto-7.remote.port'};

my $channel = $ssh->tcpip( $proto_7_addr, $proto_7_port );
if ( not defined $channel ) {
    <[base.log]>->(
        0, ': : remote proto-7 connection error [ %s ]',
        <[base.str.os_err]>
    );
    $ssh->disconnect;
    $sock->shutdown(qw| NOW |);
    goto error;
}
$channel->blocking(0);

<[base.log]>->( 1, ": : nailara tunnel connection established.." );

$connection->{'io'}->{'ssh'} = <[event.add_io]>->(
    {   'fd'      => $sock,
        'handler' => qw| ssh.handler.ssh_io |,
        'data'    => {
            'con_id'       => $con_id,
            'ssh_obj'      => $ssh,
            'profile_name' => $profile_name,
            'link_name'    => $link_name
        }
    }
);

$connection->{'sock'}             = $sock;
$connection->{'obj'}              = $ssh;
$connection->{'nch'}              = $channel;
$connection->{'buffer'}           = '';
$connection->{'authorized'}       = FALSE;
$connection->{'linked'}           = FALSE;
$connection->{'heartbeat_errors'} = FALSE;
$connection->{'latency'}          = qw| unknown |;

delete $connection->{'retry_delay'}
    if exists $connection->{'retry_delay'};

<ssh.status.connections>->{$con_id} = 'online';

$connection->{'io'}->{'ssh'}->now;    # quickfix!

my $heartbeat_delay = 4.7;            # LLL: --> config..,
$connection->{'timer'}->{'heartbeat'} = <[event.add_timer]>->(
    {   'after'    => 1.2,
        'interval' => $heartbeat_delay,
        'repeat'   => TRUE,
        'handler'  => qw| ssh.handler.connection_heartbeat |,
        'data'     => $con_id
    }
);

return 1;

error:
<ssh.status.connections>->{$con_id} = qw| error |;
$connection->{'retry_delay'} *= 2
    if exists $connection->{'retry_delay'};
$connection->{'retry_delay'} //= 0.5;    # LLL: --> config!
$connection->{'retry_delay'} = 30 if $connection->{'retry_delay'} > 30;

<[base.logs]>->(
    ': : : retrying in %s seconds ..,',
    $connection->{retry_delay}
);

$connection->{'timer'}->{'reconnect'} = <[event.add_timer]>->(
    {   'after'   => $connection->{'retry_delay'},
        'handler' => 'ssh.handler.connection_retry',
        'data'    => $con_id
    }
);

return 0;

#,,..,...,,,,,..,,,.,,,,.,..,,.,,,,.,,,,.,,.,,..,,...,...,.,,,.,.,,,.,,..,,,,,
#CDTVVXAC5JXNITWHBDGA5FX5HBH7Z7G7L6MORBDKQ4TV2BWBDK6D4B4SOGA4XHP2WGUQI6GNWBMUO
#\\\|K3AZ776X6PV7PVCXCX5IIYRS4APEI4Z2GNFYUEANWJLXC46D5TR \ / AMOS7 \ YOURUM ::
#\[7]T6UDAJNACF5IKQ7W6ZGFBTZABXALSHFULWL3F7OCHMLMJQDB4ACI 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
