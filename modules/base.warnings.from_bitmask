## [:< ##

# name  = base.warnings.from_bitmask
# descr = return hashref with category keys for enabled warnings

my $warning_bitmask = shift // '';  ## accepts ${^WARNING_BITS} style masks ##

if ( not length $warning_bitmask ) {
    warn 'expected warnings bitmask parameter <{C1}>';
    return undef;
} elsif ( length($warning_bitmask) > length( $warnings::Bits{'all'} ) ) {
    warn 'supplied warnings bitmask exceeded registered bit size <{C1}>';
    return undef;
}

state @categories;                  ##  caching sorted category names  ##
@categories
    = sort { length $a <=> length $b } reverse sort keys %warnings::Offsets
    if not @categories;

my %categories_enabled = ( qw| fatal | => {}, qw| normal | => {} );

foreach my $category (@categories) {
    my $warnings_mode = qw| normal |;

    ##  normal, then fatal bitmask offset  ##
    foreach my $category_bitmask_offset ( $warnings::Offsets{$category},
        $warnings::Offsets{$category} + 1 ) {

        $categories_enabled{$warnings_mode}{$category}
            = vec( $warning_bitmask, $category_bitmask_offset, 1 )
            ? 5     ## true ##
            : 0;    ##  false  ##

        $warnings_mode = qw| fatal |;    ## 'fatal' mode for second bitmask ##
    }
}

return \%categories_enabled;

#,,,.,,..,,,,,...,,.,,...,.,.,,,.,,.,,.,,,..,,..,,...,..,,...,,,.,...,,..,.,,,
#AMBTO5PTAIHPOOZDF4L3MN2LG6NJ3TG25QJ4H7RKZOGVEX53GBD3A522XV5ZUHM7YEPBBQ2X2ILKY
#\\\|E37VO6JG2ALRKKMB7SEA64UQG3XXTRO3L6LVH22DIL6TPWMLUMN \ / AMOS7 \ YOURUM ::
#\[7]JHUKACN2QISUFICVIEOYV7PDJ7KN5Z3CX7JV36ZLYT7B6I2XAWDY 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
