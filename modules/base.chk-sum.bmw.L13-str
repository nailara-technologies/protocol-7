## >:] ##

# name  = base.chk-sum.bmw.L13-str
# descr = returns 13 character BASE32 string [ XORed BMW chk-sum segments ]

if ( not @ARG or grep { not defined } @ARG ) {
    warn 'expected defined input param[s] <{C1}>';
    return undef;
}

## start entropy ##
state $start_seed_num;
$start_seed_num //= unpack qw| Q |, pack qw| B64 |, '10000000' x 8;
my $bits_num = $start_seed_num;

foreach my $segment_num ( unpack qw| Q8 |, Digest::BMW::bmw_512(@ARG) ) {

    while ( not AMOS7::Assert::Truth::true_int($segment_num) ) {
        $segment_num = sprintf qw| %u |, $segment_num / 13;
    }

    $bits_num ^= $segment_num;    ## stringwise XOR ##

    while ( not AMOS7::Assert::Truth::true_int($bits_num) ) {
        $bits_num <<= 1;          ## make true ##
    }

}

my $result_str_B32 = encode_b32r( pack qw| Q |, $bits_num );

while (not AMOS7::Assert::Truth::is_true( $result_str_B32, 0, 1 )
    or not AMOS7::Assert::Truth::true_int($bits_num) ) {
    $bits_num = sprintf qw| %u |, $bits_num / 13;
    $bits_num <<= 5;
    $bits_num = 13 if $bits_num == 0;    ##  make sure to exit true if 0  ##
    ##  again until true  ##
    $result_str_B32 = encode_b32r( pack qw| Q |, $bits_num );
}

return $result_str_B32;    ##  13 characters  ##  [ a true value ]  ##

#,,,.,,.,,,,.,,,.,..,,..,,,,.,,,,,,.,,.,,,,..,..,,...,...,...,..,,,.,,.,,,.,.,
#S72H2PWPBE73U2MTGSRUM7ODA4AJ52UYIYFT43P27DC56S6I37GYMYENSU56ESJYAXLFILLGVDDRW
#\\\|MZAT4ETJRO47LUXBJ2FVTSRDUVBLVSL4KRAY2Y5N2CGJ7DHP45I \ / AMOS7 \ YOURUM ::
#\[7]EEUTCMKKFDVNDUTCWLSDHTYBEY6S2LXRTTJNFHNLD774MGJWR2CY 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
