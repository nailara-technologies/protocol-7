# >:]

# name = browser.handler.url_list_reply
# todo = implement continuous playback in case current file is in playlist!

my $reply = shift;

if ( $reply->{'cmd'} eq 'NACK' ) {
    my $msg = $reply->{'call_args'}->{'args'};
    <[base.log]>->( 0, "failed to fetch url list! [$msg]" );
    return;
}

if ( $reply->{'call_args'}->{'args'} == 0 ) {
    <[base.log]>->( 0, "received empty url list!" );
    @{<browser.url.list>} = ();
    <browser.slideshow.running> = 0;

    # XXX: parse/insert 'empty playlist'-page?
    <[browser.clear_views]>;
    return;
}

my ( $width, $height ) = ( $1, $2 )
    if <x11.geometry> =~ /^(\d+)x(\d+)/;

my @url_list;
my %type_list;
foreach my $reply_line ( split( "\n", $reply->{'data'} ) ) {
    push( @url_list, $2 ) if $reply_line =~ /^([^\s]+) +(.+)$/;
    $type_list{$2} = $1;
}

my $entry_count = scalar @url_list;

foreach my $url (@url_list) {
    my $url_txt = substr( $url, 0, 52 );
    $url_txt .= '...' if length($url_txt) < length($url);
    <[base.log]>->( 1, ": - $url_txt" );
}
<[base.log]>->( 1, ": $entry_count entries received" );

@{<browser.url.list_reply>} = @url_list;

my $index = 0;

### quickfix ( cleanup old url entries ) ###

@{<browser.url.list>} = ();

############################################

foreach my $entry (@url_list) {
    if ( $type_list{$entry} eq 'pdf' ) {
        <[base.proto.nailara.command.send.local]>->(
            {   'command'   => "core.pdf2html.get_url",
                'call_args' => { 'args' => "$entry $width" },
                'reply'     => {
                    'handler' => 'browser.handler.2html_reply',
                    'params'  => { 'index' => $index }
                }
            }
        );
        <browser.url.list_reply>->[$index]
            = '!' . <browser.url.list_reply>->[$index];

    } elsif ( $type_list{$entry} eq 'image' ) {
        <[base.proto.nailara.command.send.local]>->(
            {   'command'   => "core.image2html.get_url",
                'call_args' => { 'args' => "$entry $width $height" },
                'reply'     => {
                    'handler' => 'browser.handler.2html_reply',
                    'params'  => { 'index' => $index }
                }
            }
        );
        <browser.url.list_reply>->[$index]
            = '!' . <browser.url.list_reply>->[$index];

    } else {
        push( @{<browser.url.list>}, $entry );
    }
    $index++;
}

if (    @{<browser.url.list>}
    and <browser.slideshow.autostart>
    and !<browser.slideshow.running> ) {
    <[base.log]>->( 1, ": starting slideshow.." );
    <[browser.start_slideshow]>;
}
