# >:]

# name  = power.cmd.on
# descr = switch on a single socket [1..4]
# param = <id> <s-num>

<power.cfg.devices> //= {};
my ( $device_id, $sock_num ) = split( / +/, $$call{'args'} );

return { 'mode' => 'nack', 'data' => 'numerical device id expected' }
    if !length($device_id)
    or $device_id !~ /\d+/;

return {
    'mode' => 'nack',
    'data' => "device '$device_id' does not exist"
    }
    if not exists <power.cfg.devices>->{$device_id};

return { 'mode' => 'nack', 'data' => 'power socket number expected [1..4]' }
    if not defined $sock_num or $sock_num !~ /^[1234]$/;

my $dev = <[power.dev_obj]>->($device_id);

my @set_states = ( SOCK_SKIP, SOCK_SKIP, SOCK_SKIP, SOCK_SKIP );

my $index = $sock_num - 1;
$set_states[$index] = SOCK_ON;

$dev->_set_ctrl(@set_states);

my @states;
map {
    if (defined $dev->{'stat'}->[$_]
        and (  $dev->{'stat'}->[$_] == 17
            or $dev->{'stat'}->[$_] == 18
            or $dev->{'stat'}->[$_] == 65 )
        ) {
        $states[$_] = '1';
    } elsif (
        defined $dev->{'stat'}->[$_]
        and (  $dev->{'stat'}->[$_] == 33
            or $dev->{'stat'}->[$_] == 34
            or $dev->{'stat'}->[$_] == 130 )
        ) {
        $states[$_] = '0';
    } else {
        $states[$_] = 'E';
    }
} ( 0, 1, 2, 3 );

my $new_state = $states[$index];

if ( $dev->{poller}->can_write(0.1) ) {
    $dev->{sock}->send( chr(0x11) );
    $dev->{sock}->close();
}

if ( $new_state ne '1' ) {
    my $err_msg = 'failed to retrieve new socket state';
    $err_msg = 'failed to set socket state to \'ON\'' if $new_state eq '0';
    return { 'mode' => 'NACK', 'data' => $err_msg };
}

<[base.proto.nailara.command.send.local]>->(
    {   'command'   => "core.power-x11.set_states",
        'call_args' => { 'args' => join( ' ', $device_id, @states ) },
        'reply' => { 'handler' => 'dev.null' }
    }
);

return { 'mode' => 'ACK', 'data' => "socket $sock_num switched ON" }
