## [:< ##

# name  = discover.handler.anounce_host_addr

<[base.log]>->( 2, 'sending announce_host packet .,' );

my %ifconfig;
my $mlenip   = 0;
my $hostname = <system.host.hostname>;
my $ifaces = Net::Ifconfig::Wrapper::Ifconfig('list');  # [LLL] Net::Interface

<discover.announce_interval.current> //= 0.19;
<discover.announce_interval.maximum> //= sprintf qw| %.2f |, 40 + rand(2);
<discover.announce_interval.ifactor> //= 1.13;

<discover.announce_interval.logged> //= FALSE;
if ( not <discover.announce_interval.logged> ) {
    <[base.log]>->( 1, "starting 'announce host' broadcast interval ..," );
    <discover.announce_interval.logged> = TRUE;
}

my $payload_str = sprintf "HOST[ %s ] {\n", $hostname;
my $start_len   = length $payload_str;
foreach my $interface_nam ( keys $ifaces->%* ) {
    foreach my $ip_addr ( keys $ifaces->{$interface_nam}->{'inet'}->%* ) {

        if (<[base.is_defined_recursive]>->(
                qw| discover.mcast.broadcast_interfaces |)
        ) {
            my $match = FALSE;
            foreach my $iface_name_prefix ( split m|[\t ]+|,
                <discover.mcast.broadcast_interfaces> ) {
                $match = TRUE
                    if index( $interface_nam, $iface_name_prefix, 0 ) == 0;
            }

            next if not $match;    ##  skipping non-matching interfaces  ##

        } else {    ##  built-in default prefixes  ##

            ##               ##   skipping others   ##
            next if $interface_nam !~ m{^(cni\.|rni\.|en|\wth|wl)};
        }

        $mlenip = length($ip_addr) if length($ip_addr) > $mlenip;

        # final sort
        my $is_local = 0;

        # LINK-LOCAL
        $is_local++ if $ip_addr =~ m|^169\.254\.|;

        # RFC1918
        $is_local += 2 if $ip_addr =~ m[
                        (^10\.)|
                        (^127\.)|
                        (^192\.168\.)|
                        (^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)
                    ]x;

        # LLL: make prio patterns configurable!
        my $iface_prio = 0;
        $iface_prio-- if $interface_nam =~ m{^(cni\.|e(th|n))};
        $iface_prio++ if $interface_nam =~ m{^(rni\.|ath|wl(p|an))};

        $ifconfig{ <[base.gen_id]>->( \%ifconfig ) } = {
            qw| ip |         => $ip_addr,
            qw| mac |        => $ifaces->{$interface_nam}->{'ether'},
            qw| iface |      => $interface_nam,
            qw| is_local |   => $is_local,
            qw| iface_prio | => $iface_prio
        };
    }
}

my $x_pos = $mlenip + $start_len + 1;

foreach my $id (
    sort { $ifconfig{$b}{'is_local'}   <=> $ifconfig{$a}{'is_local'} }
    sort { $ifconfig{$a}{'iface_prio'} <=> $ifconfig{$b}{'iface_prio'} }
    sort {
        length( $ifconfig{$a}{'iface'} ) <=> length( $ifconfig{$b}{'iface'} )
    }
    sort {    ##  numerical ip address sort  ##
        int(join '',
            map { sprintf qw| %03d |, $ARG } split qw| . |,
            $ifconfig{$a}{'ip'}
        ) <=> int(
            join '',
            map { sprintf qw| %03d |, $ARG } split qw| . |,
            $ifconfig{$b}{'ip'}
        )
    } <[base.sort]>->( \%ifconfig )    ## pre-sort by interface ##
) {
    $payload_str .= sprintf
        "%*s  %-17s  <%s>\n",
        $x_pos,    ##  data block indented after ip addresses  ##
        $ifconfig{$id}{'ip'}, $ifconfig{$id}{'mac'}, $ifconfig{$id}{'iface'};
}

my $c_pos = $start_len - 1;

$payload_str .= sprintf "%*s\n", $c_pos, qw| } |;

my $payload_len = length $payload_str;
<[base.logs]>->(
    2, ".. sending 'announce host' packet ., [%u payload bytes]", $payload_len
);

<[discover.send_packet]>->( qw| announce |, $payload_str );

<discover.timer.announce_host>->cancel    ## increasing send interval ##
    if <discover.timer.announce_host>->is_active;
<discover.timer.announce_host> = <[event.add_timer]>->(
    {   'after'   => <discover.announce_interval.current>,
        'handler' => qw| discover.handler.anounce_host_addr |
    }
);

##  calculating next send interval [within configured range]  ##
<discover.announce_interval.current> = sprintf( qw| %.2f |,
    <discover.announce_interval.current> *
        <discover.announce_interval.ifactor> );
<discover.announce_interval.current> = <discover.announce_interval.maximum>
    if <discover.announce_interval.current>
    > <discover.announce_interval.maximum>;

#,,.,,...,,..,...,,,,,,..,,.,,,,,,,,,,..,,.,.,..,,...,...,.,,,,.,,,,,,,.,,..,,
#3RICJW7MKC2LSNT2XFNCFIC5OX2CGINWK7ASHEB7TNBWYLR7F6GN7HRGTVW6YPLA4QDD4YEDUULFS
#\\\|NVMNEJAGHFPBTTM5QEYW3ASENEHXH3F447OAMO7LZTNOQ2XDX6H \ / AMOS7 \ YOURUM ::
#\[7]EUFEJOLYYE2D4CDVUVI2QGOOIR3KJMKIA7WALU3H6R7FVUMXCSCY 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
