## >:] ##

# name  = mod-test.perlmod.run_reload_test

my $mod = <base.modules.refresh>;

my %refresh;

##  initializing with already blacklisted ones  ##

my %module_blacklisted = <[mod-test.update_blacklist_aref]>;

my @collected;

my $started_dir   = <mod-test.path>->{'started'};
my $completed_dir = <mod-test.path>->{'complete'};
my $blacklist_dir = <mod-test.path>->{'blacklisted'};

my $file_template_blacklisted = sprintf qw| %s/%%s |, $blacklist_dir;
my $file_template_completed   = sprintf qw| %s/%%s |, $completed_dir;

## return 'continue ..,';

my $test_count = 28;

my $subs = {

    qw| update_start | => sub {
        my $filename = shift;
        <[file.write_timestamp]>->(
            sprintf $file_template_blacklisted, $filename
        );
    },
    qw| update_end | => sub {
        my $filename = shift;
        <[file.write_timestamp]>->(
            sprintf $file_template_completed, $filename
        );
        unlink( sprintf $file_template_blacklisted, $filename )
            or warn <[base.str.os_err]>;
    },
    qw| is_completed | => sub {
        my $filename = shift;
        return 5 if -e sprintf $file_template_completed, $filename;
        return 0;
    },
    qw| is_blacklisted | => sub {
        my $filename = shift;
        return 5 if -e sprintf $file_template_blacklisted, $filename;
        return 0;
    }

};

my $collect_coderef = sub {
    push @collected, scalar <[base.format_error]>->( $ARG[0] )
        if defined $ARG[0]
        and $ARG[0] !~ m,(^| )subroutine \S+ redefined ,i;
};

my @all_files = <[base.sort]>->( \%INC );

local $SIG{__WARN__} = $collect_coderef;

my @reload_blacklist = qw[

    Event.pm

];

my %skip = map { $ARG => 5 } @reload_blacklist;

foreach my $module_file (@all_files) {
    ( my $mod_short = $module_file ) =~ s|^.+/||;
    next
        if $subs->{'is_completed'}->($mod_short)
        or $subs->{'is_blacklisted'}->($mod_short);

    say '< starting test of mod > ', $mod_short;

    $subs->{'update_start'}->($mod_short);

    say sprintf ':   < starting > testing perl module %s ..,', $mod_short;

    foreach my $iteration ( 1 .. $test_count ) {
        say sprintf ':. iteration .: %03d', $test_count - $iteration;
        for ( 1 .. 7 ) {
            <[base.sleep]>->(0.1);
            <[event.once]>;    ## waiting ##
        }

        $mod->unload_module($module_file);
        $refresh{$module_file} = $mod->refresh_module($module_file);

        <[event.once]>;
    }

    say sprintf '< completed > removing %s from blacklist ..,', $mod_short;
    next if $subs->{'update_end'}->($mod_short);
}

<[base.log]>->( 0, ': done.' );

return \@collected;

#,,.,,,,.,,,.,,..,.,,,.,,,..,,,,.,...,,,,,..,,..,,...,...,.,.,,..,...,,,.,..,,
#C6CPOBV27VUCRTLJGZRZZYTK55A6W3BKRCCNTZ7Y7S57XUTTEZPXT5SUL46R3IVU3MDORUJZGGXDI
#\\\|PJPZEMVBLXUWBNJ7GFW2FNJ7JGWZSVQBJGVHO4FQPL7PHKKZQRP \ / AMOS7 \ YOURUM ::
#\[7]KMGOWLIMF22YDPB7TNOKQ4EUMN437YAJKYKQ4CFNDNB5DURAJECY 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
