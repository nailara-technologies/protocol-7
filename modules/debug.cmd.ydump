## >:] ##

# name  = debug.cmd.ydump
# param = [key_pattern]
# descr = extracts of internal program state to yaml

my $y_d_ref;
my $keyword_string = $call->{'args'} // '';

my $keymap      = {};
my $result_aref = [];

if ( not length $keyword_string ) { ##  no keyword suppled  [ dump %data ]  ##
    $reply->{'mode'} = qw| size |;
    $reply->{'data'} = "\n#:Y::[''].\n\n";
    $reply->{'data'} .= YAML::XS::Dump( \%data );
    $reply->{'data'} .= "\n#:Y::.\n";
    return $reply;
}

if ( $keyword_string =~ m|^regex(\-quoted)?:| ) {

    my $stripped_key_regex_match = 5;    ## true ##
    $stripped_key_regex_match = 0
        if index( $keyword_string, qw| regex-quoted: |, 0 ) == 0;

    ##  acquiring extracted and [re]combined result reference  ##
    ##
    my $results_hash_ref
        = { 'r-data' => <[base.resolve_data_key.regex]>->($keyword_string) };

    if ( not keys $results_hash_ref->%* ) {    ## no matches ##
        return {
            'mode' => qw| false |,
            'data' => sprintf( "no match for regular expression '%s'",
                $keyword_string )
        };
    }

    ##  registering search term to result ref  ##
    ##
    $keymap->{$results_hash_ref} = sprintf "REX%s:'%s'",
        $stripped_key_regex_match ? '' : qw| Q |, $keyword_string;
    push( $result_aref->@*, $results_hash_ref );

} else {

    ## validating hash key syntax ##
    ##
    my @key_res = <[base.validate.data_key_syntax]>->($keyword_string);
    return {
        'mode' => qw| false |,
        'data' => sprintf( '.: key syntax :. %s .:', $key_res[1] )
        }
        if not $key_res[0];

    ##  acquiring resolved result reference  ##
    ##
    my $resolve_res = <[base.resolve_key]>->($keyword_string);   ## hashref ##

    return {
        'mode' => qw| false |,    ## no matches ##
        'data' => sprintf( "failed to resolve key '%s'", $keyword_string )
        }
        if not defined $resolve_res;

    $result_aref = [$resolve_res];    ## store result ##

    ##  registering search term to result ref  ##
    ##
    $keymap->{$resolve_res} = sprintf "'%s'", $keyword_string;

}

## reparing reply message ##
$reply->{'mode'} = qw| size |;
$reply->{'data'} = '';

foreach my $href ( $result_aref->@* ) {
    next if not defined $keymap->{$href};    ##  uniqueness filter  ##

    $reply->{'data'} .= "\n" if length $reply->{'data'};
    $reply->{'data'} .= sprintf "\n#:Y::[%s].\n\n%s\n#:Y::.\n\n",
        delete $keymap->{$href},
        YAML::XS::Dump( $href->{'r-data'} );

}

#,,,.,..,,...,.,.,,..,,,,,.,,,,,.,,.,,.,,,,,,,..,,...,...,.,.,..,,..,,,,,,.,.,
#TV3YYDQXBJF2QHEJAHWG7PPJPU5YF7BTUD7GX6PZDDOD6JLEFPA5PF3OMAALBMWL53CPLRSCHHDLK
#\\\|2LZTNKEACWHYYPEADSAHAVKLVHWIKDDIYZG3UQE7YQA6RAYTGR3 \ / AMOS7 \ YOURUM ::
#\[7]3NHE7WZBQU55V3FVHBVUGXIHAMFDOGB2RG5I32JNS7ORGGDZQKCA 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
