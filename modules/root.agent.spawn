# >:]

# name = root.agent.spawn
# descr = spawn nailara agent and add it to process maintenance table

my $job_id     = $_[0]->{'job_id'};
my $agent_name = $_[0]->{'params'};
my $sic_mode   = 0;
my @exec_args  = ();
my ( $pid, $r_fh, $w_fh, $e_fh );
my $nailara_bin = <system.start.exec_name>;    # use current interpreter path
die "no agent name supplied" if not defined $agent_name;
my $init_code = <root.spawn_config.agents.startup.init_code>->{$agent_name};
my $agent_id  = <[agent.get_id]>->($agent_name);

# reuse instance id or create new one if none exists
my $instance_id = <jobqueue.joblist.by_id>->{$job_id}->{'instance_id'};
$instance_id //= <[agent.instance.add]>->($agent_id);
<jobqueue.joblist.by_id>->{$job_id}->{'instance_id'} //= $instance_id;
<root.agent.instance>->{$instance_id}->{'job_id'} = $job_id;

<[agent.change_status]>->( $instance_id, 'starting' );

# execute root-init code
my $init_result_data = {};
my $namespace_str
    = "\$data{'root'}{'agent'}{'instance'}{$instance_id}{'init_data'}";
if ( exists $init_code->{'root-init'} ) {
    <[base.log]>->( 2, "executing '$agent_name'-agent spawn init-code.." );
    my $success = <[base.execute_agent_code]>->(
        <[base.parser.config]>->( $init_code->{'root-init'}, $namespace_str ) );
    $init_result_data = <root.agent.instance>->{$instance_id}->{'init_data'};
    if ( !$success ) {
        <[base.log]>->(
            0, "errors in agent '$agent_name' init-code, aborting start-up!"
        );
        <[agent.change_status]>->( $instance_id, 'failed' );
        return undef;
    }
}

$sic_mode = 1 && push( @exec_args, '-sic' )
    if exists $init_result_data->{'start_mode'}
    and $init_result_data->{'start_mode'} eq 'exec-sic'
    and exists $init_code->{'agent-init'};

my $agent_verbosity = <system.verbosity> || 1; # -v is minimum (agent patterns!)
push( @exec_args, '-' . 'v' x $agent_verbosity );

<[base.log]>->( 1, "spawning '$agent_name'-agent initiated ..." );

eval {
    $pid = open3( $r_fh, $w_fh, $e_fh, $nailara_bin, $agent_name, @exec_args );
};

if ( not defined $pid ) {
    my $err_msg = $@ || <$e_fh>;
    <[base.log]>->( 0, " failed to spawn agent '$agent_name' [$err_msg] " );
    return undef;
}

<[event.add_io]>->(
    {   'fd'      => $w_fh,
        'handler' => 'root.handler.agent_output',
        'data'    => $instance_id
    }
);
<[event.add_io]>->(
    {   'fd'      => $e_fh,
        'handler' => 'root.handler.agent_output',
        'data'    => $instance_id
    }
) if defined $e_fh;

<root.agent.instance>->{$instance_id}->{'process'} = { 'id' => $pid, };    # ...

# push init code to agent (stdin) if in 'sic' mode..
if ($sic_mode) {
    <[base.log]>->( 1, "pushing startup init code to '$agent_name'-agent..." );
    foreach my $code_line ( @{ $init_code->{'agent-init'} } ) {

        # <{foo.bar}> (agent instance namespace) variable fetching syntax
        while ( $code_line =~ /<{([^\}]+)}>/ ) {
            ( my $var_str = "{'$1'}" ) =~ s|\.|'}{'|g;
            my $var_value;
            eval "\$var_value = $namespace_str$var_str";
            if ($@) {
                $@ =~ s|\n| |g;
                <[base.log]>->( 0, "[!] error in agent init-code: $@" );
                last;
            } else {
                $code_line =~ s|<{([^\}]+)}>|$var_value|;
            }
        }
        print {$r_fh} "$code_line\n";
    }
}
close($r_fh);    # no more use for agent stdin handle (for now)

<[base.log]>->( 1, "agent '$agent_name' spawned ! [ pid : $pid ] " );
