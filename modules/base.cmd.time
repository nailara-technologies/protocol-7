# >:]

# name  = base.cmd.time
# param = [clock|date|%d]
# descr = returns time, date or unix time (%d = float precision)
# todo  = return warning when $float specified but Time::HiRes not present(?)

my $param = $$call{'args'};
if ( defined $param and $param eq 'clock' ) {
    my ( $sec, $min, $hour ) = localtime();
    return {
        'mode' => 'ack',
        'data' => sprintf( "%02d", $hour ) . ':'
            . sprintf( "%02d", $min ) . ':'
            . sprintf( "%02d", $sec )
    };
} elsif ( defined $param and $param eq 'date' ) {
    my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday )
        = localtime(time);

    $year = sprintf( "%02d", $year + 1900 );
    $mon  = sprintf( "%02d", $mon + 1 );
    $mday = sprintf( "%02d", $mday );

    return {
        'mode' => 'ack',
        'data' => "$year-$mon-$mday"
    };
} elsif ( defined $param and $param =~ /^\d+$|^$/ ) {
    my $float = 0;
    my $limit = 22;

    # XXX: consider additional access control to floating seconds?
    $float = $param if defined $param and $param =~ /^\d+$/;
    return {
        'mode' => 'nack',
        'data' => "current float precision limit is $limit"
        }
        if $float > $limit;
    return {
        'mode' => 'ack',
        'data' => $code{'base.time'}->($float)
    };
} elsif ( defined $param and $param eq '%d' ) {
    return {
        'mode' => 'nack',
        'data' => "'%d' is expected to be a decimal value"
            . " describing floating point precision!"
    };
} else {
    return {
        'mode' => 'nack',
        'data' => "invalid parameter '$param'.. [clock|date|%d]"
    };
}
