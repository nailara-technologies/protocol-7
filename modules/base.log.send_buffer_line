## [:< ##

# name  = base.log.send_buffer_line
# descr = send log buffer content to configured log zenka [ p7-log ]

my $name         = shift;    ## buffer name ##
my $buffer_index = shift;    ##  buffer line num  ##

##  connected to cube ?  ##      ##  use notify-online  ##  [LLL]
return if not <[base.cfg_bool]>->(<base.log.allow_buffer_send>);
return warn 'expected log buffer name parameter <{C1}>' if not defined $name;

<log.file>->{$name} //= {
    qw| complete        | => TRUE,
    qw| next_index      | => 0,
    qw| start_index     | => $buffer_index,    ##  <-- can be undef  ##
    qw| resend_delay    | => 0.1,
    qw| resend_slowdown | => 1.8,
};

my $log_data = <log.file>->{$name};

##  no such buffer  ##
return <[base.s_warn]>->(
    "send_buffer_line : no such buffer ['%s'] <{C1}>", $name
) if not defined $data{'buffer'}->{$name};

my $buffer_data_ref = $data{'buffer'}->{$name}->{'data'};

SEND_NEXT:    ##  going back when skipping log lines  ##

my $next_index = $log_data->{'next_index'};

##  no such buffer content line [ sent ]  ##
return if not defined $buffer_data_ref->[$next_index];

## filter for correct log level when buffer has higher ones ##
##
my $logfile_verbosity = <system.verbosity.zenka_logfile>;
if ( <system.verbosity.zenka_buffer> > $logfile_verbosity ) {
    ##  grab entry verbosity from buffer line  ##
    my $log_entry_verbosity = $LAST_PAREN_MATCH
        if $buffer_data_ref->[$next_index] =~ m|^[A-Z2-7]+ (\d) |;
    ##  when higher than configured , do not send log message  ##
    if ( defined $log_entry_verbosity
        and $log_entry_verbosity > $logfile_verbosity ) {

        $log_data->{'start_index'} = ++$log_data->{'next_index'};

        my $buffer_count = $data{'buffer'}{$name}{'data'}->@*;
        if ( $log_data->{'next_index'} >= $buffer_count ) {

            ## mark as complete \ done ##
            $log_data->{'complete'} = TRUE;
            return;
        } else {
            ## do not send and advance buffer position ##
            goto SEND_NEXT;
        }
    }
}

my @send_line;    ##  protocol line messages  ##

## path to target zenka.., ##
my $route_prefix = qw| cube. |;

##[ cube has sid 0 ]##
if ( <system.zenka.type> eq qw| cube | ) {
    push @send_line, join( '.', <system.node.name>, <system.zenka.name> ), 0;
    $route_prefix = '';
}

##  log buffer name  ##
push @send_line, $name;

##[ t-stmp, lvl, msg ]##
push @send_line, $buffer_data_ref->[$next_index];
$log_data->{'complete'} = FALSE;

<[base.protocol-7.command.send.local]>->(
    {   qw| command | =>
            join( '', $route_prefix, $data{'buffer'}{$name}{'log_cmd'} ),
        qw| call_args | =>
            { qw| args | => join( ' ', map { $ARG // '' } @send_line ) },
        qw| reply | => {
            qw| handler | => qw| base.log.handler.log_reply |,
            qw| params |  => { qw| name | => $name }
        }
    }
    )
    ##  no warnings during 'reload'  ##
    or <base.silence.sprint_t> = TRUE and <[base.log.handler.log_reply]>->(
    {   qw| cmd |       => qw| FALSE |,    ## command does not exist ##
        qw| call_args | => {
            qw| args | => <[base.sprint_t]>->(qw| 4RVWZTY |)
                // 'command does not exist'    ## fallback in 'reload' case ##
        },
        qw| params | => { qw| name | => $name }
    }
    );

#,,.,,,.,,.,,,..,,.,.,,.,,.,.,,.,,.,.,,,.,,..,..,,...,...,...,,..,,,,,,.,,,,.,
#KCKBGRRE3ZGUXIBMWZYKFNOHLWEIYDYPHIAGSNBI2SCPRTT7P2SXVVAEAUBQYUPDMOSOYMKWIFDPK
#\\\|CRX66W2YZ2GAAQ44GMEAJG7E63SRRUA6LMNQHQ6EJECV2TKHYEO \ / AMOS7 \ YOURUM ::
#\[7]PQ3EZ5OURUM4UPY5CXZ4F2HUD7MN5XT3RMXZ3K4EQ4DTSBDBDOCA 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
