## >:] ##

# name  = base.zenki.ondemand.handler.startup_reply
# descr = handles 'v7.notify_online' command replies

my $reply = shift;

my $v_id       = $reply->{'params'}->{'v_id'};
my $zenka_name = <zenki.virtual>->{$v_id}->{'name'};

delete <zenki.virtual>->{$v_id}->{'starting'};

if ( $reply->{'cmd'} eq qw| FALSE | ) {
    my $reason = $reply->{'call_args'}->{'args'};
    <[base.logs]>->(
        0,           'ondemand start-up of %s zenka not successful [ %s ]',
        $zenka_name, $reason
    );
    while ( my $element = shift <zenki.virtual>->{$v_id}->{'queue'}->@* ) {
        my $cmd_id = $element->{'cmd_id'};
        my $src_id = $element->{'source_id'};
        next if not exists $data{'session'}{$src_id};    ##   <--  gone.   ###

        $data{'session'}{$src_id}{'buffer'}{'output'}
            .= <[base.sprint_t]>->( qw| GLPLXJQ |, $cmd_id );
    }
} else {
    <[base.logs]>->( 'ondemand %s zenka has come online..,', $zenka_name );

    while ( my $element = shift <zenki.virtual>->{$v_id}->{'queue'}->@* ) {
        my $src_id = $element->{'source_id'};
        next if not exists $data{'session'}{$src_id};    ##   <--  gone.   ###

        ##  preparing the stored command for arrived zenka  ##
        my $output_str = sprintf qw| %s%s |, $element->{'cmd_id'},
            $element->{'cmd_str'};

        ## append command arguments ##
        $output_str .= sprintf( ' %s', $element->{'cmd_args'} )
            if defined $element->{'cmd_args'};

        # [LLL] add multiline command parameters ..,
        $data{'session'}{$src_id}{'buffer'}{'input'}
            .= sprintf( "%s\n", $output_str );
    }
}

#,,,,,.,.,...,,,.,,.,,,..,.,.,,.,,,,,,...,,..,..,,...,...,,..,.,,,,..,..,,.,,,
#OVDA6W2DABIRPPV6M4B6KSIHCCCSPNT3BPD77SY4NIUYJWHNJ2ADVCG5ZRNAJE3YLSKHEYQSWLCCQ
#\\\|FDE6LY7DJVE3O5BLIPACNJMRYB7VF4AOBWYDHU3U2JS4OHEGCGN \ / AMOS7 \ YOURUM ::
#\[7]ECSWHU46P7VMNASBVVUDEVUB2RMOBGLIOG5EVFRPL624QOJSIQDI 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
