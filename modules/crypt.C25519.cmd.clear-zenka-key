## >:] ##

# name  = crypt.C25519.cmd.clear-zenka-key
# descr = erase C25519 zenka key from memory [secure]

my $name = <crypt.C25519.key_vars.key_name>;
my $id   = $call->{'session_id'};

return { 'mode' => qw| false |, 'data' => 'C25519 key name is not defined' }
    if not defined $name;
return {
    'mode' => qw| false |,
    'data' => sprintf( "C25519 key '%s' is not loaded", $name )
    }
    if not exists $keys{'C25519'}->{$name};

<[base.logs]>->(
    0,   "[%d] flushing C25519 key '%s'., [ requested ]",
    $id, $name
);

my $success_0 = <[crypt.C25519.del_keys_hash_entry]>->($name);
my $success_S = TRUE;

##  deleting session key if present  ##
##
my $session_keyname = sprintf qw| session:%s |, <system.zenka.name>;
if ( exists $keys{'C25519'}->{$session_keyname} ) {
    <[base.logs]>->(
        "[%d] :, also erasing session key '%s'.., [ from memory ]",
        $id, <system.zenka.name>
    );
    $success_S = <[crypt.C25519.del_keys_hash_entry]>->($session_keyname);
}

if ( $success_0 and $success_S ) {
    return {
        'mode' => qw| true |,
        'data' => sprintf( "deleted '%s' key from memory", $name )
    };
} else {
    return {
        'mode' => qw| false |,
        'data' => 'errors encountered while erasing session key'
    };
}

#,,..,,,,,,.,,,,,,.,,,.,,,,,,,.,,,.,.,..,,..,,..,,...,...,,,.,,,.,...,,,,,,,.,
#ONXJ3TA5DYAANG73WTWZVM57DLV25AD57KGL36I27ZB2NSPRUH3KD4B3TXASG3EU2WEW3CW2AEAP6
#\\\|MONYK5G6CZ7W2O6MQQTMZXNHSZSMWHHKWKD7DO36TAE5N46XMIV \ / AMOS7 \ YOURUM ::
#\[7]FFKS5VMBRTAWVZEJPCFHNRRN4DZ7P32BGY5A2MWLI2BEJ5HYUWAQ 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
