# >:]

# name       = plugin.auth.rsa.load_key

my $key_file = $data{'auth'}{'rsa'}{'key_file'};
my $max_keys = 23542;
my $key_id   = undef;
my $key_path = $data{'system'}{'conf_path'} . '/keys/';

my $key_extensions = { 'private' => 'priv', 'public' => 'pub' };

$code{'base.log'}->( 0, "key directory '$key_path' does not exist!" )
    if !-d $key_path;

# XXX: introduce ~/.nailara/keys/ (l8er)

if ( !-f "$key_path$key_file.$key_extensions->{public}" ) {
    $code{'base.log'}->( 0,
	"RSA key '$key_file.$key_extensions->{public}'"
	." not found, creating new key pair..." );
    $key_id = $code{'crypt.rsa.gen_keys'}->();
} else {
    $key_id = $code{'base.gen_id'}->(
	"data{'crypt'}{'rsa'}{'key'}", $max_keys );
    $code{'base.log'}->( 2,
	": found rsa key '$key_file.pub' [key_id:$key_id]" );
}

if ( exists <auth.rsa.key.current.id> ) {
    # overwrites old key data in memory and deletes it (on reload)
    my $current_id = <auth.rsa.key.current.id>;
    if (exists $data{'crypt'}{'rsa'}{'key'}{$current_id}) {
        my $key_ref = $data{'crypt'}{'rsa'}{'key'}{$current_id};
        foreach my $hash_key (keys(%{$key_ref})){
            my $val_len = length($key_ref->{$hash_key}) || 0;
            $key_ref->{$hash_key} = '-' x int($val_len + rand(222));
        }
        delete $data{'crypt'}{'rsa'}{'key'}{$current_id};
        [base.log:1,": deleted old key (id:$current_id)"];
    }
}

$data{'auth'}{'rsa'}{'key'}{'current'}{'id'} = $key_id;

my $key = $data{'crypt'}{'rsa'}{'key'}{$key_id};
my $rsa = $key->{'obj'};

my $key_loaded = 0;
my $overwrite_key = 0;

foreach my $key_type ( 'private', 'public' ) {

# XXX: fix / cleanup !!!

    next if $key_loaded;

    my $file_extension = $key_extensions->{$key_type};
    $data{'auth'}{'rsa'}{'file'}{$key_type} = "$key_file.$file_extension";
    my $file_name = $key_path . $data{'auth'}{'rsa'}{'file'}{$key_type};

    if ( not -f $file_name or $overwrite_key ) {

	if ( $key_type eq 'private' ) {
	    $data{'crypt'}{'rsa'}{'key'}{$key_id}{$key_type} =
	      $rsa->get_private_key_string();
	} else {
	    $data{'crypt'}{'rsa'}{'key'}{$key_id}{$key_type} =
	      $rsa->get_public_key_string();
	    $overwrite_key = 1;
	}
	# write key file to disk
	$code{'base.put_file'}->( $file_name,
	    \$data{'crypt'}{'rsa'}{'key'}{$key_id}{$key_type} );
    } else {
	$code{'base.log'}->(1, ": loading $key_file $key_type key..");

	$data{'crypt'}{'rsa'}{'key'}{$key_id}{$key_type} =
	  join( '', $code{'base.get_file'}->($file_name) );

	if ($key_type eq 'public') {
	    $rsa = Crypt::OpenSSL::RSA->new_public_key(
		$data{'crypt'}{'rsa'}{'key'}{$key_id}{$key_type}
	    );
	} else {
	    #$rsa->new_private_key(
	    $rsa = Crypt::OpenSSL::RSA->new_private_key(
		$data{'crypt'}{'rsa'}{'key'}{$key_id}{$key_type}
	    );
	}

	$data{'crypt'}{'rsa'}{'key'}{$key_id} = {
	    'private' => $rsa->get_private_key_string(),
	    'public'  => $rsa->get_public_key_x509_string()
	};

	$key = $data{'crypt'}{'rsa'}{'key'}{$key_id};

	# default initialization
	$rsa->use_pkcs1_oaep_padding();
	$rsa->use_sha512_hash();

	$key->{'obj'}        = $rsa;
	$key->{'size'}       = $rsa->size() * 8;
	$key->{'block_size'} = $rsa->size();
	$key->{'type'}       = 'rsa';
	$key->{'encoding'}   = 'X509';
	$key->{'fingerprint'}{'public'} = sha1_hex( $key->{'public'} );
	$code{'base.log'}->( 2, ": : valid : "
            . $key->{'fingerprint'}{'public'} );
	$key_loaded = 1;
    }
}



#    if($key_type eq 'private') {

#	if ( $rsa->check_key() ) {
#	    } else {
#		$code{'base.log'}->( 0, ': error: loaded key is invalid!' );
#	    }
#	}

#    }



#$key->{'obj'} = $rsa;

#$data{'crypt'}{'rsa'}{'key'}{$key_id} = $key;

#use Data::Dumper qw( Dumper );
#die "key : ".Dumper($key);

#die Dumper( $key->{'obj'} );

return $key_id;

