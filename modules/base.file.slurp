## >:] ##

# name  = base.file.slurp
# args  = <filename>[, <target_reference> (SCALAR|ARRAY)][, <encoding>]
# descr = loads a file into memory and returns a reference to it

my $open_file_name = shift // '';
my $target_ref     = shift;           # optional scalar or array reference
my @encoding       = ( shift // '' ); # optional encoding type [ i.e. ':raw' ]

if ( not length $open_file_name ) {
    warn 'expecting file_name parameter <{C1}>';
    return undef;
}
$open_file_name = abs_path($open_file_name) if -e $open_file_name;

if ( defined $target_ref and not length ref $target_ref ) {
    @encoding = ($target_ref);
    undef $target_ref;
}

if ( not defined $target_ref ) {
    my $buffer = '';
    $target_ref = \$buffer;
}
if ( not -f $open_file_name ) {
    <[base.logs]>->( 0, ": file not found : %s", $open_file_name );
    return undef;
}
my $file_fh;
if ( not open( $file_fh, join( ' ', qw| < |, @encoding ), $open_file_name ) )
{
    <[base.logs]>->(
        0,                   "<< %s : reading file : '%s' >>",
        <[base.str.os_err]>, $open_file_name
    );
    return undef;
}
my $ref_type = ref $target_ref;
use warnings qw| FATAL |;
if ( $ref_type eq qw| SCALAR | ) {
    use warnings qw| FATAL |;
    local $INPUT_RECORD_SEPARATOR = undef;
    eval { $target_ref->$* = readline($file_fh) };
    if ( length $EVAL_ERROR ) {
        ## say '  < caller >  ', scalar <[base.caller]>;
        <[base.s_warn]>->(
            ': %s : %s', <[base.str.eval_error]>, $open_file_name
        );
        return undef;
    }
} elsif ( $ref_type eq qw| ARRAY | ) {
    use warnings qw| FATAL |;
    local $INPUT_RECORD_SEPARATOR = undef;
    eval { push $target_ref->@*, readline($file_fh) };
    if ( length $EVAL_ERROR ) {
        ## say '  < caller >  ', scalar <[base.caller]>;
        <[base.s_warn]>->(
            ': %s : %s', <[base.str.eval_error]>, $open_file_name
        );
        return undef;
    }
    chomp $target_ref->@*;

} else {
    <[base.s_warn]>->( "not supported reference type %s <{C1}>", $ref_type );
    return undef;
}

if ( not close($file_fh) ) {    ##[  only warning about it  ]##
    <[base.logs]>->(
        0,                   "<< %s : closing file : %s >>",
        <[base.str.os_err]>, $open_file_name
    );
}

return $target_ref;             ##  scalar or array reference  ##

#,,,,,...,..,,,,.,.,.,,,,,,..,,,,,.,.,,,.,,.,,..,,...,...,.,.,.,,,,..,,,,,...,
#YQJ5PBYCZJ4PMZWRQXRXLNDQHI5ZMYXE7B7ONX6XUZ32YDWS2EXJP6AWLLXWIISDR4PMNQMBB34NM
#\\\|2ZNOKPHRXPS3ICI7F65BPYV5FDOAZYXESBCPFAK4IZ626A56LK7 \ / AMOS7 \ YOURUM ::
#\[7]XNOGQEYF2BZP7NNZ2ZWQNWKLNEF3YD2MI6CP3UKAQMLI4ZOKAUAQ 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
