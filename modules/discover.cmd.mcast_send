## >:] ##

# name  = discover.cmd.mcast_send
# descr = send (signed) message to mcast group

my $ann_msg = shift->{'args'} // '';
return {
    'mode' => qw| false |,
    'data' => 'no announce message string given'
    }
    if not defined !length($ann_msg);

my $key_name = <discover.crypt.key_name>;

if ( not defined <discover.announce_msg_header> ) {

    <discover.announce_msg_header>
        = "[:<|ANNOUNCE|"
        . encode_b32r( $keys{'C25519'}{$key_name}{'public'} ) . "\n";

    map {
        <discover.announce_msg_header>
            .= join( ':', $ARG,
            $keys{'C25519'}{$key_name}{'root'}{$ARG}{'sig'} )
            . "\n"
        }
        keys %{ $keys{'C25519'}{$key_name}{'root'} };
}

$ann_msg =~ s/\n*$/\n/;

( my $t_stmp = <[base.time]>->( length(time) ) ) =~ s|\.||;
my $packet_str = <discover.announce_msg_header> . "\n$ann_msg\n$t_stmp:";

$packet_str .= encode_b32r( <[crypt.C25519.sign_data]>->( \$packet_str ) );

# print "---<sent>---\n$packet_str--</sent---\n";

return { 'mode' => qw| false |, 'data' => "unable to send : \l$OS_ERROR" }
    unless <discover.mcast.obj.sock>->mcast_send( $packet_str . "\n",
    join( ':', <discover.mcast.ip4_addr>, <discover.mcast.ip4_port> ) );

return { 'mode' => qw| true |, 'data' => 'message sent' };

#,,,,,.,,,...,,,.,...,...,.,.,...,,,,,,,.,,,,,..,,...,...,.,.,,..,,,.,,.,,,,,,
#RT6GHMTLEXLHFYJUC4AVOO4YKJTZFPRYPS5H75K35KFLGAVZ7IFVDVPH6O34CJ44AELKIF6M33WNE
#\\\|IAXLROOEBWOHFSES4LC7RVVQQHJPAOC56TMPTRSRR35NACP6RZR \ / AMOS7 \ YOURUM ::
#\[7]HWWQ3DDOBEML3KJDWWO5GOVVOSC3HPSOTXXQTVMGLGASVNTELCDI 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
