# >:]

# name = mpv.handler.get_list_reply
# todo = implement continuous playback in case current file is in playlist!

my $reply = shift;

if ( $reply->{'cmd'} eq 'NACK' ) {
    <[base.log]>->( 0, "failed to fetch playlist!" );
    return;
}

<mpv.file_map.rescaled> = {};

if ( $reply->{'call_args'}->{'args'} == 0 ) {
    <[base.log]>->( 0, "received empty playlist!" );
    <[mpv.send_command]>->('stop');
    return;
}

@{<mpv.playlist.update_files>} = split( "\n", $reply->{'data'} );

if (<mpv.autorescale>) {
    my $window_width  = <x11.coordinates.right> - <x11.coordinates.left>;
    my $window_height = <x11.coordinates.bottom> - <x11.coordinates.top>;
    my $box_size      = join( 'x', $window_width, $window_height );

    foreach my $playlist_path ( @{<mpv.playlist.update_files>} ) {
        my $extension = '';
        ( my $output_path = $playlist_path ) =~ s|/([^/]+)$|/rescaled/$1|;
        $extension = ".$1" if $playlist_path =~ /\.([^\.]+)$/;
        my $rescaled_path = "$output_path/$box_size$extension";
        next if !-f $rescaled_path;
        <mpv.file_map.rescaled>->{$playlist_path} = $rescaled_path;
        <mpv.file_map.rescaled>->{$rescaled_path} = $playlist_path;
        $playlist_path = $rescaled_path;
    }

}

push( @{<mpv.command.reply>}, { 'handler' => 'dev.null' } );
<[mpv.send_command]>->('playlist_clear');

push(
    @{<mpv.command.reply>},
    {   'handler'  => 'mpv.handler.path_reply',
        'callback' => 'mpv.callback.playlist_update'
    }
);

delete <mpv.current.path>;
<[mpv.send_command]>->( 'get_property_string', 'path' );
