## >:] ##

# name  = keys.key.is-encrypted

my $key_name = shift // '';

if ( not length $key_name ) {
    warn 'expecting key_name parameter <{C1}>';
    return undef;
}

my $re_kfiles = <keys.regex.key_files>;

my $private_keyfile;

if ( index( $key_name, qw| / |, 0 ) == 0 and $key_name =~ $re_kfiles ) {
    ## absolute path to keyfile ##
    return -2 if not -f $key_name;    ##  no key file with that name  ##
    return -3 if not -r $key_name;    ##  is not readable  ##
    ( my $filepath_rel = $key_name ) =~ s|^.+/||;
    my $key_re_public = <keys.regex.key_file.public>;

    ##  public key [ never encrypted ]  ##
    return 0 if $filepath_rel =~ $key_re_public;

    $private_keyfile = $key_name;     ##  private key abs file path  ##

} else {

    my $key_filenames
        = <[crypt.C25519.key_vars]>->($key_name)->{'key_filename'};

    $private_keyfile = $key_filenames->{'private'};
    my $public_keyfile = $key_filenames->{'public'};

    if ( defined $private_keyfile and not -f $private_keyfile ) {
        if ( defined $public_keyfile and -f $public_keyfile ) {
            return -1;    ##  only public key present  ##
        } else {
            return -2;    ##  no key with specified name  ##
        }
    } elsif ( not defined $private_keyfile or not defined $public_keyfile ) {
        warn 'key_vars function returned undefined filename <{C1}>';
        return undef;
    }
}

my $key_file_ref = <[file.slurp]>->($private_keyfile);

if (   not defined $key_file_ref
    or ref $key_file_ref ne qw| SCALAR |
    or not defined $key_file_ref->$* ) {
    return -3;    ##  cannot read file  ##
} else {
    chomp( $key_file_ref->$* );    ##  strip linefeed  ##
}

my $key_encrypted = 0;             ##  false  ##

my $encoded_keylen  = length $key_file_ref->$*;
my $decoded_privkey = decode_b32r( $key_file_ref->$* );

## checking for encryption [ '.:' prefix encrypted or 'U:' for plain ] ##
##
if ($encoded_keylen == 106    ##[  has no linefeed  ]##
    and index( $key_file_ref->$*, qw| FY5 |, 0 ) == 0
    and index( $decoded_privkey,  qw| .: |,  0 ) == 0
) {
    $key_encrypted = 5;       ## true ##

} elsif ( $encoded_keylen == 106
    and index( $key_file_ref->$*, qw| KU5 |, 0 ) == 0
    and index( $decoded_privkey,  qw| U: |,  0 ) == 0 ) {

    $key_encrypted = 0;       ## false ##

} elsif ( $encoded_keylen == 103 ) {    ##[  old key format  ]##

    $key_encrypted = 0;                 ## false ##

} else {
    return -4;                          ##[  not a valid key format  ]##
}

return $key_encrypted;                  ##  key encryption status  ##

#,,..,.,.,.,,,..,,.,,,.,,,,,,,.,.,,.,,..,,.,.,..,,...,...,,,.,...,..,,...,.,.,
#WUWCLS5LAWGCLTPAQUMRSE3V5GUEWEUQLIXJFFN674RXUSP46K5M5PYFYMOZVJGOW7BESG5XWJTZ6
#\\\|3EF67YV4WRRDJBUTFZQVCKVZ5UFXTCMMYBAHGR7IOVTRJJOMGTD \ / AMOS7 \ YOURUM ::
#\[7]NJVPBJPTZETF3JKVQHU7KOTXLTURDXVP6FVD2CC25DI3PJGD5QDA 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
