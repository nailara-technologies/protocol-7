## >:] ##

# name  = crypt.C25519.encrypted_key

## todo : use get_type_from_key_str here to remove redundancy ##

my $key_name = shift // '';

if ( not length $key_name ) {
    warn 'expecting key_name parameter <{C1}>';
    return undef;
}

my $keys_re   = <crypt.C25519.regex>;
my $re_kfiles = $keys_re->{'key_files'};

my $private_keyfile;

if ( index( $key_name, qw| / |, 0 ) == 0 and $key_name =~ $re_kfiles ) {
    ## absolute path to keyfile ##
    return -2 if not -f $key_name;    ##  no key file with that name  ##
    return -3 if not -r $key_name;    ##  is not readable  ##
    ( my $filepath_rel = $key_name ) =~ s|^.+/||;
    my $key_re_public = $keys_re->{'key_file'}->{'public'};

    ##  public key [ never encrypted ]  ##
    return FALSE if $filepath_rel =~ $key_re_public;

    $private_keyfile = $key_name;     ##  private key abs file path  ##

} else {

    my $key_filenames
        = <[crypt.C25519.key_vars]>->($key_name)->{'key_filename'};

    $private_keyfile = $key_filenames->{'private'};
    my $public_keyfile = $key_filenames->{'public'};

    if ( defined $private_keyfile and not -f $private_keyfile ) {
        if ( defined $public_keyfile and -f $public_keyfile ) {
            return -1;    ##  only public key present  ##
        } else {
            return -2;    ##  no key with specified name  ##
        }
    } elsif ( not defined $private_keyfile or not defined $public_keyfile ) {
        warn 'key_vars function returned undefined filename <{C1}>';
        return undef;
    }
}

my $key_file_ref = <[file.slurp]>->($private_keyfile);

if (   not defined $key_file_ref
    or ref $key_file_ref ne qw| SCALAR |
    or not defined $key_file_ref->$* ) {
    return -3;    ##  cannot read file  ##
} else {
    chomp( $key_file_ref->$* );    ##  strip linefeed  ##
}

my $key_encrypted = FALSE;         ##  false  ##

my $encoded_keylen  = length $key_file_ref->$*;
my $decoded_privkey = decode_b32r( $key_file_ref->$* );

## checking for encryption [ '.:' prefix encrypted or 'U:' for plain ] ##
##
if ($encoded_keylen == 106    ##[  has no linefeed  ]##
    and index( $key_file_ref->$*, qw| FY5 |, 0 ) == 0
    and index( $decoded_privkey,  qw| .: |,  0 ) == 0
) {
    $key_encrypted = TRUE;    ## true ##

} elsif ( $encoded_keylen == 106
    and index( $key_file_ref->$*, qw| KU5 |, 0 ) == 0
    and index( $decoded_privkey,  qw| U: |,  0 ) == 0 ) {

    $key_encrypted = FALSE;    ## false ##

} elsif ( $encoded_keylen == 103 ) {    ##[  old key format  ]##

    $key_encrypted = FALSE;             ## false ##

} else {
    return -4;                          ##[  not a valid key format  ]##
}

return $key_encrypted;                  ##  key encryption status  ##

#,,,.,.,,,,,.,.,,,...,...,,,.,,.,,..,,,,.,.,.,..,,...,...,,,.,,.,,.,,,.,.,...,
#5BL5HPY6ULB3NN66WCQUFWMYNRSYQ7UVB5YGTX27B2EO5MU5437OWNDMEJUKWJODHBBYI34RSA5FM
#\\\|YRSZPACUB6OBXSVL234LZFJEPVY35LXSMWJIFOUXR6XJKFBQNC7 \ / AMOS7 \ YOURUM ::
#\[7]7CTBKKPHC6OWVCPT7KBU4ORFUENK7S73LFGRBKRYKDHQ373K3EDA 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
