## >:] ##

# name = crypt.C25519.gen_keys

my $key_name_param = shift;    ##  optional  ##

my $key_vars_ref = <[crypt.C25519.key_vars]>->($key_name_param);

my $key_name = $key_vars_ref->{'key_name'};

<[base.logs]>->( 2, "generating '%s' C25519 key pair ..,", $key_name );

$keys{'C25519'} //= {};

if ( exists $keys{'C25519'}{$key_name} ) {
    <[base.s_warn]>->(
        "a C25519 key with name '%s' is already loaded [ skipped ]", $key_name
    );
    return 0;
}

my $TRUE = 0;    ##  false  ##
my ( $public_key, $private_key );

my $secret_key;

##  create from random input [ Crypt::PRNG::Fortuna ]  ##
##
while ( not $TRUE ) {
    <[event.once]>->(0.007);
    $secret_key = <[base.prng.bytes]>->(32);
    $public_key = Crypt::Ed25519::eddsa_public_key($secret_key);

    $TRUE = 5    ## true ##
        if AMOS7::Assert::Truth::is_true( \$public_key, 0, 1 )
        and AMOS7::Assert::Truth::is_true( \encode_b32r($public_key), 0, 1 );
}

( $public_key, $private_key ) = Crypt::Ed25519::generate_keypair($secret_key);

$keys{'C25519'}{$key_name} = {
    'name'       => $key_name,
    'public'     => $public_key,
    'private'    => $private_key,    ##[  C25519 private key  ]##
    'secret_key' => $secret_key      ##  source entropy  ##
};

return ( $keys{'C25519'}{$key_name}, $key_name );    ##[ success ]##

#,,..,.,.,...,.,,,...,,,.,.,,,.,,,,..,..,,,,.,..,,...,..,,...,,,.,.,,,,,.,..,,
#AV7QONAMYQKBK5RAJ6DFS4D6K3RYHAXO2YMEYTO7WB37GSVIPU2ARMPRMNVWMBNC6KFF6G7ETHU76
#\\\|KO6E5NSZ6DKYLAOINC4COLH2OV6MVNZST55EBQD3XX6LTQBSSLE \ / AMOS7 \ YOURUM ::
#\[7]WBZOIMNYNJMJVODDSDEWKM54F6NZBHFANPBGTE5A6AEQEZN3MOBY 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
