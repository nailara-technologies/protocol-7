# >:]

# name = playlist.load_file

my $file_path    = shift;
my $check_logged = 0;
my $check_types  = <playlist.http.check_content_types>;

die "expected playlist file path"
    if not defined $file_path or !length($file_path);
( my $file_name = $file_path ) =~ s|^.*\/||;

if ( !-f $file_path ) {
    <[base.log]>->( 0, "playlist file '$file_path' not found!" );
    return -1;
}

<[base.log]>->( 1, "loading playlist file '$file_name'" );

my @lines;
my @file_names;
<[file.slurp]>->( $file_path, \@lines );

map {
    $_ =~ s/^\s+|\s+$//g;
    $_ =~ s|^ *#[^\n]*$||mg;
    $_ =~ s| +#[^\n]*$||mg;
    $_ =~ s|\n\n|\n|sg;
    $_ =~ s/^\n|\n$//mg;
    push( @file_names, $_ ) if length($_);
} @lines;

<playlist.file_list>  = \@file_names;
<playlist.file_types> = {};

if ( !@file_names ) {
    <[base.log]>->( 0, "no files in playlist!" );
    return 0;
}

foreach my $file (@file_names) {
    my $agent_subname;
    $agent_subname = $1 if $file =~ s|^([^\:]): +||;
    <playlist.agent_subnames>->{$file} = $agent_subname
        if defined $agent_subname;
    my $type = 'unknown';
    if ( -f $file ) {
        $type = mimetype($file);
    } elsif ( $file =~ m|^https?://| ) {
        if ($check_types) {
            if ( !$check_logged ) {
                <[base.log]>->( 1, ': checking http content types ...' );
                $check_logged = 1;
            }
            $type = <[playlist.http.get_mime_type]>->($file);

            # todo: retry on failures (no network)
        } else {
            $type = 'html';
        }
    } else {
        <[base.log]>->( 0, "local content file '$file' not found!" );
    }

    $type =~ s|^video/.*$|video|;
    $type =~ s|^audio/.*$|audio|;
    $type =~ s|^image/.*$|image|;
    $type =~ s|^.*application.*/||;
    $type =~ s|^text/||;
    $type =~ s|;.*$||g;
    $type =~ s| +|_|g;

    <playlist.file_types>->{$file} = $type;

}

return scalar @file_names;
