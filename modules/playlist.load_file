# >:]

# name = playlist.load_file

my $file_path = shift;
die "expected playlist file path"
    if not defined $file_path or !length($file_path);
( my $file_name = $file_path ) =~ s|^.*\/||;

if ( !-f $file_path ) {
    <[base.log]>->( 0, "playlist file '$file_path' not found!" );
    return -1;
}

<[base.log]>->( 1, "loading playlist file '$file_name'" );

my @lines;
my @file_names;
<[file.slurp]>->( $file_path, \@lines );

map {
    $_ =~ s/^\s+|\s+$//g;
    $_ =~ s|^ *#[^\n]*$||mg;
    $_ =~ s| +#[^\n]*$||mg;
    $_ =~ s|\n\n|\n|sg;
    $_ =~ s/^\n|\n$//mg;
    push( @file_names, $_ ) if length($_);
} @lines;

<playlist.file_list>  = \@file_names;
<playlist.file_types> = {};

if ( !@file_names ) {
    <[base.log]>->( 0, "no files in playlist!" );
    return 0;
}

foreach my $file (@file_names) {
    my $agent_subname;
    $agent_subname = $1 if $file =~ s|^([^\:]): +||;
    <playlist.agent_subnames>->{$file} = $agent_subname
        if defined $agent_subname;
    <playlist.file_types>->{$file} = 'unknown';
    if ( -f $file ) {
        my $type = mimetype($file);
        $type =~ s|^video/.*$|video|;
        $type =~ s|^audio/.*$|audio|;
        $type =~ s|^.*application.*/||;
        <playlist.file_types>->{$file} = $type;
    } elsif ( $file =~ m|^https?://| ) {

        # XXX: check XML [rss] vs. HTML
        <playlist.file_types>->{$file} = 'html';
    }
}

return scalar @file_names;
