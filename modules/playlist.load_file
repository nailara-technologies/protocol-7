# >:]

# name = playlist.load_file

my $file_path    = shift;
my $check_logged = 0;
my $check_types  = <playlist.http.check_content_types>;

die "expected playlist file path"
    if not defined $file_path or !length($file_path);
( my $file_name = $file_path ) =~ s|^.*\/||;

if ( !-f $file_path ) {
    <[base.log]>->( 0, "playlist file '$file_path' not found!" );
    return -1;
}

<[base.log]>->( 1, "loading playlist file '$file_name'" );

my @lines;
my @file_names;
<[file.slurp]>->( $file_path, \@lines );

map {
    $_ =~ s/^\s+|\s+$//g;
    $_ =~ s|^ *#[^\n]*$||mg;
    $_ =~ s| +#[^\n]*$||mg;
    $_ =~ s|\n\n|\n|sg;
    $_ =~ s/^\n|\n$//mg;
    push( @file_names, $_ ) if length($_);
} @lines;

<playlist.file_list>    = \@file_names;
<playlist.file_types>   = {};
<playlist.items_queued> = 0;

if ( !@file_names ) {
    <[base.log]>->( 0, "no files in playlist!" );
    return 0;
}

foreach my $file (@file_names) {
    my $agent_subname;
    $agent_subname = $1 if $file =~ s|^([^\:]+): +||;
    <playlist.agent_subnames>->{$file} = $agent_subname
        if defined $agent_subname;
    my $type = 'unknown';

    ### XXX: weather agent test hack ###
    if ( $file =~ /^\[weather:(.+)\]$/ ) {

        if ( not exists <playlist.agent_online> or !<playlist.agent_online> ) {
            <playlist.items_queued>++;
            $type = ':queued:';
        } else {
            my $city_str = $1;
            <[base.proto.nailara.command.send.local]>->(
                {   'command'   => "core.weather.get_urls",
                    'call_args' => { 'args' => $city_str },
                    'reply'     => {
                        'handler' => 'playlist.handler.weather_urls_reply',
                        'params'  => {
                            'city'    => $city_str,
                            'subname' => $agent_subname
                        }
                    }
                }
            );
            $type = ':waiting:';
        }
    }

    ####################################

    if ( $type eq 'unknown' and -f $file ) {
        $type = mimetype($file);
    } elsif ( $type eq 'unknown' and $file =~ m|^https?://| ) {
        if ($check_types) {
            if ( !$check_logged ) {
                <[base.log]>->( 1, ': checking http content types ...' );
                $check_logged = 1;
            }
            $type = <[playlist.http.get_mime_type]>->($file);

            # todo: retry on failures (no network)
        } else {
            $type = 'html';
        }
    } elsif ( $file =~ m|^udp://| ) { # XXX: temporary hack for mcast live video
        $type = 'video';
    } elsif ( $type eq 'unknown' ) {
        <[base.log]>->( 0, "local content file '$file' not found!" );
    }

    $type =~ s|^video/.*$|video|;
    $type =~ s|^audio/.*$|audio|;
    $type =~ s|^image/.*$|image|;
    $type =~ s|^.*application.*/||;
    $type =~ s|^text/||;
    $type =~ s|;.*$||g;
    $type =~ s| +|_|g;

    <playlist.file_types>->{$file} = $type;

}

return scalar @file_names;
