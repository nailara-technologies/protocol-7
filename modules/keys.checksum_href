## >:] ##

# name  = keys.checksum_href

my $key_name_param = shift;

my $key_vars = <[crypt.C25519.key_vars]>;
my $key_dir  = $key_vars->{'key_dir'};

my $key_re_secret = <keys.regex.key_file.secret>;
my $key_re_public = <keys.regex.key_file.public>;

my $re_kfiles = <keys.regex.key_files>;

my @k_files = grep {m{$re_kfiles}} <[file.all_files]>->($key_dir)->@*;

@k_files = grep {m{/$key_name_param\.$re_kfiles}} @k_files
    if defined $key_name_param;

my %key_chksums;
my %single_chksums;

return \%key_chksums if @k_files == 0;    ##  no [matching] keys  ##

my @chksumkeys;
my $last_kname = '';
foreach my $file (@k_files) {
    ( my $filepath_rel = $file )         =~ s|^.+/||;
    ( my $key_name     = $filepath_rel ) =~ s|\.$re_kfiles||;
    @chksumkeys = () if $key_name ne $last_kname;    ##  resetting  ##

    my $key_encryption_status = <[keys.key.is-encrypted]>->($file);

    if ( $key_encryption_status == -3 ) {
        $key_chksums{$key_name} = qw| no-r.perms |;
    } elsif ( $key_encryption_status == 5 ) {
        $key_chksums{$key_name} = qw| <::encrypted::> |;
    } else {
        my $keystr_encoded = <[file.slurp]>->($file);
        if ( ref $keystr_encoded ne qw| SCALAR |
            or not length $keystr_encoded->$* ) {
            $key_chksums{$key_name} = qw| r.err |;
        } else {
            chomp( $keystr_encoded = $keystr_encoded->$* );
            my $key_len = length $keystr_encoded;
            if ( $key_len > 52 ) {    ##  is priv. key  ##
                my $key_bin = decode_b32r($keystr_encoded);
                if ( not defined $key_bin ) {
                    $key_chksums{$key_name} = qw| dec.err |;
                } else {
                    substr( $key_bin, 0, 2, '' ) if $key_len == 106;
                    push @chksumkeys, $key_bin;
                    $single_chksums{$key_name}
                        = <[crypt.C25519.key_checksums]>->(@chksumkeys);
                }
            } else {                  ##  is a public key  ##
                my $key_bin = decode_b32r($keystr_encoded);
                if ( not defined $key_bin ) {
                    $key_chksums{$key_name} = qw| dec.err |;
                } else {
                    push @chksumkeys, $key_bin;
                    $single_chksums{$key_name} = $key_chksums{$key_name}
                        //= <[crypt.C25519.key_checksums]>->(@chksumkeys);
                }
            }
        }
        $last_kname = $key_name;
    }
}

foreach my $key_name ( <[base.sort]>->( \%key_chksums ) ) {
    $key_chksums{$key_name} //= $single_chksums{$key_name};
}

return \%key_chksums;

#,,,.,.,,,..,,..,,.,,,,.,,.,,,..,,.,.,.,.,,.,,..,,...,...,,.,,...,,..,...,..,,
#DBMEIAWQL3EFPYTYXORGAQHD25MATLPHNYAEFVOWWMV2ZB72KCQHUAQ6RQCI3Y54VGXAGI35PA5IW
#\\\|JHUG2ARBC55LSDYWLOK6WFHJ4AKMW2DPFUXSWADY3D62ZJ3CZRX \ / AMOS7 \ YOURUM ::
#\[7]K5ZDVMB2V3DET2E6BLNTZMJZJ2OCEUBITOUFWIF6IUJFRB5VAOBI 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
