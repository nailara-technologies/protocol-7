## >:] ##

# name  = keys.checksum_href

my $key_name_param = shift;

my $key_vars_ref = <[crypt.C25519.key_vars]>;
my $key_dir      = $key_vars_ref->{'key_dir'};

my $keys_re = <keys.regex>;

my $re_kfiles      = $keys_re->{'key_files'};
my $key_re_public  = $keys_re->{'key_file'}->{'public'};
my $key_re_private = $keys_re->{'key_file'}->{'private'};

my @k_files = grep {m{$re_kfiles}} <[file.all_files]>->($key_dir)->@*;

@k_files = grep {m{/$key_name_param\.$re_kfiles}} @k_files
    if defined $key_name_param;

my %key_chksums;
my %single_chksums;

return \%key_chksums if @k_files == 0;    ##  no [matching] keys  ##

my @chksumkeys;
my $last_kname = '';
foreach my $file (@k_files) {
    ( my $filepath_rel = $file )         =~ s|^.+/||;
    ( my $key_name     = $filepath_rel ) =~ s|\.$re_kfiles||;
    @chksumkeys = () if $key_name ne $last_kname;    ##  resetting  ##

    my $key_encryption_status = <[crypt.C25519.encrypted_key]>->($file);

    if ( $key_encryption_status == -3 ) {
        $key_chksums{$key_name} = qw| no-r.perms |;
    } elsif ( $key_encryption_status == 5 ) {
        $key_chksums{$key_name} = qw| <::encrypted::> |;
    } else {
        my $keystr_encoded = <[file.slurp]>->($file);
        if ( ref $keystr_encoded ne qw| SCALAR |
            or not length $keystr_encoded->$* ) {
            $key_chksums{$key_name} = qw| r.err |;
        } else {
            chomp( $keystr_encoded = $keystr_encoded->$* );
            my $key_len = length $keystr_encoded;

            if ( $key_len != 52 and $key_len != 103 and $key_len != 106 ) {
                <[base.logs]>->(
                    0, "length of key '%s' not valid [ %04d BYTES ]",
                    $filepath_rel, $key_len
                );
                $single_chksums{$key_name}
                    = $key_chksums{$key_name} = qw| size.error |;
            } elsif ( $key_len > 52 ) {    ##  is priv. key  ##
                my $key_bin = decode_b32r($keystr_encoded);
                if ( not defined $key_bin ) {
                    $key_chksums{$key_name} = qw| dec.err |;
                } else {
                    substr( $key_bin, 0, 2, '' ) if $key_len == 106;
                    push @chksumkeys, $key_bin;
                    $single_chksums{$key_name}
                        = <[crypt.C25519.key_checksums]>->(@chksumkeys);
                }
            } else {                       ##  is a public key  ##
                my $key_bin = decode_b32r($keystr_encoded);
                if ( not defined $key_bin ) {
                    $key_chksums{$key_name} = qw| dec.err |;
                } else {
                    push @chksumkeys, $key_bin;
                    $single_chksums{$key_name} = $key_chksums{$key_name}
                        //= <[crypt.C25519.key_checksums]>->(@chksumkeys);
                }
            }
        }
        $last_kname = $key_name;
    }
}

foreach my $key_name ( <[base.sort]>->( \%key_chksums ) ) {
    $key_chksums{$key_name} //= $single_chksums{$key_name};
}

return \%key_chksums;

#,,.,,,,.,,.,,,..,.,.,,.,,...,...,,..,.,,,..,,..,,...,...,.,,,...,..,,,..,,.,,
#GZGPZV2DF3XF32R7NONM3AP353NLJA3UNLPWGTP6RFUMKNDHEPSXIGVHFJQ3DIDZXOKEXUSY4LLLI
#\\\|I4MRYK267QG5KSTP36OQP4FQXGXQX4W7UGXUOC7Z44A4DEEHQJA \ / AMOS7 \ YOURUM ::
#\[7]U4THGKZJ4U7TYVIV7NKDRVEMT4BXJDMIVXYZFH355NQAXJ4N4SCA 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
