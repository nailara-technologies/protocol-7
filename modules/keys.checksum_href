## [:< ##

# name  = keys.checksum_href

my $name_param = shift;

my $key_vars_ref = <[crypt.C25519.key_vars]>;
my $key_dir      = $key_vars_ref->{'key_dir'};

my $keys_re = <keys.regex>;

my $re_kfiles      = $keys_re->{'key_files'};
my $key_re_public  = $keys_re->{'key_file'}->{'public'};
my $key_re_private = $keys_re->{'key_file'}->{'private'};

my @k_files = grep {m{$re_kfiles}} <[file.all_files]>->($key_dir)->@*;

@k_files = grep {m{/$name_param$re_kfiles}} @k_files
    if defined $name_param;

my %key_chksums;
my %single_chksums;

return \%key_chksums if @k_files == 0;    ##  no [matching] keys  ##

my @chksumkeys;
my $last_kname = '';
my %key_L13chksums;
foreach my $file (@k_files) {
    ( my $filepath_rel = $file )         =~ s|^.+/||;
    ( my $name         = $filepath_rel ) =~ s|$re_kfiles||;
    @chksumkeys = () if $name ne $last_kname;    ##  resetting  ##

    my $key_encryption_status = <[crypt.C25519.encrypted_key]>->($file);

    if ( $key_encryption_status == -3 ) {
        $key_chksums{$name} = qw| no-r.perms |;
    } else {
        my $keystr_encoded = <[file.slurp]>->( $file, undef, qw| :raw | );
        if ( ref $keystr_encoded ne qw| SCALAR |
            or not length $keystr_encoded->$* ) {
            $key_chksums{$name} = qw| r.err |;
        } else {

            $keystr_encoded = $keystr_encoded->$*;
            my $key_len = length $keystr_encoded;

            chomp($keystr_encoded)
                if not exists <crypt.C25519.keys.sizetype>->{$key_len}
                or <crypt.C25519.keys.sizetype>->{$key_len}->{'encoding'} ne
                qw| plain |;    ##  virtual keys only [ so far ]  ##

            my $key_L13sum = <[chk-sum.bmw.L13-str]>->($keystr_encoded);
            push $key_L13chksums{$name}->@*, $key_L13sum;

            my $key_checksum    ##  retrieve from chksum cache  ##
                = <[crypt.C25519.chksum_cache.retr]>->($key_L13sum);

            if ( defined $key_checksum ) {    ##  cache hit  ##
                if ( $key_checksum =~ m{(\w:\w|::)} ) {
                    $key_chksums{$name} = $key_checksum;
                } else {
                    $single_chksums{$name} = $key_checksum;
                }
                next;
            }
            my $key_len = length $keystr_encoded;   ##[  updating key len  ]##

            if ( not exists <crypt.C25519.keys.sizetype>->{$key_len} ) {
                <[base.logs]>->(
                    0, "length of key '%s' not valid [ %04d BYTES ]",
                    $filepath_rel, $key_len
                );
                $single_chksums{$name}
                    = $key_chksums{$name} = qw| size.error |;
                next;
            }

            my $key_details = <crypt.C25519.keys.sizetype>->{$key_len};
            my $type        = $key_details->{'type'};

            if ( $type eq qw| private | ) {    ##  is priv. key  ##

                my $key_bin = Crypt::Misc::decode_b32r $keystr_encoded;
                if ( not defined $key_bin ) {
                    $key_chksums{$name} = qw| dec.err |;
                } else {
                    substr( $key_bin, 0, 2, '' ) if $key_len == 106;

                    $key_bin = qw| [enc-key] |   ##  encrypted private key  ##
                        if $key_encryption_status == TRUE;

                    push @chksumkeys, $key_bin;
                    $single_chksums{$name}
                        = <[crypt.C25519.key_checksums]>->(@chksumkeys);
                }
            } elsif ( $type eq qw| public | ) {    ##  is a public key  ##

                my $key_bin = Crypt::Misc::decode_b32r $keystr_encoded;
                if ( not defined $key_bin ) {
                    $key_chksums{$name} = qw| dec.err |;
                } else {
                    push @chksumkeys, $key_bin;
                    $single_chksums{$name} = $key_chksums{$name}
                        //= <[crypt.C25519.key_checksums]>->(@chksumkeys);
                }
            } elsif ( $type eq qw| virtual | ) {    ##  is a virtual key  ##

                $single_chksums{$name} = $key_chksums{$name}
                    //= <[crypt.C25519.key_checksums]>->($keystr_encoded);
            }
        }
    }
    $last_kname = $name;
}

foreach my $name ( uniq <[base.sort]>->( \%key_chksums, \%single_chksums ) ) {
    $key_chksums{$name} //= $single_chksums{$name};
    ##  add chksum to cache file  ##
    foreach my $key_L13sum ( $key_L13chksums{$name}->@* ) {
        <[crypt.C25519.chksum_cache.add]>->(
            $key_L13sum, $key_chksums{$name}
        );
    }
}

return \%key_chksums;

#,,,,,,,,,,..,,,,,,,,,,,,,,,,,...,...,..,,...,..,,...,...,..,,...,,.,,,,.,...,
#OSOYIYX5773MA2YE6RYT6GBTOVBEP2O733FUEFSFVS4K5O4LDBH63HOXOHJR7U4UKPRAVPWOXWC5S
#\\\|TTHRLMMRIUOOH7DJ2C4XYPUNIA7XB4G3GS74TJ6UGJQTZXSDVRS \ / AMOS7 \ YOURUM ::
#\[7]EC23UA2IDICXNCLNRMVMHZZ7SBQB6CPAB7P7SPJTSPMDIXXSZABY 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
