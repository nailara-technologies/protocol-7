# >:]

# name   = base.handler.auth
# return = 0 (authentication successful), 1 (keep state), 2 (authentication failed)

my $id      = $_[0]->w->data;
my $session = $data{'session'}{$id};
my $input   = \$$session{'buffer'}{'input'};
my $output  = \$$session{'buffer'}{'output'};
my ( $auth_method, $auth_code, $auth_name );
($auth_method) = $$session{'auth'}{'method'}
    || split( /\s+/, $data{'auth'}{'methods'} );

$_[0]->w->stop;    # stop handler to modify buffer

if ( $$input =~ s/^(auth\.)?close\n// ) {
    $$output .= "ACK connection closed\n";
    <[base.log]>->( 1, "[$id] connection shutdown requested" );
    return 2;
} elsif ( $$input =~ s/^(auth\.)?select (\w+)\n// ) {    # select auth method

    $_[0]->w->start;

    if ( not exists $code{'auth.auth_select'} ) {
        <[base.log]>->( 0, "[$id] auth module not loaded, 'select' rejected!" );
        $$output .= ">:[\n";
        $$session{'shutdown'} = 1;

    } elsif ( ( $$session{'counter'}{'auth'}{'error'}{'select'} || 0 ) > 2 ) {
        $$output .= ">:[\n";
        $$session{'shutdown'} = 1;
    } elsif ( ( $$session{'counter'}{'auth'}{'select'} || 0 ) > 1 ) {
        <[base.log]>->( 0, "[$id] 3rd auth select request >:[" );
        $$output .= ">:[\n";
        $$session{'shutdown'} = 1;
    } else {
        if ( !<[auth.auth_select]>->( $id, $2 ) ) {
            $$session{'counter'}{'auth'}{'error'}{'select'}++;
        } else {
            $$session{'counter'}{'auth'}{'select'}++;
        }
    }
} elsif ( $$input =~ s/^(auth\.)?list\n// ) {    # list auth methods

    $_[0]->w->start;

    if ( not exists $code{'auth.auth_list'} ) {
        <[base.log]>->( 0, "[$id] auth module not loaded, 'list' rejected!" );
        $$output .= ">:[\n";
        $$session{'shutdown'} = 1;

    } elsif ( ( $$session{'counter'}{'auth'}{'list'} || 0 ) > 1 ) {
        <[base.log]>->( 0, "[$id] 3rd auth list requested >:[" );
        $$output .= ">:[\n";
        $$session{'shutdown'} = 1;
    } elsif ( ( $$session{'counter'}{'auth'}{'list'} || 0 ) > 0 ) {
        <[base.log]>->( 0, "[$id] repeated auth list requested.." );
        $$output .= "NACK once should be enough >;]\n";
        $$session{'counter'}{'auth'}{'list'}++;
    } else {
        <[base.log]>->( 1, "[$id] auth method list requested" );

        my $auth_list = <[auth.auth_list]>->($id);
        $auth_list = 'RAW ' . length($auth_list) . "\n" . $auth_list;
        $$session{'counter'}{'auth'}{'list'}++;
        $$output .= $auth_list;
    }
}

# call auth plugin

elsif ( exists $code{ 'plugin.auth.' . $auth_method } ) {

    $_[0]->w->start;

    ( $auth_code, $auth_name )
        = ( $code{ 'plugin.auth.' . $auth_method }->( $_[0] ) );

    if (    $auth_code == 0
        and defined $auth_name
        and $auth_name =~ <regex.base.usr> ) {
        my $fh = $data{'session'}{$id}{'handle'};
        $$session{'encryption'} = $data{'handle'}{$fh}{'encryption'} || 'none';
        $$session{'mode'}       = 'client';
        $$session{'user'}       = $auth_name;
        $$session{'auth_time'}  = <[base.time]>->(5);
        $$session{'authenticated'} = 'yes';

        $data{'user'}{$auth_name}{'session'}{$id}{'mode'} = 'client';

        $data{'user'}{$auth_name}{'connected_since'} = time()
            if delete $data{'user'}{$auth_name}{'last_seen'}
            or keys( %{ $data{'user'}{$auth_name}{'session'} } ) == 1;

        <[base.session.init_state]>->( $id, 1 );

        # disable the authentication timeout
        $$session{'watcher'}{'input_handler'}->timeout(undef);

        return 0;
    } elsif ( $auth_code == 1 ) {
        return 1;
    } else {
        return 2;
    }
} else {
    <[base.log]>->( 0, "auth plugin '$auth_method' not loaded" );
    return 2;
}
