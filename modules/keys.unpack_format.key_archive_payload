## >:] ##

# name  = keys.unpack_format.key_archive_payload

my $archive_payload_ref = shift;
if ( ref $archive_payload_ref ne qw| SCALAR | ) {
    warn 'expected scalar ref to archive payload <{C1}>';
    return undef;
} elsif ( not length( $archive_payload_ref->$* // '' ) ) {
    warn 'archive payload is empty or not defined <{C1}>';
    return undef;
}

my $payload_data_body;
my $header_str         = "## >:] ##\n#.\n";
my $archive_footer_str = "\n#.\n#.::\n";

if ( $archive_payload_ref->$*
    !~ m|^\Q$header_str\E(.+)\Q$archive_footer_str\E$|s ) {
    warn 'archive format not correct [ header \ footer ] <{C1}>';
    return undef;
} else {
    $payload_data_body = $LAST_PAREN_MATCH;
}

my $key_ref;
foreach my $key_line ( split "\n", $payload_data_body ) {
    if ( $key_line !~ m|^\['([^']+)'\]([A-Z2-7]+(\\n)?)$| ) {
        warn 'archive format not correct [ key line error ] <{C1}>';
        return undef;
    }
    my $name        = ${^CAPTURE}[0];    ## C25119-key file name ##
    my $encoded_key = ${^CAPTURE}[1];    ## base32 encoded key ##
    $encoded_key =~ s|\\n$|\n|;          ## restoring linefeed ##

    if ( exists $key_ref->{$name} ) {
        warn 'key archive error [ duplicate key ] <{C1}>';
        return undef;
    }

    $key_ref->{$name} = $encoded_key;    ##  storing extracted user key  ##
}
if ( not keys $key_ref->%* ) {
    warn 'key archive error [ no keys extracted ] <{C1}>';
    return undef;
}

return $key_ref;    ##  hash ref to keys  ##

#,,,,,..,,,.,,..,,...,,..,.,,,..,,.,.,..,,,..,..,,...,...,,,,,,..,,.,,,..,,..,
#W5W5QGHOOC3CF5WAGELRNHGN5SMVHGI5DDT37C34Z46N3QGRVZ44HTPOI5AW3ZM7454YV7X5NJCJ6
#\\\|QYAXUSPPR4JFM6WE7PL7EYDJAK5F4Z5UQI5FPELJ22L7F6SL5H7 \ / AMOS7 \ YOURUM ::
#\[7]KNXYDWGT3K2WU6JYA4NR7Y7NU6XXSASOYMTMZTF7BT6NQSN5O6BI 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
