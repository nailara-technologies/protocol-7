# >:]

# name = config.json.import_file

my $filename    = shift;
my $config_type = shift;    # <- optional (autodetect from filename if omitted)
my $absolute_path = shift // 0;
my $import_dir    = <config.json.import_dir>;
my $agent_name    = <system.agent.name>;
my $rules_subname = "$agent_name.config.import_rules";

die "invalid characters in config filename" if $filename =~ /\s/;

die "json file import is disabled in agent config"
    if not exists <config.json.import_allowed> or !<config.json.import_allowed>;

die "no import rules defined for agent '$agent_name'!"
    if not exists $code{$rules_subname};
my $import_rules = $code{$rules_subname}->();

die "config filename parameter expected"
    if not defined $filename or !length($filename);

if ($absolute_path) {
    die "expected abolute path" if $filename !~ /^\//;
    if ( $filename =~ s|^(\/(.+\/)?)([^\/]+)$|$3| ) {
        ( $import_dir = $1 ) =~ s|\/\/|\/|g;
        ( $import_dir = $1 ) =~ s|\/$|| if length($import_dir) > 1;
    }
} elsif ( $filename =~ m,^/|\.\., ) {
    die "invalid config filename (only relative paths allowed)";
}
$config_type = $1
    if not defined $config_type and $filename =~ /^[^\.]+\.([^\.]+)\.json$/;
warn "[!] failed to detect config type from filename, will try type 'config'\n"
    if not defined $config_type;
$config_type //= 'config';

die "no import rules defined for config type '$config_type'"
    if not exists $import_rules->{'keys'}->{$config_type};

my $import_key_rules = $import_rules->{'keys'}->{$config_type};

my @merge_keys;
my @delete_keys;
my @overwrite_keys;

@merge_keys = @{ $import_key_rules->{'merge'} }
    if exists $import_key_rules->{'merge'};
@delete_keys = @{ $import_key_rules->{'delete'} }
    if exists $import_key_rules->{'delete'};
@overwrite_keys = @{ $import_key_rules->{'overwrite'} }
    if exists $import_key_rules->{'overwrite'};

die "incomplete config import definition in '$filename'"
    if !@merge_keys
    and !@overwrite_keys;

my %key_count;
map { $key_count{$_}++ } ( @overwrite_keys, @delete_keys, @merge_keys );
foreach my $key_name ( keys %key_count ) {
    die "config import setup key collision for key '$key_name'"
        if $key_count{$key_name} > 1;
}

my $import_path = "$import_dir/$filename";

return
    <[base.log]>->( 2, "json config [$filename] not found, skipping import.." )
    if !-f $import_path;

if ($absolute_path) {
    <[base.log]>->( 1, "loading configuration file $import_dir/$filename" );
} else {
    <[base.log]>->( 1, "importing json cfg '$filename'.." );
}
my $json_data;
<[file.slurp]>->( $import_path, \$json_data );

my $import_data;
$@ = undef;
my $err_msg;
eval '$import_data = $data{json}{parser}->decode($json_data)';
( $err_msg = $@ ) =~ s| at \(.+\n$|| if defined $@;
die "json import of '$filename' failed: $err_msg"
    if defined $err_msg and length($err_msg);

foreach my $d_key (@delete_keys) {
    my $d_key_ref = <[base.resolve_key]>->($d_key);
    <[base.del_key]>->($d_key) if defined $d_key_ref;
}

foreach my $o_key (@overwrite_keys) {    # XXX: implement for key depth > 1
    $data{$o_key} = $import_data->{$o_key};
}

foreach my $m_key (@merge_keys) {        # XXX: implement for key depth > 1
    $data{$m_key} = merge( $data{$m_key}, $import_data->{$m_key} );
}

### key depth implementation example:

#foreach my $exp_key (@export_keys) {
#    my $parent_ref = $data_copy;
#    my @rest_keys = split /\./, $exp_key;
#    while ( my $k = shift @rest_keys ) {
#        if (@rest_keys) {
#            $parent_ref->{$k} //= {};
#            $parent_ref = $parent_ref->{$k};
#        } else {
#            $parent_ref->{$k} = ${ clone( <[base.resolve_key]>->($exp_key) ) };
#        }
#    }
#}
