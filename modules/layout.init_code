# >:]

# name = layout.init_code

use File::Path qw(make_path);
use FreezeThaw qw(cmpStr);

<list.layouts> = {
    'var'   => 'data',
    'key'   => 'layout.config.layouts',
    'mask'  => '<key>:name',
    'align' => { 'name' => 'left+1' },
    'descr' => 'configured layouts'
};

<layout.config_name>   //= 'default';
<layout.cfg_directory> //= '/etc/nailara/nailara.layout';
<layout.hash_file>     //= <layout.cfg_directory> . '/layout_file.sha1';
<layout.transition_in_progress> //= 0;
<layout.restore_layout_timeout> //= 300;    # seconds

delete <layout.config.ticker_agent_type>
    if defined <layout.config.ticker_agent_type>
    and <layout.config.ticker_agent_type> !~ /^gtk|sdl$/;
<layout.config.ticker_agent_type> //= 'gtk';

if ( !-d <layout.cfg_directory> ) {
    my $cfg_dir = <layout.cfg_directory>;
    my $perms   = '0750';
    if ( !-d $cfg_dir ) {
        <[base.log]>->( 1, "creating config directory '$cfg_dir'.. [$perms]" );
        my ( undef, undef, $uid, $gid ) = getpwnam(<system.privs.user>)
            or die "user '" . <system.privs.user> . "' not in passwd file";
        make_path( $cfg_dir,
            { mode => oct($perms), 'uid' => $uid, 'group' => $gid } )
            or die "make_path: $!";
    } else {
        my $old_perms = <[base.file_perm]>->($cfg_dir);
        if ( $old_perms ne $perms ) {
            <[base.log]>->(
                0, "<!> fixing config dir permissions [ $old_perms -> $perms ]"
            );
            chmod( oct($perms), $cfg_dir ) or warn("chmod($cfg_dir): $!");
        }
    }
}

goto skip_load if defined <layout.config.layouts>;

my $config_name     = <layout.config_name>;
my $config_filename = "config.layout.$config_name";
my $config_file_path;
$config_file_path = <layout.import_path> if defined <layout.import_path>;
$config_file_path //= <system.conf_path>;
$config_file_path .= "/$config_filename";

die "layout config file '$config_filename' not found!"
    if !-f $config_file_path;

<[base.log]>->( 1, ": loading layout configuration '$config_name'" );

<[file.put]>->(
    <layout.hash_file>, <[digest.sha.file_hex]>->($config_file_path) . "\n"
);
<layout.config> = <[base.load_section_config]>->($config_filename);

skip_load:    # <- jumping here if layout has already been imported as json!

my $current_cfg = <layout.cfg_directory> . '/layout.current';

if ( -f $current_cfg ) {
    <[base.log]>->( 1, "loading 'layout.current' config..." );
    my $cfg_content = ${ <[file.slurp]>->($current_cfg) };
    if ( $cfg_content =~ /^(\d+(\.\d+)?) +([^\n]+)\n$/s ) {
        ( my $t_stamp, my $layout_name ) = ( $1, $3 );
        my $timeout_secs = <layout.restore_layout_timeout>;
        my $delta_t = sprintf( "%.4f", <[base.time]>->(4) - $t_stamp );
        if ( $delta_t >= $timeout_secs ) {
            <[base.log]>->(
                1,
                "stored layout selection has timed out (${timeout_secs}s),"
                    . " ignoring.."
            );
            unlink($current_cfg) or warn("unlink($current_cfg): $!");
        } else {
            <[base.log]>->( 1, "loading 'layout.current' config..." );
            if ( defined <layout.default_layout>
                and <layout.default_layout> ne $layout_name ) {
                <[base.log]>->(
                    0, "restoring previous layout '$layout_name'..."
                );
                <layout.default_layout> = $layout_name;
            }
        }
    } else {
        <[base.log]>->( 0, ": <!> syntax error in 'layout.current' config..." );
    }
}

<[event.add_timer]>
    ->( { 'after' => 0, 'handler' => 'layout.callback.start_corner_logo' } );

<[base.log]>->( 0, "no default layout configured!" )
    if not exists <layout.default_layout>
    or not defined <layout.default_layout>
    or !length(<layout.default_layout>);

my $layout_name = <layout.default_layout>;
my $log_level   = 1;
my $default_str = ' default ';
if ( not exists <layout.config.layouts>->{$layout_name} ) {
    my $cfg_name_str = defined $config_name ? " '$config_name'" : '';
    <[base.log]>->(
        0,
        "default layout '$layout_name' "
            . "does not exist in layout config$cfg_name_str!"
    );
    ($layout_name) = sort keys %{<layout.config.layouts>};
    $default_str = ' _fallback_ ';
    $log_level   = 0;
}

$default_str //= ' default ';
$layout_name //= <layout.default_layout>;
<layout.current_layout> = $layout_name;

<[base.log]>->( $log_level, "selected${default_str}layout '$layout_name'" );

map {
    <base.watcher.signal>->{$_}->cancel
        if defined <base.watcher.signal>->{$_};
    my $uc_sig = uc($_);
    delete $SIG{$uc_sig} if defined $SIG{$uc_sig};
    <base.watcher.signal>->{$_} = <[event.add_signal]>
        ->( { 'signal' => $uc_sig, 'handler' => 'layout.handler.sig_term' } );
} ( 'int', 'term' );

0;
