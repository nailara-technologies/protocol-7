# >:]

# name  = pdf.html.parent.cmd.get_url
# param = <pdf_path> [width]
# descr = returns file:// url to html version of pdf

my ( $pdf_path, $target_width ) = split( / +/, $$call{'args'} );

return { 'mode' => 'nack', 'data' => 'expected path to pdf file!' }
    if not defined $pdf_path or !length($pdf_path);

return { 'mode' => 'nack', 'data' => 'file does not exist!' }
    if !-f $pdf_path;

return { 'mode' => 'nack', 'data' => 'target width parameter not numerical!' }
    if defined $target_width and $target_width !~ /^\d+$/;

if ( not defined $target_width ) {
    <[base.log]>->( 2, "no target width supplied, using document width!" );
    $target_width = <[pdf.html.base.get_page_width]>->($pdf_path);
}

my $html_path = <[pdf.html.base.get_html_path]>->( $pdf_path, $target_width );
( my $html_dir = $html_path ) =~ s|^.*/||;

if (    -d $html_path
    and !-f $html_path . '/.complete'
    and not exists <pdf.html.converting>->{$html_dir} ) {
    my $errors;
    <[base.log]>->(
        1, "incomplete conversion found, removing html dir '$html_dir'.."
    );
    remove_tree( $html_path, { error => \$errors } );
    for my $err (@$errors) {
        my ( $file, $message ) = %$err;
        if ( $file eq '' ) {
            <[base.log]>->( 0, "remove_tree($html_path): $message" );
        } else {
            <[base.log]>->( 0, "remove_tree: $message [$file]" );
        }
    }
    die "failed to remove '$html_path'" if @$errors;
}

if ( !-d $html_path ) {
    <pdf.html.converting>->{$html_dir} = 1;
    <[base.log]>->( 2, "creating html dir '$html_dir'.." );
    make_path($html_path) or die "make_path($html_path): $!";
    <[pdf.html.base.write_stub_page]>->($html_path);

    <[base.proto.nailara.command.send.local]>->(
        {   'command'   => "child.convert_pdf",
            'call_args' => { 'args' => "$pdf_path $target_width" },
            'reply'     => {
                'handler' => 'pdf.html.parent.handler.convert_pdf_reply',
                'params' =>
                    { 'pdf_path' => $pdf_path, 'html_path' => $html_path }
            }
        }
    );
}

<[file.write_timestamp]>->("$html_path/.last_used");

return { 'mode' => 'ack', 'data' => "file://$html_path/pdf.html" }
