## >:] ##

# name = crypt.C25519.init_code

<crypt.C25519.initialized> //= FALSE;

<[base.perlmod.load]>->('AMOS7::Twofish');
<[base.perlmod.load]>->( 'File::Path', qw| make_path | );

##  C25519 and BASE-32 modules loaded in 'pre_init'  ##

<crypt.C25519.autocreate-user-key> //= FALSE;

<crypt.C25519.key_usr> //= <system.amos-zenka-user>; #  <--  C25519 key owner.

<crypt.C25519.path.key_chksums_cache_file>
    //= sprintf qw| %s/.key-chksums.cache |,
    <[crypt.C25519.key_vars]>->{'key_dir'};

## regex ##
##
my $C25519_id = qw| C25519.B32 |;

my @key_ext   = qw| secret  public |;
my @key_types = qw| private public |;

( my $key_re_tmpl = $C25519_id ) =~ s|\.|\.|g;

my $re_keyfiles = sprintf qw| %s.(%s) |, $key_re_tmpl, join( '|', @key_ext );

my $name_regex = qr|[0-9a-zA-Z\._\-]+|;

delete <crypt.C25519.regex>    ##  allow updates during reload  ##
    if <[base.is_defined_recursive]>->(qw| crypt.C25519.regex |);

const <crypt.C25519.regex> => {
    qw| key_name | => qr|^$name_regex$|,
    qw| key_file | => {
        map {
            my $type = $ARG;
            my $xt   = $type;
            $xt = qw| secret | if $xt eq qw| private |;

            $type => qr|^($name_regex)\.$key_re_tmpl\.$xt$|

        } @key_types
    },
    qw| key_files | => qr|$re_keyfiles|
};

delete <crypt.C25519.keys.sizetype>    ##  allow updates during reload  ##
    if <[base.is_defined_recursive]>->(qw| crypt.C25519.keys.sizetype |);

const <crypt.C25519.keys.sizetype> => {
    32 => {
        qw| type |      => qw| public |,
        qw| encoding |  => qw| bin |,
        qw| prefixed |  => FALSE,
        qw| linefeed |  => FALSE,
        qw| old-form |  => FALSE,
        qw| encrypted | => FALSE
    },
    64 => {
        qw| type |      => qw| private |,
        qw| encoding |  => qw| bin |,
        qw| prefixed |  => FALSE,
        qw| linefeed |  => FALSE,
        qw| old-form |  => FALSE,
        qw| encrypted | => UNKNOWN    ##  requires public key test signing  ##
    },
    66 => {
        qw| type |      => qw| private |,
        qw| encoding |  => qw| bin |,
        qw| prefixed |  => TRUE,
        qw| linefeed |  => FALSE,
        qw| old-form |  => FALSE,
        qw| encrypted | => UNKNOWN,         ##  requires prefix match  ##
    },
    52 => {
        qw| type |      => qw| public |,
        qw| encoding |  => qw| b32 |,
        qw| prefixed |  => FALSE,
        qw| linefeed |  => FALSE,
        qw| old-form |  => TRUE,
        qw| encrypted | => FALSE
    },
    53 => {
        qw| type |      => qw| public |,
        qw| encoding |  => qw| b32 |,
        qw| prefixed |  => FALSE,
        qw| linefeed |  => TRUE,
        qw| old-form |  => FALSE,
        qw| encrypted | => FALSE
    },
    103 => {
        qw| type |      => qw| private |,
        qw| encoding |  => qw| b32 |,
        qw| prefixed |  => FALSE,
        qw| linefeed |  => FALSE,
        qw| old-form |  => TRUE,
        qw| encrypted | => UNKNOWN          ##  : probably : test required  ##
    },
    104 => {
        qw| type |      => qw| private |,
        qw| encoding |  => qw| b32 |,
        qw| prefixed |  => FALSE,
        qw| linefeed |  => FALSE,
        qw| old-form |  => TRUE,
        qw| encrypted | => FALSE
    },
    106 => {
        qw| type |      => qw| private |,
        qw| encoding |  => qw| b32 |,
        qw| prefixed |  => TRUE,
        qw| linefeed |  => FALSE,
        qw| old-form |  => FALSE,
        qw| encrypted | => UNKNOWN          ##  requires prefix match  ##
    },
};

0;

#,,,.,,,.,..,,,,.,,.,,,,,,..,,,,,,,..,.,,,...,..,,...,.,.,.,,,.,,,,.,,...,.,.,
#A25LOSDXCBZ2RM6IB4IN4465SWIWMXN6CK6BIWA7TUPYF7P2NXAUMRMVM4D4KIFF2I2OAZM3JYHW2
#\\\|PTXXAEL7J2GX2CQLFM3WKBVC2GXJNLNPGZ3U5XGM6W7G7J7PP6H \ / AMOS7 \ YOURUM ::
#\[7]RG7CCYD6OK6AV4JMGOC2MHKJ3LTH4YCWTW6BHDQYTAX4Q5ZS6SCQ 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
