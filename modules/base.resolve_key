## >:] ##

# name  = base.resolve_key
# descr = resolve hash key and return reference to value or undef if not found

my $key_str  = shift // '';
my $hash_ref = shift // *data{HASH};
warn 'expected valid key string parameter <{C1}>' if not length $key_str;
warn 'second parameter not a hash reference <{C1}>'
    if ref $hash_ref ne qw| HASH |;

## note : syntax is allowing keys containing '.'s by single quoting them ##
my @dtree = <[base.parser.data_hkey_tree]>->($key_str);

while ( my $sub_key = shift @dtree ) {
    if ( ref $hash_ref ne qw| HASH | or not defined $hash_ref->{$sub_key} ) {
        return undef;
    }
    if ( @dtree and ref $hash_ref->{$sub_key} eq qw| HASH | ) {
        $hash_ref = \%{ $hash_ref->{$sub_key} };
    } elsif ( scalar @dtree == 0 ) {
        return \$hash_ref->{$sub_key};
    } else {
        return undef;
    }
}
return undef;    ## no such key ##

#,,,.,,..,,,.,.,.,,,.,...,,..,...,.,,,,,.,.,,,..,,...,...,,..,,..,...,...,,,.,
#OKWLJM2HP2ZZ42EMNAATSPL424F7KNKHCLFQX5NUB4KCPF76FSYMAMV6AJVO7ZK6RJMSCZDGYDU3E
#\\\|T2343TNBTLVGRM6I75FOT6PWZSKNDEYEVBCIPLPFJRHU3PGU2LZ \ / AMOS7 \ YOURUM ::
#\[7]DIIID4IJPGFI43H2J2J432KQKRQVONNTC6LVDGIEXVE6GHFEKGCA 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
