## >:] ##

# name  = base.resolve_key
# descr = resolve hash key and return reference to value or undef if not found

my $key_str  = shift // '';
my $hash_ref = shift // *data{HASH};
if ( not length $key_str ) {
    warn 'expected valid key string parameter <{C1}>';
    return undef;
} elsif ( ref $hash_ref ne qw| HASH | ) {
    warn 'second parameter not a hash reference <{C1}>';
    return undef;
}

## note : syntax is allowing keys containing '.'s by single quoting them ##
my @dtree = <[base.parser.data_hkey_tree]>->($key_str);

while ( my $sub_key = shift @dtree ) {

    ##  value or other ref type present  ##
    return undef if ref $hash_ref ne qw| HASH |;

    return undef if not exists $hash_ref->{$sub_key};    ## no such key ##

    my $reftype = ref $hash_ref->{$sub_key};

    if (@dtree) {    ##  reftype == HASH  ##

        $hash_ref = $hash_ref->{$sub_key};    ##  collect reference type  ##

    } elsif ( scalar @dtree == 0 ) {   ##  last key element \ returning it  ##
        return {
            qw|  r-type  | => $reftype,
            qw|  r-data  | => $hash_ref->{$sub_key},
            qw| key-href | => $hash_ref,
            qw| last-key | => $sub_key
        };
    }
}
return undef;    ## no such key ##

#,,.,,,..,..,,..,,..,,..,,,..,,,,,.,.,.,,,..,,..,,...,...,,.,,.,.,,..,,,.,,..,
#GZODLL24YEZCWR6ZYE6UDPTNWNQYGQL5MTGKYS2VZPO6I4UNF6JEMMCWQYHPPKIGPKKL5UYTX7ROU
#\\\|URIHWV63QZQZGDPV2DMN2SJUG3ZZYFEA7KH73GPS6V6SADBPYY2 \ / AMOS7 \ YOURUM ::
#\[7]RFLVJQEDFPQC2VW6UZVYBNCXRZM7C3533R6LPKERN3PFAFCIFADQ 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
