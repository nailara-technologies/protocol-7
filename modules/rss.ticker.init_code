# >:]

# name = rss.ticker.init_code

<rss.data.tmp_path>          //= '/tmp';
<rss.ticker.txt_data_path>   //= '/tmp/rssdata/ticker-content.txt';
<rss.ticker.user_agent>      //= '';
<rss.ticker.item_seperator>  //= '.:.';
<rss.ticker.request_timeout> //= 5;

$ENV{'TIMINGBOTPATH'} = <rss.data.tmp_path>;
die "rss.data.tmp_path '$ENV{TIMINGBOTPATH}' not found"
    if !-d <rss.data.tmp_path>;

use XML::RSS::TimingBot;
use XML::RSS::Parser;
use File::Copy;
use Encode;
use feature 'unicode_strings';

( my $db_dir = <rss.data.tmp_path> . '/rssdata' ) =~ s,(/|\.\.)/,/,g;
if ( -d $db_dir ) {
    <[base.log]>->( 1, ": removing rss database directory '$db_dir'" );
    qx(rm -rf -- $db_dir);
}

<rss.browser> = XML::RSS::TimingBot->new;
<rss.parser>  = XML::RSS::Parser->new;
<rss.browser>->agent(<rss.ticker.user_agent>);
<rss.browser>->timeout(<rss.ticker.request_timeout>);

my @rss_urls;
<rss.ticker.url_hash> //= <[digest.sha1]>->('');
if ( defined <rss.ticker.content_url> ) {
    if ( ref(<rss.ticker.content_url>) ne 'HASH' ) {
        @rss_urls = (<rss.ticker.content_url>);
    } else {
        @rss_urls = map { <rss.ticker.content_url>->{$_} }
            keys %{<rss.ticker.content_url>};
    }
    <rss.ticker.url_hash>
        = <[digest.sha1]>->( join( '', map {"$_\n"} @rss_urls ) );
}

0;
