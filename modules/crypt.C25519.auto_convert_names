## >:] ##

# name  = crypt.C25519.auto_convert_names

my $key_dir = shift // '';

if ( not length $key_dir ) {
    warn 'expected key-dir param <{C1}>';
    return undef;
} elsif ( not -d $key_dir ) {
    <[base.log]>->( 0, ': key dir not found .., [ skipped auto-convert ]' );
    return undef;
} elsif ( not -r $key_dir ) {
    <[base.log]>->( 0, ': key dir not readable ., [ skipped auto-convert ]' );
    return undef;
}
<[base.log]>->( 2, ": [ auto-convert ] '$key_dir'..," );

my @key_files = grep {m{\.C25519\.B32}} <[file.all_files]>->($key_dir)->@*;

<[base.log]>->( 2, ": [ auto-convert ] no convertable keys present.," )
    and return
    if @key_files == 0;

map { <[base.log]>->( 0, $ARG ) }
    ( ':', ": [ auto_convert ] : .. renaming .. :.", ':' );

foreach my $source_path (@key_files) {
    my $target_path = $source_path;
    if ( $target_path =~ s|\.C25519\.B32|| ) {
        ( my $source_name = $source_path ) =~ s|^.*\/||;
        ( my $target_name = $target_path ) =~ s|^.*\/||;
        <[base.log]>->( 0, ": [ file '$source_name' ]" );
        <[base.log]>->( 0, ": target '$target_name'.," );
        if ( -e $target_path ) {
            map { <[base.log]>->( 0, $ARG ) }
                ( ':', "<< $source_name :: target path exists `:| >>" );
        } else {
            rename( $source_path, $target_path )
                or map { <[base.log]>->( 0, $ARG ) }
                ( ':', "<< $source_name : : \l$OS_ERROR >>" );
        }
    }
    <[base.log]>->( 0, ":" );
}

return scalar @key_files;    ##  return number of renamed files  ##

#,,..,.,,,,..,,,.,..,,,..,,.,,...,...,.,.,.,.,..,,...,...,...,..,,..,,,,,,.,.,
#JN4RLOD3FRI6PMBP2X75VVLPIMMJSQQCOHUEMK4K7PCPMWEAYTCMAYV335QIDHMCPLHXNMSSTABME
#\\\|MR7ZRYWFVTZO26Z64O2MAVXHPP75NVZ2ADPKTBTOGOPUP7ZQKAZ \ / AMOS7 \ YOURUM ::
#\[7]BIVJG7ME5EYULZAS6BEAS4DJBGBT5ORUPMVIFB3JB3SK4NKWQ6DQ 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
