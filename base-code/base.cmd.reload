# >:]

# name  = base.cmd.reload
# param = [keyword]
# descr = reload or reinit config and source code
my @keywords = qw|  config  source  plugins  init  all  |;

my $arg = $$call{'args'} // qw| all |;  ## [LLL] enable multiple keyword param
my $id  = $$call{'session_id'};

my ( $success, $output ) = ( 0, '' );

<base.debug.keep_on_reload>      //= 0; # <-- dbg. module persistence override
<base.reload.success.clean-code> //= 1; # <-- delete $data{'code'} [ success ]

my $s = ' ' x 5;
$$reply{'data'} = ":\n\n\n::\n\n";      # <-- header
my $reply_footer  = "\n::\n\n\n:\n";    # <-- footer
my $keyword_match = 0;

<system.reload.mode> = $arg; ## <-- <system.reload> deleted after completition

if ( $arg eq qw| config | or $arg eq qw| all | ) {
    $keyword_match = 1;
    delete <access.cmd.usr>;
    <[base.log]>->( 1, "[$id] < reload config >" );
    if (<[base.reload_config]>) {
        $$reply{'data'} .= "$s reload config  [ success ]\n";
    } else {
        $$reply{'data'} .= "$s reload config  [  ERROR  ]\n";
    }
    <[base.parser.access_conf]> if $arg eq qw| config |;
    $success = 1;
}
if ( $arg eq qw| source | or $arg eq qw| all | ) {

    my @reload_modules = <[base.clear_p7_mods]>;
    my %mod            = map { $ARG => 1 } @reload_modules;

    $keyword_match = 1;
    delete <base.commands>;
    <base.modules.load_errors> = 0;
    $data{'callbacks'}{'end_code'} = [];

    <[base.log]>->( 1, "[$id] < reload source code >" );

    if ( not <base.debug.keep_on_reload> and not exists $mod{'debug'} ) {
        <[base.log]>->( 0, '[reload] .. removing debug module [mem] .,' )
            if ref( $code{'debug.dump'} ) eq 'CODE';
        <[base.purge_code]>->('debug');    # [LLL] create unload mechanism
    } elsif (<base.debug.keep_on_reload>) {
        <[base.log]>->( 0, '<< keeping debug module enabled >>' );
        $mod{'debug'} = 1;
    } else {
        <[base.log]>->( 0, '<< debug module enabled in configuration >>' );
    }

    map { delete $data{'base'}{$ARG} } (qw|  cmd  console  overwritten  |);

    my $error = <[base.load_modules]>->(@reload_modules);
    if ( !$error and !<base.modules.load_errors> ) {
        $$reply{'data'} .= "$s reload source  [ success ]\n";
        $success = 1;
    } else {
        $$reply{'data'} .= "$s reload source  [  ERROR  ]\n";
    }

    ## source version ##
    my $src_version_file
        = catfile( $data{'system'}{'conf_path'}, 'protocol-7.src-ver' );
    if ( -f $src_version_file
        and open( my $ver_fh, '<' . $src_version_file ) ) {
        my $old_version = <protocol-7.src-ver> // '';
        ( <protocol-7.src-ver> = <$ver_fh> ) =~ s|\s||g;
        close($ver_fh);
        <[base.log]>->(
            0, sprintf( 'NEW SOURCE CODE [ %s ]', <protocol-7.src-ver> )
        ) if <protocol-7.src-ver> ne $old_version;
    } else {
        <protocol-7.src-ver> = 'unknown';
    }

    ## release version ##
    my $rel_version_file
        = catfile( $data{'system'}{'conf_path'}, qw| protocol-7.rel-ver | );
    if ( -f $rel_version_file
        and open( my $ver_fh, '<' . $rel_version_file ) ) {
        my $old_release = <protocol-7.rel-ver> // '';
        ( <protocol-7.rel-ver> = <$ver_fh> ) =~ s|\s||g;
        close($ver_fh);
        <[base.log]>->(
            0,
            sprintf(
                'RELEASE VERSION : %s --> %s',
                $old_release, <protocol-7.rel-ver>
            )
        ) if <protocol-7.rel-ver> ne $old_release;
    } else {
        <protocol-7.rel-ver> = qw| unknown |;
    }
}
if ( $arg eq qw| plugins | or $arg eq qw| all | ) {
    $keyword_match = 1;
    <[base.log]>->( 1, "[$id] < reload plugins >" );
    if (<[base.reload_plugins]>) {
        $$reply{'data'} .= "$s plugin reload  [ success ]\n";
        $success = 1;
    } else {
        $$reply{'data'} .= "$s plugin reload  [  ERROR  ]\n";
    }
}
if ( $arg eq qw| init | or $arg eq qw| all | ) {
    $keyword_match = 1;

    delete <base.templates.sprintf>; ##  require automatic reload on 'src'  ##

    <[base.log]>->( 1, "[$id] < source code reinit >" );
    if ( <[base.init_modules]>->() ) {
        $$reply{'data'} .= "$s reinit source  [ success ]\n";
        $success = 1;
    } else {
        $$reply{'data'} .= "$s reinit source  [  ERROR  ]\n";
    }
}
if ( !$keyword_match ) {
    <[base.log]>->( 0, "[$id] invalid reload keyword '$arg' called.," );
    return { 'mode' => 'false', 'data' => "unknown reload keyword '$arg'" };
}
if ($success) {
    <[base.log]>->( 1, "[$id] .. reloading complete =)" );
    if (<base.reload.success.clean-code>) {
        <[base.log]>->( 2, ":.. cleaning up 'code' namespace .," );
        delete $data{'code'};
    }
} else {
    <[base.log]>->( 0, "[$id] reloading $arg was not successful `:|" );
}

delete <system.reload>;    ## completed ##

$$reply{'mode'} = qw| data |;
$$reply{'data'} .= $reply_footer;

#.............................................................................
#R2LH7GG3RPMIQDZJSPXBMRGKXJD2IBXUIFXWH7JZD32TN52JG4S2VYA467WOWKN3ZXPKGCGCAJPGA
#::: GSOYVFQHQQRV3WIBA4KOUWVWTPJU6TCR4I2STG7E24IMLLE7SUV :::: NAILARA AMOS :::
# :: NLB5QD5TSH7JMJW5IBCSKGWBX25QDY6UCOW54NVBSMYT5XO3ZYCA :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
