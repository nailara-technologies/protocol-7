# >:]

# name  = base.session.init
# descr = creates and initializes a new session

my ( $fd, $protocol, $mode, $name ) = @_;

$protocol //= qw| protocol-7 |;
$mode     //= qw| client |;

my $re = <regex.base>;

if ( not defined $fd ) {
    <[base.log]>->(
        0,
        '< base.session.init > [undefined filehandle] cannot create session'
    );
    <[base.session.check_remaining]>;
    return undef;
}

if ( defined $name and $name !~ $re->{usr} ) {
    <[base.log]>->(
        0,
        "< base.session.init > value '$name' for parameter name is not valid"
    );
    <[base.session.check_remaining]>;
    return undef;
}

$name //=
    $mode eq qw| server |
    ? <base.session.uname.server>
    : <base.session.uname.client>;

if ( not defined $data{'protocol'}{$protocol} ) {
    <[base.log]>->( 0, "< base.session.init > unknown protocol '$protocol'" );
    <[base.session.check_remaining]>;
    return undef;
}

my $initialized = $mode eq qw| server | ? 1 : 0;

my $id = <[base.list.element.add]>->(
    {   'key_ref' => \$data{'session'},
        'val_ref' => \{
            'start_time'     => <[base.time]>->(5),          ## ntime ## [LLL]
            'protocol'       => $protocol,
            'handle'         => $fd,
            'link'           => $data{'handle'}{$fd}{'link'},
            'mode'           => $mode,
            'state'          => 0,
            'paused'         => 0,
            'complete'       => 1,
            'shutdown'       => 0,
            'initialized'    => $initialized,
            'flush_shutdown' => 0,
            'user'           => $name,
            'size'           => {
                'buffer' => {
                    'input'  => $data{'size'}{'buffer'}{'input'},
                    'output' => $data{'size'}{'buffer'}{'output'},
                }
            },
            'buffer' => { 'input' => '', 'output' => '' }
        }
    }
);

if ( $name ne <base.session.uname.server> ) {
    $mode = $data{'user'}{$name}{'session'}{$id}{'mode'} = qw| client |;
}

$data{'handle'}{$fd}{'cid'} = $id if $mode eq qw| client |;

$data{'watcher_list'}{'paused'} = []
    if not defined $data{'watcher_list'}{'paused'}
    or ref( $data{'watcher_list'}{'paused'} ) ne qw| ARRAY |;

$data{'session'}{$id}{'watcher'}{'shutdown_trigger'} = <[event.add_var]>->(
    {   'var'     => \$data{'session'}{$id}{'shutdown'},    ## VARIABLE ##
        'poll'    => qw| w |,
        'handler' => qw| base.session.check.close |,
        'repeat'  => 0,
        'data'    => $id,
        'desc'    => "[$id] shutdown trigger"
    }
);

$data{'session'}{$id}{'watcher'}{'flush_shutdown'} = <[event.add_var]>->(
    {   'var'     => \$data{'session'}{$id}{'flush_shutdown'},  ## VARIABLE ##
        'poll'    => qw| w |,
        'handler' => qw| base.session.check.flushed |,
        'repeat'  => 0,
        'data'    => $id,
        'desc'    => "[$id] flush output and shutdown trigger"
    }
);

$data{'session'}{$id}{'watcher'}{'input_buffer'} = <[event.add_var]>->(
    {   'var'     => \$data{'session'}{$id}{'buffer'}{'input'}, ## VARIABLE ##
        'handler' => qw| base.handler.input |,
        'poll'    => qw| w |,
        'repeat'  => 1,
        'data'    => $id,
        'desc'    => "[$id] input buffer"
    }
);

$data{'session'}{$id}{'watcher'}{'output_buffer'} = <[event.add_var]>->(
    {   'var' => \$data{'session'}{$id}{'buffer'}{'output'},    ## VARIABLE ##
        'handler' => qw| base.handler.write |,
        'poll'    => qw| w |,
        'data'    => $id,
        'prio'    => -1,
        'repeat'  => 0,
        'desc'    => "[$id] output buffer"
    }
);

if ( $mode eq qw| server | ) {    ##  SERVER SOCKET  ##

    <[event.add_io]>->(
        {   'fd'      => $fd,
            'handler' => qw| base.handler.connect |,
            'data'    => $id,
            'poll'    => qw| r |                     ## connection requests ##
        }
    );
    <[event.add_io]>->(                              ### ,.. TESTING .., ###
        {   'fd'   => $fd,
            'cb'   => sub { warn "[$id] socket exception handler called" },
            'data' => $id,
            'poll' => qw| e |
        }
    );
} else {

    my @timeout_callback
        = (
               $protocol ne qw| protocol-7 |
            or $name ne <base.session.uname.server>
            and $name ne <base.session.uname.client>
        )
        ? ()
        : (
        # set up auth. [input] timeout for protocol-7 sessions
        'timeout'    => <net.auth.timeout> || 13,
        'timeout_cb' => sub {
            <[base.log]>->( 1, "[$id] authentication timeout.," );
            $data{'session'}{$id}{'buffer'}{'output'} .= ">:|\n";
            $data{'session'}{$id}{'shutdown'} = 1;
        }
        );

    if ( $protocol eq 'http' and $name eq <base.session.uname.server> ) {

        # http[d] timeout
        @timeout_callback = (
            'timeout'    => <httpd.timeout> || 13,
            'timeout_cb' => sub {
                <[base.log]>->( 1, "[$id] .. http timeout .," );
                $data{'session'}{$id}{'shutdown'} = 1;
            }
        );
    } elsif ( defined <net.input_timeout> ) {    # generic input timeout
        <[base.logs]>->(
            2,                   'setting up %s second%s input timeout',
            <net.input_timeout>, <[base.cnt_s]>->(<net.input_timeout>)
        );
        @timeout_callback = (
            'timeout'    => <net.input_timeout>,
            'timeout_cb' => sub {
                <[base.log]>->(
                    1,
                    sprintf(
                        "[$id] input timeout after %s second%s.",
                        <net.input_timeout>,
                        <[base.cnt_s]>->(<net.input_timeout>)
                    )
                );
                $data{'session'}{$id}{'shutdown'} = 1;
            }
        );
    }
    $data{'session'}{$id}{'watcher'}{'input_handler'} = Event->io(
        'fd'     => $fd,
        'cb'     => sub { &{ $code{'base.handler.read'} } },
        'poll'   => scalar(@timeout_callback) ? qw| rt | : qw| r |,
        'prio'   => 1,
        'data'   => $id,
        'repeat' => 0,
        'desc'   => "[$id] input handler",
        @timeout_callback    # disabled eventually in 'base.handler.auth'
    );

    ## set error handler here ## [LLL]
    $data{'session'}{$id}{'watcher'}{'input_error'} = Event->io(
        'fd'     => $fd,
        'cb'     => sub { &{ $code{'base.handler.session_error'} } },
        'poll'   => qw| e |,
        'prio'   => 2,
        'data'   => $id,
        'repeat' => 0,
        'desc'   => "[$id] input error handler"
    );
}

if ( not <[base.session.init_state]>->( $id, 0 ) ) {
    $data{'session'}{$id}{'shutdown'} = 1;
    warn "cannot initialize $protocol protocol session $id";
    return undef;
}

return $id;

#.............................................................................
#MUF2XFZRNAM3ZCQ5BP4JTUFDHDKQCTBUVUH3MQFLQWS3OCFZ4CZYFG4C4HO5NKXKR6XKNJ5M2YZQW
#::: LHKYVLCHQIYRI4IIX5LXQD2O6OKHKKW7AL6TFXCTCBX34BFCEP6 :::: NAILARA AMOS :::
# :: Z4AT4LA5BJHWA2N5M7C4IFPAKZZ66J7YEN5MN3D6VI3M2FCMREAA :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
