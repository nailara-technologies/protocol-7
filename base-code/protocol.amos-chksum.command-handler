# >:]

# name  = protocol.amos-chksum.command-handler

my $id = $_[0]->w->data;

return 2 if not defined $data{'session'}{$id};

##[ INITIALIZATION \ VARIABLE SET-UP ]########################################

my $session = $data{'session'}{$id};
my $user    = $session->{'user'};

##  initialize empty  ##
$session->{'binary-mode'}         //= 0;
$session->{'binary-input-length'} //= 0;

$session->{'amos-chksum'}->{'modes'}    ##  set from AMOS::CHKSUM  ##
    //= $AMOS::CHKSUM::algorithm_set_up{'elf_truth_modes'};

my $input  = \$session->{'buffer'}->{'input'};
my $output = \$session->{'buffer'}->{'output'};

##[ BINARY MODE DATA INPUT ]##################################################

if ( $session->{'binary-mode'} ) {

    my $binary_state;

    if ( $session->{'binary-input-length'} > 0 ) {    ##  more imput data  ##
        $session->{'binary-input'} //= {
            'elf_checksum' => 0,
            'bmw-context'  => Digest::BMW->new(512)
        };
        return 1 if not length($$input);              ##  <-- not expected  ##
        $binary_state = $session->{'binary-input'};

        my $buffer_len = length($$input);

        my $buffer_str
            = substr( $$input, 0, $session->{'binary-input-length'}, '' );

        ##  add elf checksum state  ##  input data at elf mode 7  ##
        $binary_state->{'elf_checksum'} = <[chk-sum.elf.inline]>->(
            \$buffer_str, $binary_state->{'elf_checksum'}, 7
        );
        ##  add to bmw checksum state  ##
        $binary_state->{'bmw-context'}->add($buffer_str);

        $session->{'binary-input-length'} -= $buffer_len - length($$input);

        return 1 if $session->{'binary-input-length'} > 0; ## more expected ##
    }

    if ( defined $binary_state and $session->{'binary-input-length'} == 0 )
    {    ## calc amos-chksum ##

        $$output .= sprintf(
            "%s\n",
            AMOS::CHKSUM::amos_chksum(
                {   'elf_checksum' => $binary_state->{'elf_checksum'},
                    'BMW_checksum' => $binary_state->{'bmw-context'}->digest

                },
                @{ $session->{'amos-chksum'}->{'modes'} }
            )
        );

        $session->{'binary-mode'} = 0;
        delete $session->{'binary-input'};
    }    ## else not defined $binary_state ..,
}

##[ LIMITING REQUEST SIZE ]###################################################

my $max_cmd_len = 64;

if ( $$input =~ m|^[^\n]{$max_cmd_len}\n?| ) {
    <[base.log]>->(
        0, "[$id] maximum command length [ $max_cmd_len bytes ] exceeded."
    );
    $$output .= "maximum command size exceeded\n";
    return 2;    ##  <-- closing connection \ command not parseable  ##
}

##[ PARSING COMMANDS ]########################################################

my $peer_fh = $session->{'handle'};

$session->{'amos-chksum'}
    //= { 'modes' => $AMOS::CHKSUM::algorithm_set_up::elf_truth_modes };

return 1 if $$input =~ s|^\r?\n+||s or $$input !~ s|^([^\n]+)\r?\n+||s;

## : <mode> [<mode[s]>] : ## <-- modes syntax example
if ( $LAST_PAREN_MATCH =~ m|^:\s*((\D*\d+\D*)+)\s*:$| ) {  ## no cmd output ##

    my @modes_str = split( m|\D+|, ${^CAPTURE}[0] );
    $session->{'amos-chksum'}->{'modes'} = \@modes_str;

} elsif ( $LAST_PAREN_MATCH =~ m|^  (.+)$| ) { ##  indented chksum request  ##
    my $modes_ref = $session->{'amos-chksum'}->{'modes'};

    my $chksum_str
        = eval { <[chk-sum.amos]>->( \$LAST_PAREN_MATCH, @{$modes_ref} ) };

    if ( $EVAL_ERROR or not length( $chksum_str // '' ) ) {
        if ($EVAL_ERROR) {
            warn join( ' ',
                '[chk-sum.amos]',
                <[base.format_error]>->( $EVAL_ERROR, -1 ) );
        } else {
            warn '[chk-sum.amos] no result returned';
        }
        return 2;   ## disconnect [ without tainted or missing result string ]
    }

    $$output .= sprintf( "%s\n", $chksum_str );

} elsif ( $LAST_PAREN_MATCH =~ m|^(\S+)( +(.+))?$| ) {  ## protocol command ##
    my $command     = ${^CAPTURE}[0];
    my $params      = ${^CAPTURE}[2];
    my $cmd_handler = "protocol.amos-chksum.ext-cmd.$command";
    if ( not defined $code{$cmd_handler} ) {
        $$output .= "no such command\n";
        return 0;
    } else {
        my $return_href = eval { $code{$cmd_handler}->( $id, $params ) };
        if ( $EVAL_ERROR or ref( $return_href // '' ) ne 'HASH' ) {
            if ($EVAL_ERROR) {
                warn join( ' ',
                    "[amos-ext-cmd:$command]",
                    <[base.format_error]>->( $EVAL_ERROR, -1 ) );
            } else {
                warn '[amos-ext-cmd:$command] expected hash reference';
            }
            $$output .= "[ error in command handler ]\n";
            return 0;
        }

        my ( $mode, $return_data )
            = ( $return_href->{'mode'}, $return_href->{'data'} );
        my $return_code = $mode eq 'term' ? 2 : 0;

        if ( $mode eq qw| binary | ) {
            $session->{'binary-mode'}         = 1;
            $session->{'binary-input-length'} = $return_data;

        } elsif ( $mode eq qw| data | ) {
            $$output .= $return_data;
        } else {
            $$output .= sprintf( "%s\n", $return_data );
        }
        return $return_code;
    }
} else {
    $$output .= sprintf( "protocol hint : %s\n",
        'content to checksum requires 2 space indentation' );
    return 0;
}

##############################################################################

### NEXT COMMANDS ## [LLL]
##
## select ## keep modes, disable commands and remove prefix requirement
## seperator ## set data seperator [ i.e. \n or \t ,.. ]
##
## [ binary bits : data width selection [ i.e. 7 bit multiples ] ?

return 0;

#.............................................................................
#VN45RSLFLY3HEMQ2DBZJ3KAGHDJ5V5DZPPBGUYMVNXQVVNZLD5WNZMHIDDCVPXKLB2GND7SB2FYIY
#::: ZCJHSUPUZKJOF7YVKFBFE2WDFR3ML34X5EFKM2MQP23QQP6QZJN :::: NAILARA AMOS :::
# :: A4FUULAGLLZBYUZM4VISRUK3WZXUX6X46TWE6Q643XJ5HBGRDOAA :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
