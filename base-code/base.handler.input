# >:]

# name  = base.handler.input
# descr = call input handler

my $id = $ARG[0]->w->data;

if ( not defined $id or not defined $data{'session'}{$id} ) {
    my $id = '!!!' if not defined $id;
    $ARG[0]->w->cancel;
    ## call cleanup handler.., [protocol.,]                              [LLL]
    <[base.log]>->( 0, "[$id] input handler session was already closed.," );
    return undef;
}

my $session   = $data{'session'}{$id};
my $fd        = $session->{'input'}->{'handle'} // $session->{'handle'};
my $type      = $data{'handle'}{$fd}{'link'};
my $proto     = $session->{'protocol'};
my $state     = $session->{'state'};
my $mode      = $data{'handle'}{$fd}{'mode'};
my $handler   = $session->{'input'}->{'handler'};
my $start_len = length( $session->{'buffer'}->{'input'} );

$session->{'shutdown'} //= 0;

if ( exists $code{$handler} and defined &{ $code{$handler} } ) {

    my $ret_code = $code{$handler}->( $ARG[0] );

    ## return code 0 ## command processed  [ removed from buffer ]
    ## return code 1 ## ..not complete.,   [ more data expected. ]

    ## call [registered] error handler in next case ##                   [LLL]
    warn "return code of $handler not defined" and $ret_code = 2
        if not defined $ret_code;
    warn "not expected return code from $handler : '$ret_code'"
        and $ret_code = 2
        if $ret_code !~ m|^\d+$|;
    ##

    $session->{'complete'} = $ret_code == 1 ? 0 : 1;

    ## return code 2 ## terminate session and close connection ##
    if (   $ret_code == 2
        or $session->{'shutdown'}
        or $session->{'flush_shutdown'} ) {
        $ARG[0]->w->cancel;    ##  no longer watching buffer content  ##

        ##  secure buffer erasing  ##
        <[base.erase_buffer_content]>->( \$session->{'buffer'}->{'input'} );

        $session->{'flush_shutdown'} = 1
            if not $session->{'shutdown'}
            and not $session->{'flush_shutdown'};

        <[base.log]>->(
            2, "[$id] stopped input processing [ session shutdown ]"
        );
    }
    ##
} else {

    ##  stopping variable watcher to modify buffer content  ##
    $ARG[0]->w->stop;

    ##  secure buffer erasing  ##
    <[base.erase_buffer_content]>->( \$session->{'buffer'}->{'input'} );

    $ARG[0]->w->start;    ##  modification complete restarting watcher  ##

    <[base.log]>->(
        0, "[$id] input handler '$handler' not defined, buffer emptied.,"
    );

    if (   $session->{'mode'} eq qw| client |
        or $session->{'mode'} eq qw| in | ) {
        $session->{'shutdown'} = 1;
    }
}

my $len = length( $session->{'buffer'}->{'input'} );
return $ARG[0]->w->cancel if not defined $len;  ## <-- buffer 'not defined' ##

if (    $len < $data{'size'}{'buffer'}{'input'}
    and not $session->{'shutdown'}
    and not $session->{'flush_shutdown'} ) {
    push( @{ $data{'watcher_list'}{'paused'} }, \$ARG[0] );
    if ( !$data{'watcher'}{'io'}{'transfer'}->is_running ) {
        $data{'watcher'}{'io'}{'transfer'}->start;
    }
}

##  restarting watcher if it was still stopped  ##
if ( !$session->{'watcher'}->{'input_buffer'}->is_running ) {
    $session->{'watcher'}->{'input_buffer'}->now;
}

##  buffer contains complete line ?  ##
$session->{'watcher'}->{'input_buffer'}->now
    if $len
    and $len != $start_len
    and not $session->{'shutdown'}
    and not $session->{'flush_shutdown'}
    and index( $session->{'buffer'}->{'input'}, "\n" ) >= 0;

# if ( !$session->{'watcher'}->{'output_buffer'}->is_running ) {
#    $session->{'watcher'}->{'output_buffer'}->now;
# }

#.............................................................................
#M2S7RRSW7ITWLBSVGFAZTV3XEVJ7NXNHTEK2IGJRT3TBJZUETZ5YUGEZOM6J44TSNKREQLLU7QEEY
#::: 56ZW3R324FDNR6P36GCGURUFG7L6KCBXQLOJXMHTXO45N53AE2U :::: NAILARA AMOS :::
# :: 2JXOSAQXPIESQGXYOQTR4LK3QCCV7B3BE3FOD6IXLTKG7F5CQSDI :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
