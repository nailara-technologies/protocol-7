# >:]

# name  = graphics-matrix.cmd.filter
# param = <color|'auto'> <image>
# descr = replaces specified color with transparency

my $params = shift // {};
my ( $color_str, $input_file ) = split( / +/, $params->{'args'}, 2 );

return { 'mode' => 'false', 'data' => 'expected alpha color parameter' }
    if not defined $color_str or !length($color_str);
return { 'mode' => 'false', 'data' => 'expected path to image file' }
    if not defined $input_file or !-f $input_file;
return { 'mode' => 'false', 'data' => 'input file not found' }
    if !-f $input_file;

my $image_sha1 = <[chk-sum.sha.file_hex]>->($input_file);

my $image  = Graphics::Magick->new;
my $status = $image->Read($input_file);
return { 'mode' => 'false', 'data' => "$status" } if "$status";

$image->Trim() if $color_str eq 'auto';

$color_str = <[graphics-matrix.guess_bg_color]>->($image)
    if $color_str eq 'auto';

my $color_md5 = <[chk-sum.md5.b64u]>->($color_str);

my $output_file = join( '/',
    <graphics-matrix.cache_dir>, $image_sha1 . $color_md5 . '.png' );

unlink($output_file)
    if -f $output_file and File::stat::stat($output_file)->size == 0;

<[base.log]>->( 1, "output file: $output_file" );

return { 'mode' => 'true', 'data' => $output_file } if -f $output_file;

my ( $img_w, $img_h ) = $image->get( 'width', 'height' );

<[graphics-matrix.filter_image]>->( $image, $color_str );   # apply the filter

$image->Write($output_file);
return { 'mode' => 'false', 'data' => "$status" } if "$status";

return { 'mode' => 'true', 'data' => $output_file }

#.............................................................................
#TTCWRHXM3M73OJP6L2XY3O6QIQBIIZXSH62XRDS33TGFJJNWHGGMV2ZYSQNR4AOTINHC22H6HHDJW
#::: ZQMFCAH52X5F7IPQT4JQAJMCYVRRINTBXXQAQWZ4AOVE6R2B477 :::: NAILARA AMOS :::
# :: WDJSNXOYJ2FA4QHQIBU54VPFW5YMVYC7XMG6WP4VOIRJOTCFMIDY :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
