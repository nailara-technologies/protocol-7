## >:] ##

# name  = base.file.make_path
# descr = recursively create a directory path

my ( $path, $param_mode, $param_owner ) = @ARG;

$param_mode //= 0700;    # <-- strict default
$param_mode = oct($param_mode) if $param_mode =~ m|^0|;
warn '<path> not defined <{C1}>' and return undef if not defined $path;
return warn 'expected absolute path [ to create ] <{C1}>' and return undef
    if $path !~ m|^/[^/]+|;

my $mkdir_umask = 0777;    ## <-- permissive setting.., ##

## optionally recursive mode array [ reference ] ##  <-- expand [owners] [LLL]
my $modes = ref($param_mode) ne qw| ARRAY | ? [$param_mode] : $param_mode;

### path clean-up ####
$path =~ s|/[^/]+/\.\./||g;
$path =~ s|//|/|g;
$path =~ s|/$||;

return warn sprintf( "path not valid : '%s' <{C1}>", $path )
    if $path !~ m|^/[^/]+|;

if ( -d $path ) {
    <[base.log]>->( 2, ':. path present =)' );
    <[base.log]>->( 2, ": $path" );

    ## check permissions of existing directory .., ##
    my $old_perms = <[base.file_perm]>->($path);

    if ( $old_perms ne sprintf '%#o', $param_mode ) {
        <[base.logs]>->(
            0, '<< resetting permissions of %s [ %s --> %04o ] >>',
            $path, $old_perms, $param_mode
        );
        chmod( $param_mode, $path )
            or warn sprintf( 'chmod[ %s ] : %s',
            $path, <[base.format_error]>->($OS_ERROR) );
    }
    ##
    return $path;
}

my ( $uid, $gid );
if ( defined $param_owner ) {
    return warn sprintf( "not valid username ['%s'] <{C1}>", $param_owner )
        if $param_owner !~ <regex.base.usr>;
    ( undef, undef, $uid, $gid ) = getpwnam($param_owner)
        or return
        warn sprintf( "owner %s not in passwd file <{C1}>", $param_owner );
}

my $install_root = <system.root_path>;
( my $report_path = $path ) =~ s|^$install_root/?||;

<[base.logs]>->( 2, ":. creating., .: ['%s']", $report_path );

my $previous_umask = umask($mkdir_umask)
    or return warn sprintf( "umask[ %s ] : [ %s ] mkdir aborted .., <{C1}>",
    $mkdir_umask, <[base.format_error]>->($OS_ERROR) );

my $current_mode;
my $current_path = '';
foreach my $_dir ( split qw| / |, $path ) {
    next if not length $_dir;

    $current_path .= sprintf '/%s', $_dir;
    $current_mode //= shift @{$modes};

    next if -d $current_path;    ## <-- exists \ continue ., ##

    mkdir( $current_path, $current_mode )
        or warn sprintf( 'mkdir[ %s ] : [ %s ] <{C1}>',
        $current_path, <[base.format_error]>->($OS_ERROR) );

    $current_mode = oct $current_mode if $current_mode =~ m|^0|;

    chmod( $current_mode, $current_path )
        or warn sprintf( 'chmod[ %04o ] : [ %s ] <{C1}>',
        $param_mode, <[base.format_error]>->($OS_ERROR) );
    if ( defined $param_owner ) {
        chown( $uid, $gid, $current_path )
            or warn sprintf( 'chown [%d:%d] %s : [ %s ] <{C1}>',
            $uid, $gid, $current_path, <[base.format_error]>->($OS_ERROR) );
    }
}

umask $previous_umask;

return $path;

#,,.,,.,.,.,,,,,.,,,.,.,,,,,,,,,.,..,,,,.,,,,,..,,...,...,,..,.,,,,,.,,..,..,,
#WSLF5XP6EOW4XLR77YQPOJYQSQET4IJ7J7BHWWHKYB4R2LHKZQSBDAO2SIMWJF4REXSXRT7T44I2S
#\\\|IFSE4UPYWPKRRZN2TLPFIITDU2TTLZX6EGWZYYOL7K2GBFQF6PR \ / AMOS7 \ YOURUM ::
#\[7]27RLDMWXKB3KX733EID4VRJTE7CDU5EXHUGU6VDKQ3NINATVJGBI 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
