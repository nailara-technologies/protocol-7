## >:] ##

# name  = io.unix.socket.input.open

my $socket_path  = shift;
my $socket_umask = shift // 0775;

<[base.start.unlink_child]>;

undef <unix.socket_paths> if ref(<unix.socket_paths>) ne qw| ARRAY |;
<unix.socket_paths> //= [];

my $uaddr = sockaddr_un($socket_path);
my $proto = getprotobyname('tcp');

unlink( my $tmp_spath = "$socket_path.NEW" );
my $unix_sock = IO::Socket::UNIX->new(
    Type   => SOCK_STREAM(),
    Local  => $tmp_spath,
    Listen => SOMAXCONN(),
) || die "io.unix.socket.input.open: socket: \l$OS_ERROR";

rename( $tmp_spath, $socket_path )
    or die "io.unix.socket.input.open: rename: \l$OS_ERROR";

##  unlink child removes path in io.unix.socket.end_code  ##
push( @{<unix.socket_paths>}, $socket_path );

chmod( $socket_umask, $socket_path )
    or die "io.unix.socket.input.open: chmod: \l$OS_ERROR";

( my $sp_str = $socket_path ) =~ s{^\Q/var/run/.7/UNIX/\E}{};
<[base.logs]>->( 1, "UNX server launched [unix:%s]", $sp_str );

if ( defined $data{'handle'}{$unix_sock} ) {
    <[base.log]>->(
        0,
        "io.unix.socket.input.open: handle '$unix_sock' "
            . "was not cleaned up, doing now .,"
    );
    delete $data{'handle'}{$unix_sock};
}

$data{'handle'}{$unix_sock}{'link'} = qw| unix |;
$data{'handle'}{$unix_sock}{'mode'} = qw| input |;

return $unix_sock;

#,,,.,...,,,.,.,,,,,.,..,,..,,.,.,,.,,,,.,.,,,..,,...,...,..,,.,.,,,.,.,.,,,.,
#7KPZYWYOWNUVQRTHDHY5SWLMOXZ3RSX5DNPPSVVJX7VUFGV2MSRS2YWWJKDXWXRLBRD52AAVMFNZE
#\\\|L24FTOLU4H77X7WFZCYW7CEU3SDYXEVZXVL6KNUHUDSC52TYD4T \ / AMOS7 \ YOURUM ::
#\[7]EVAPYNOSLN4VR4C37QERBSFFMUMTRVCEQVTLOMOUICZSU2ZMUCCA 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
