# >:]

# name  = nroot.zenka.is_enabled
# descr = returns true if zenka is enabled \ not disabled in the configuration

my $zenka_name = shift;
die 'nroot.zenka.is_enabled: no zenka name specified'
    if not defined $zenka_name;

my $config_href   = <nroot.start_setup.globals.zenki>;
my $zenka_name_re = <regex.base.usr_str>;

# checking config syntax
foreach my $check_key ( 'enabled', 'disabled' ) {
    if (    exists $config_href->{$check_key}
        and defined $config_href->{$check_key}
        and $config_href->{$check_key} !~ m|^(($zenka_name_re*\ *)+)?\s*$|i )
    {
        <[base.log]>->(
            0,
            "start setup syntax error: zenki.$check_key = '"
                . $config_href->{$check_key}
                . "' <-- expecting valid zenka name[s]"
        );
        die 'critical configuration error';
    }
}

# all zenki are considered enabled in absence of explicit statements ..,
return 1
    if not defined $config_href->{'enabled'}
    and ( not defined $config_href->{'disabled'}
    or $config_href->{'disabled'} =~ m|^\s+$| );

# zenki.diabled takes precedence to zenki.enabled.,
map { return 0 if $ARG eq $zenka_name }
    split( m|\s+|, $config_href->{'disabled'} )
    if defined $config_href->{'disabled'};

return 1 if not defined $config_href->{'enabled'};

# if zenki.enabled is present, all zenki not listed there count as disabled .,
map { return 1 if $ARG eq $zenka_name }
    split( m|\s+|, $config_href->{'enabled'} );
return 0;

#.............................................................................
#O63ETTE544CT3OLHBE3WJZQ5T5TIN2FTPOOELHF3LSLEZX7225TTA47FDZG5EHJB5HECOEJSRHI2O
#::: I6OXX6QECFFZYHJPXZ2QBGJRQW5E2ASMWZJQVXHSOQNOXX2YHKG :::: NAILARA AMOS :::
# :: CHA3BYOMVQW7PSQOLZ7QC5GEJWCVGAUXYNGHZ2TQFQ3SW6WKVGDA :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
