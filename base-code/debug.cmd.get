## >:] ##

# name  = debug.cmd.get
# param = <key>
# descr = return internal 'data' hash value
# note  = todo: implement access control filter and root namespace

my ( $cid, $requested_key ) = ( $ARG[0]->{'session_id'}, $ARG[0]->{'args'} );
my $key_ref;
my ( $key_is_valid, $errmsg )
    = <[base.validate.data_key_syntax]>->($requested_key);
if ( not $key_is_valid ) {
    <[base.logs]>->( 0, '[%d] get: %s', $cid, $errmsg );
    return { 'mode' => qw| false |, 'data' => $errmsg };
}

if ( defined( $key_ref = <[base.resolve_key]>->($requested_key) ) ) {

    if ( ref $key_ref eq qw| SCALAR | ) {    ## returning value ##

        ##  single line value  ##
        return { 'mode' => qw| true |, 'data' => $key_ref->$* }
            if length $key_ref->$* and index( $key_ref->$*, "\n", 0 ) == -1;

        ##  empty string \ containing endline[s]  ##
        return { 'mode' => qw| size |, 'data' => $key_ref->$* };

    }
    $key_ref = $$key_ref    ## consider modifying base.resolve_key ##  [LLL]
        if ref $key_ref eq qw| REF | and ref $$key_ref eq qw| HASH |;

    return {    ##  returning key list as size reply if hashref  ##
        'mode' => qw| size |,
        'data' => join(
            '', map { sprintf "%s\n", $ARG } <[base.sort]>->($key_ref)
        )
        }
        if ref $key_ref eq qw| HASH |;

    return {
        'mode' => qw| false |,
        'data' =>
            sprintf( '%s references not implemented', lc( ref $key_ref ) )
    };
}

return { 'mode' => qw| false |, 'data' => 'requested key not found' };

#,,..,..,,,..,,,.,...,,,.,.,.,,..,.,.,,,.,...,..,,...,...,...,.,,,.,,,.,.,.,.,
#I6HACWTBMSWHEETDKHIJKMUMBYYJU6Q744GA466INKRRV4O74FAMJC53I7YQOPDSSISQBCPPR7OY4
#\\\|D55RAHGHAJT43JBGHTE22PE6BG7FNETP2YPYYYPHAFKQURTQLYB \ / AMOS7 \ YOURUM ::
#\[7]62A6VBQQMO6YORK2EOOKJJCYZHYBC5VUNDKZ6C2DNJLYKCTZVYDI 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
