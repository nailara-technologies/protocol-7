# >:]

# name  = base.cmd.show-access
# param = [user]
# todo  = implement wrapping for long permission strings

my $user = $$call{'args'};

my $usr_re = <regex.base.usr_str>;

return { 'mode' => 'false', 'data' => "'$user' not a valid user name" }
    if defined $user
    and $user ne '*'
    and $user !~ m|^$usr_re$|
    and $user !~ m|^<$usr_re>$|;

my $special_users = {
    map      { $ARG => $data{'system'}->{$ARG} }
        grep { !m|^amos-zenka-user$| }    ## <-- seperate namespace [LLL]
        grep {m|\-user$|} keys %{ $data{'system'} }
};

my @mapped_users;

@mapped_users
    = map {"<$ARG>"} grep { $special_users->{$ARG} eq $user }
    <[base.reverse-sort]>->($special_users)
    if defined $user and $user ne '*';

if ( defined $user ) {
    return {
        'mode' => 'false',
        'data' => "no permissions set-up for '$user'"
        }
        if not defined <access.cmd.usr>->{$user} and not @mapped_users;
    my $max_len   = max map {length} ( $user, @mapped_users );
    my $reply_str = defined <access.cmd.usr>->{'*'} ? '' : ":\n";
    my $map_names = {};
    if ( not defined <access.cmd.usr>->{$user} ) {  ## no custom [$user] rules
        map { $map_names->{$ARG} = "    ::  [ $user <-- $ARG ]" }
            @mapped_users;
    } else {
        $map_names->{$user}
            = @mapped_users
            ? "    ::  [ $user <-- " . join( ', ', @mapped_users ) . ' ]'
            : '';
    }
    if ( $user ne '*' and defined <access.cmd.usr>->{'*'} ) {
        $reply_str .= sprintf ".\n:  %${max_len}s  :    %s%s\n", "'*'",
            join ' ',
            <[base.sort]>->( split m|\s+|, <access.cmd.usr>->{'*'} ),
            '    ::  [  matches all users  ]';
        $reply_str .= ".\n:\n";
    }
    foreach my $map_user (@mapped_users) {
        $reply_str .= sprintf ":  %${max_len}s  :    %s%s\n", $map_user,
            join ' ',
            <[base.sort]>->( split m|\s+|, <access.cmd.usr>->{$map_user} ),
            $map_names->{$map_user};
    }
    if ( defined <access.cmd.usr>->{$user} ) {
        $reply_str .= sprintf( ":  %${max_len}s  :\n", '' ) if @mapped_users;
        $reply_str .= sprintf ":  %${max_len}s  :  %s%s\n", $user, join ' ',
            <[base.sort]>->( split m|\s+|, <access.cmd.usr>->{$user} ),
            $map_names->{$user};
    }

    $reply_str .= ":\n";

    return { 'mode' => 'data', 'data' => $reply_str };

} elsif ( keys( %{<access.cmd.usr>} ) ) {
    my $max_len   = max map {length} keys( %{<access.cmd.usr>} );
    my $reply_str = ":\n";
    foreach my $user ( <[base.reverse-sort]>->(<access.cmd.usr>) ) {
        $reply_str .= sprintf ":\n:  %${max_len}s  :    %s\n", $user,
            join ' ',
            <[base.sort]>->( split( m|\s+|, <access.cmd.usr>->{$user} ) );
    }

    $reply_str .= ":\n:\n";

    return { 'mode' => 'data', 'data' => $reply_str };

} else {
    return {
        'mode' => 'false',
        'data' => 'no access permissions have been set up'
    };
}

#.............................................................................
#4A2KAACUYCIVJ3P64DL2PFW6EK4WVTTJXWMCDZNU5W3XJ6GFUBPAU4JTLAMOWXKN2KVR53XQDRFTA
#::: AQP2PXNL4NSNDADICL6BCZ6LJQXWQMHJW2OBT33QHTYJ6SGFNN6 :::: NAILARA AMOS :::
# :: JHHNAKALUCFD46D7JOJMT5D22RRI4TLM3M6RKDWFVO6N7VNME4DI :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
