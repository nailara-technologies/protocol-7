# >:]

# name  = base.cmd.show-access
# param = [user]
# todo  = implement wrapping for long permission strings

my $user = $$call{'args'};

my $usr_re = <regex.base.usr_str>;

return { 'mode' => 'nak', 'data' => "'$user' not a valid user name" }
    if defined $user
    and $user ne '*'
    and $user !~ m|^$usr_re$|
    and $user !~ m|^<$usr_re>$|;

my $special_users = {
    map      { $ARG => $data{'system'}->{$ARG} }
        grep { !m|^amos-zenka-user$| }    ## <-- seperate namespace [LLL]
        grep {m|\-user$|} keys %{ $data{'system'} }
};

my @mapped_users;

@mapped_users = map {"<$ARG>"} grep { $special_users->{$ARG} eq $user }
    sort { length $b <=> length $a }
    reverse sort keys %{$special_users}
    if defined $user and $user ne '*';

if ( defined $user ) {
    return { 'mode' => 'nak', 'data' => "no permissions set-up for '$user'" }
        if not defined <access.cmd.usr>->{$user} and not @mapped_users;
    my $max_len   = max map {length} ( $user, @mapped_users );
    my $reply_str = defined <access.cmd.usr>->{'*'} ? '' : ":\n";
    my $map_names = {};
    if ( not defined <access.cmd.usr>->{$user} ) {  ## no custom [$user] rules
        map { $map_names->{$ARG} = "    ::  [ $user <-- $ARG ]" }
            @mapped_users;
    } else {
        $map_names->{$user}
            = @mapped_users
            ? "    ::  [ $user <-- " . join( ', ', @mapped_users ) . ' ]'
            : '';
    }
    if ( $user ne '*' and defined <access.cmd.usr>->{'*'} ) {
        $reply_str .= sprintf ".\n:  %${max_len}s  :    %s%s\n", "'*'",
            <access.cmd.usr>->{'*'}, '    ::  [  matches all users  ]';
        $reply_str .= ".\n:\n";
    }
    foreach my $map_user (@mapped_users) {
        $reply_str .= sprintf ":  %${max_len}s  :    %s%s\n", $map_user,
            <access.cmd.usr>->{$map_user}, $map_names->{$map_user};
    }
    if ( defined <access.cmd.usr>->{$user} ) {
        $reply_str .= sprintf( ":  %${max_len}s  :\n", '' ) if @mapped_users;
        $reply_str .= sprintf ":  %${max_len}s  :  %s%s\n", $user,
            <access.cmd.usr>->{$user}, $map_names->{$user};
    }

    $reply_str .= ":\n";

    return { 'mode' => 'data', 'data' => $reply_str };

} elsif ( keys( %{<access.cmd.usr>} ) ) {
    my $max_len   = max map {length} keys( %{<access.cmd.usr>} );
    my $reply_str = ":\n";
    foreach my $user (
        sort { length $b <=> length $a }
        reverse sort keys( %{<access.cmd.usr>} )
    ) {
        $reply_str .= sprintf ":\n:  %${max_len}s  :    %s\n", $user,
            <access.cmd.usr>->{$user};
    }

    $reply_str .= ":\n:\n";

    return { 'mode' => 'data', 'data' => $reply_str };

} else {
    return {
        'mode' => 'nak',
        'data' => 'no access permissions have been set up'
    };
}

#.............................................................................
#ICX6CFK5D2DXFVN5Y7RI7FSRJ6WLMYXL3JDB2CEW5TBATFMZEFUICLCOOG43GBTLJ6UEBBQJFU2IC
#::: ASZCKBL3HJ4XTVNXWN43HJLTTYWSENDLRZ263U4VA6SLD6AON7T :::: NAILARA AMOS :::
# :: AS5RU6G5WRLQD7AMG3WTTS4LZVUW56FM6GTAKZBFVQY5OUO7KUDA :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
