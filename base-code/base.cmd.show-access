# >:]

# name  = base.cmd.show-access
# param = [user]

my $user = $$call{'args'};

my $usr_re = <regex.base.usr_str>;

return { 'mode' => 'false', 'data' => "'$user' not a valid user name" }
    if defined $user
    and $user ne '*'
    and $user !~ m|^$usr_re$|
    and $user !~ m|^<$usr_re>$|;

my $special_users = {
    map      { $ARG => $data{'system'}->{$ARG} }
        grep { !m|^amos-zenka-user$| }    ## <-- seperate namespace [LLL]
        grep {m|\-user$|} keys %{ $data{'system'} }
};

my @mapped_users;
my $wrap_len = 57;

@mapped_users
    = map {"<$ARG>"} grep { $special_users->{$ARG} eq $user }
    <[base.reverse-sort]>->($special_users)
    if defined $user and $user ne '*';

if ( defined $user ) {
    return {
        'mode' => 'false',
        'data' => "no permissions set-up for '$user'"
        }
        if not defined <access.cmd.usr>->{$user} and not @mapped_users;
    my $max_len   = max map {length} ( $user, @mapped_users );
    my $w_prefix  = ':' . ' ' x ( $max_len + 7 );
    my $reply_str = defined <access.cmd.usr>->{'*'} ? '' : ":\n";
    my $map_names = {};
    if ( not defined <access.cmd.usr>->{$user} ) {  ## no custom [$user] rules
        map { $map_names->{$ARG} = "    ::  [ $user <-- $ARG ]" }
            @mapped_users;
    } else {
        $map_names->{$user}
            = @mapped_users
            ? "    ::  [ $user <-- " . join( ', ', @mapped_users ) . ' ]'
            : '';
    }
    if ( $user ne '*' and defined <access.cmd.usr>->{'*'} ) {
        $reply_str .= sprintf ".\n:  %${max_len}s  :  %s%s\n", "'*'",
            <[base.wrap_text]>->(
            $w_prefix,
            $wrap_len,
            <[base.reverse-sort]>->( split m|\s+|, <access.cmd.usr>->{'*'} )
            ),
            '    ::  [  matches all users  ]';
        $reply_str .= ".\n:\n";
    }
    foreach my $map_user (@mapped_users) {

        $reply_str .= sprintf ":  %${max_len}s  :  %s%s\n", $map_user,
            <[base.wrap_text]>->(
            $w_prefix,
            $wrap_len,
            <[base.reverse-sort]>->(
                split m|\s+|, <access.cmd.usr>->{$map_user}
            )
            ),
            $map_names->{$map_user};
    }
    if ( defined <access.cmd.usr>->{$user} ) {
        $reply_str .= sprintf( ":  %${max_len}s  :\n", '' ) if @mapped_users;
        $reply_str .= sprintf  ":  %${max_len}s  :  %s%s\n", $user,
            <[base.wrap_text]>->(
            $w_prefix,
            $wrap_len,
            <[base.reverse-sort]>->(
                split m|\s+|, <access.cmd.usr>->{$user}
            )
            ),
            $map_names->{$user};
    }

    $reply_str .= ":\n";

    return { 'mode' => 'data', 'data' => $reply_str };

} elsif ( keys( %{<access.cmd.usr>} ) ) {
    my $max_len   = max map {length} keys( %{<access.cmd.usr>} );
    my $w_prefix  = ':' . ' ' x ( $max_len + 7 );
    my $reply_str = ":\n";
    foreach my $user ( <[base.reverse-sort]>->(<access.cmd.usr>) ) {
        $reply_str .= sprintf ":\n:  %${max_len}s  :  %s\n", $user,
            <[base.wrap_text]>->(
            $w_prefix, $wrap_len,
            , <[base.sort]>->( split( m|\s+|, <access.cmd.usr>->{$user} ) )
            );
    }

    $reply_str .= ":\n:\n";

    return { 'mode' => 'data', 'data' => $reply_str };

} else {
    return {
        'mode' => 'false',
        'data' => 'no access permissions have been set up'
    };
}

#.............................................................................
#MUZX27SAC6E7UIQKBDGSAWC5BH2KJBGTBZSVUXOTWNFT6NWMBSDKR5MFQEVG5GTQGLBHTWGSIEQB2
#::: 63Z32FSNBAPA2J3EI2OU2Z645EAI2RGBNKPTPB3AVIDERD3LXDO :::: NAILARA AMOS :::
# :: YSJ7GOXNGRRVTFHKLO3KJDGOP3EPPTC2SWHFFOG63IT3YGA76KCA :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
