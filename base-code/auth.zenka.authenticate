# >:]

# name  = auth.zenka.authenticate
# descr = authenticate to cube in zenka mode
# note  : zenka name can now contain subnames

my ( $backend_socket, $zenka, $key_str ) = @ARG;

my $protocol_messages  = <protocol.protocol-7.connect>;
my $protocol_banner    = $protocol_messages->{'banner'};
my $proto_msg_timeout  = $protocol_messages->{'timeout'};
my $protocol_error_msg = $protocol_messages->{'protocol_error'};

my $link_mode_str = qw| zenka |;
$link_mode_str = lc($LAST_PAREN_MATCH)
    if ref($backend_socket) =~ m|^IO::Socket::(\S+)$|;

if ( defined $key_str
    or %KEYS
    and exists $KEYS{'zenka'}{'session_key'}
    and $KEYS{'zenka'}{'session_key'} ne '' ) {
    $key_str //= $KEYS{'zenka'}{'session_key'};
    my $banner_string;
    my ( $m_len, $read_len )
        = minmax( map {length} $protocol_banner, $proto_msg_timeout );
    my $bytes_read
        = <[base.s_read]>->( $backend_socket, \$banner_string, $read_len )
        // 0;
    if ( $bytes_read > 0 ) {
        if ( $banner_string eq $protocol_banner ) {
            <[base.log]>->( 2, '[*] protocol seven banner detected.,' );
        } elsif ( $banner_string eq $proto_msg_timeout ) {
            <[base.log]>->( 2, '[#] authentication timeout :|' );
            return undef;
        } else {
            <[base.logs]>->(
                0,
                '[#] protocol mismatch [ no valid connection banner \ %s ]',
                $link_mode_str
            );
            return undef;
        }
    } else {
        <[base.log]>->(
            0, 'auth.zenka : [#] network error [ nothing read on %s ]',
            $link_mode_str
        );
        return undef;
    }

    <[net.out]>->( $backend_socket, "select zenka\n" );

    my $answer = readline($backend_socket);
    chomp($answer) if defined $answer;

    if ( not defined $answer ) {
        <[base.log]>->( 0, '[X] connection lost :|' ) and return undef;
    } elsif ( $answer ne 'TRUE continue' ) {
        <[base.log]>->( 0, '[#] protocol mismatch >:[' );
        return undef;
    }

    <[base.logs]>->(
        2,      "[<] authenticating as '%s'., [%s]",
        $zenka, $link_mode_str
    );
    <[net.out]>->( $backend_socket, "$zenka $key_str\n" );

    if ( exists $KEYS{'zenka'}{'session_key'} ) {    ## secure key erasure ##
        my $rand_len = length( $KEYS{'zenka'}{'session_key'} );
        substr( $KEYS{'zenka'}{'session_key'},
            0, $rand_len, <[base.prng.characters]>->($rand_len) );
        $KEYS{'zenka'}{'session_key'}
            .= <[base.prng.characters]>->( 8 + int( rand(9) ) );
        delete $KEYS{'zenka'}{'session_key'};
    }

    return <[auth.zenka.process_auth_reply]>->($backend_socket);

} else {
    <[base.log]>
        ->( 0, 'session_key not set, authentication not possible..,' );
    return undef;
}

#.............................................................................
#U4JIGZOSQ645PJZS6OXG76KPXENFLINWH75QYOZSN4MSU6ACTXE4TSERMZ3TLHF4OERNXELST2M4A
#::: QO3M6Q4IRNUC4M4J6RKIFW2URYUB5IOZUXS6RWXL62QX5C5TX3L :::: NAILARA AMOS :::
# :: S7HXJ4RBCCR4D7DH5666ILPMCM24ZY5XYH5IZ7QO3XIPSIT5K4AI :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
