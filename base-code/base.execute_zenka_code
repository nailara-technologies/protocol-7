## >:] ##

# name  = base.execute_zenka_code
# descr = execute protocol-7 zenka code

<[base.log]>->( 2, ': executing protocol-7 zenka code .,' );

use vars qw| $ZENKA_CFG_NAME |;
my $code_name
    = defined $ZENKA_CFG_NAME
    ? sprintf( "cfg '%s'", $ZENKA_CFG_NAME )
    : qw| zenka-code |;
$code_name = sprintf qw| %s-zenka |, <system.zenka.name>
    if lc($code_name) eq qw| zenka |;
undef $ZENKA_CFG_NAME;

## storing last return value ##
<zenka_cfg.ret_val> = undef;

my $use_aliases        = 1;    ## <-- resolve config command aliases ? ##
my $noerr              = 5;
my $code_line_num      = 0;
my $event_loop_present = @ARG ~~ m|\$code\{'event.loop'}|;
foreach my $code_line (@ARG) {
    $code_line_num++;
    my $error_exit = 0;

    ## checking \ resolving command routine aliases ## [ cfg_cmd.<name> ]
    #
    $code_line =~ s|(*plb:\$code\{')([^']+)(*pla:'\})|
            <[base.check_cfg_cmd_alias]>->($1)|ge;
    ###

    ## change warn handler to report zenka config line numbers ##
    local $SIG{'__WARN__'} = sub {
        ( my $err_str = $ARG[0] ) =~ s| ?<\{N?C\d?}>||g;
        if ( index( $err_str, qw| eval |, 0 ) > -1 ) {
            if ( index( $err_str, "[ '", 0 ) == -1 ) {
                $err_str =~ s| at .+line.+$||g;
            } else {
                $err_str =~ s| at .+line.+$|' \]|g;
            }
        }
        <[base.logs]>->(    ## requires statement to line number map ##
            0,          'runtime-error : %s [ statement %03d ]',
            $code_name, $code_line_num
        );
        <[base.logs]>->(
            0, ": '%s'", scalar <[base.format_error]>->( $err_str, -1 )
        );
        $error_exit = 1;
        }
        if $event_loop_present
        ## use regular base.sig_warn handler in main event loop ##
        and index( $code_line, '$code{\'event.loop\'}', 0 ) == -1;

    ##  evaluate zenka-code \ config line  ##
    <zenka_cfg.ret_val> = eval($code_line);

    if ($error_exit) {    ## todo : adapt parser from below ##
        return warn 'stopped processing <{C1}>';
        return $noerr = 0;
    }

    if ( length $EVAL_ERROR ) {
        if ( $EVAL_ERROR =~ m|^Can't use string \(""\) as a subroutine ref| )
        {
            my $code_line_copy = $code_line;
            while ( $code_line_copy =~ s|(\$code\{'([^']*)'\})|| ) {
                my ( $sub_call, $sub_name )
                    = ( ${^CAPTURE}[0], ${^CAPTURE}[1] // '' );
                next if length $sub_name and defined $code{$sub_name};
                <[base.logs]>->(
                    0,         "unknown subroutine '%s' called [ %s ]",
                    $sub_name, $sub_call
                );
                $noerr = 0 if $noerr;
            }
        }
        if ($noerr) {
            $EVAL_ERROR =~ s| at ([^\s]+) line (\d+).+\n||;
            <base.eval_error.name> = ${^CAPTURE}[0];
            <base.eval_error.line> = ${^CAPTURE}[1];
            <[base.s_warn]>->(
                "no success on eval '%s' [ '%s' ] <{C3}>",
                $code_line, scalar <[base.format_error]>->( $EVAL_ERROR, -1 )
            );
        }
        $noerr = 0 if $noerr;
    }
}

return $noerr;    ## return zenka cfg execution status ##

#,,,,,.,.,,..,...,.,,,..,,,.,,...,,.,,,..,..,,..,,...,..,,..,,...,.,.,.,.,..,,
#KUH4HMHZUPLYJ43G45J5T6UIOKLFWB2KRQHOJK7FKZQP32Y4AGTML6YUDNESHUP4G4TEEZCPM6FXK
#\\\|XID7P4J7ZGOQQBA4QM5DE4NGQTGGU5ETW7ROTIJFQ2ZICJ7A7MH \ / AMOS7 \ YOURUM ::
#\[7]VGVHQ7NRGSALH5O7SXYPQ5J7AHGZRICPDO2KVUOAASF3K6RMDCCQ 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
