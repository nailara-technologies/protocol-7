## >:] ##

# name  = base.parser.config
# descr = returns perl code from parsed zenka config
# [LLL] = needs more cleanup \ extract parser code.,

<[base.log]>->( 2, ': parsing zenka startup code .,' );
<base.parser.config.errors> //= 0;
my $parse_aref = shift // [];
my $var_prefix = shift // '$data';
my $entries    = 0;
my @init_code  = ();

my $last_line = '';

foreach my $_line ( @{$parse_aref} ) {
    my $conf_line = $_line;    #  <-- leaving original intact.,
    <base.config_parser.cfg_descr> = ${^CAPTURE}[0]
        if $conf_line =~ m|\.:\[ +([^:]+) +\]:\.|
        and defined <base.config_parser.cfg_type>
        and defined <base.config_parser.cfg_name>
        and ( !length(<base.config_parser.cfg_descr>)
        or <base.config_parser.cfg_descr> eq '<STDIN>' );
    $conf_line =~ s{^ +| *(#.*|\.:.*)$|[\r\n\t]+}{}g;
    next if $conf_line eq '';
    if ( $conf_line =~ s|\\ *$|| ) {
        $last_line .= $conf_line;
        next;
    } elsif ( length($last_line) ) {
        $conf_line =~ s|^[ \t]+||;
        $conf_line = "$last_line$conf_line";
        $last_line = '';
    }
    $conf_line =~ s|(^[^=]+=)[ \t]+|$1|;
    $conf_line =~ s|\$([\{\w])|\\\$$1|g;    ## <-- disallow perl variables ##

    # <<keyword>> requests corresponding data value from network
    # warning: <<<variable>>> will not work in current implementation.,
    $conf_line =~ s|<<([\w_-]+(\.[\w_-]+)*)>>|\[net.get:"$1"]|g;

    my ( $found, $rec_depth ) = ( 1, 0 );
    while ($found) {
        $found = 0;
        if ( $conf_line =~ m{(?<![\w\d])\[([^\[|^\]]+)\]} )
        {    # [LLL] check '|'
            $found = 1;
            my ( $cmd_name, $param ) = ( ${^CAPTURE}[0], '' );
            my $out = '';
            if ( $cmd_name =~ s|([^:]+):(.+)$|$1| ) {
                $param = ${^CAPTURE}[1];
                ## $param = "\"$2\"";
                ## $param =~ s|,|","|g;
            }

            while ( $param =~ m|(?<!')<([\w_-]+(\.[\w_-]+)+)>(?!')| ) {
                my $conf_key  = ${^CAPTURE}[0];
                my $eval_code = $conf_key;
                $eval_code =~ s|[ \t\n]+||g;
                $eval_code =~ s|\.|'}{'|g;
                $eval_code = "${var_prefix}{'$eval_code'}";
                $eval_code =~ s|\.|\\.|;
                $param     =~ s|(?<!')<$conf_key>(?!')|$eval_code|g;
            }

            ## [code_name:param] shortcut patterns ##

            if (    $cmd_name !~ m|\.|
                and defined $code{ 'base.' . $cmd_name }
                and defined &{ $code{ 'base.' . $cmd_name } } ) {
                $cmd_name = "base.$cmd_name";
            } elsif ( $cmd_name =~ m|^root\.|
                and defined $code{ 'base.' . $cmd_name }
                and defined &{ $code{ 'base.' . $cmd_name } } ) {
                $cmd_name = "base.$cmd_name";
            } elsif ( $cmd_name !~ m|\.|
                and defined $code{ 'base.cmd.' . $cmd_name }
                and defined &{ $code{ 'base.cmd.' . $cmd_name } } ) {
                $cmd_name = "base.cmd.$cmd_name";
            } elsif ( $cmd_name !~ m|\.| ) {
                <[base.log]>->(
                    1, "called not defined command '$cmd_name'..,"
                );
            }
            $conf_line =~ s{(?<![\w\d])\[([^\[|^\]]+)\]}
                           {\$code{'$cmd_name'}->($param)};

            while ( $conf_line =~ m,^[ \t]*([^\$|^ |^\t]+)[ \t]*=, ) {
                my $new_conf_line = $LAST_PAREN_MATCH;
                $new_conf_line =~ s|[ \t\n]||g;
                $new_conf_line = "${var_prefix}{\'$new_conf_line\'}";
                $new_conf_line =~ s|\.|'}{'|g;
                $conf_line     =~ s{^[ \t]*([^\$|^ |^\t]+)[ \t]*=}
                                   {$new_conf_line = };
            }
            $rec_depth++;
        }
    }
    if ($rec_depth) {
        push( @init_code, $conf_line );
        $conf_line = '';
        $found     = 0;
    } else {
        my ( $_name, $_value ) = split( qw| = |, $conf_line, 2 );
        if ( defined $_value ) {
            $_name  =~ s|[ \t\n]||g;
            $_value =~ s|'||g;
            my $conf_hash = join( '', $var_prefix, "{\'$_name\'}" );
            $conf_hash =~ s|\.|'}{'|g;

            while ( $_value =~ m|(?<!')\<([\w_-]+(\.[\w_-]+)+)>(?!')| ) {
                my $conf_key  = ${^CAPTURE}[0];
                my $eval_code = $conf_key;
                $eval_code =~ s|[ \t\n]+||g;
                $eval_code =~ s|\.|'}{'|g;
                $eval_code = "${var_prefix}{'$eval_code'}";
                $eval_code =~ s|\.|\\.|;
                $_value    =~ s|(?<!')<$conf_key>(?!')|'.$eval_code.'|g;
            }

            my $cmd = join( qw| = |, $conf_hash, "'$_value'" );

            $cmd =~ s{''\.|\.''}{}g;
            push( @init_code, $cmd );

            if ($EVAL_ERROR) {
                <base.parser.config.errors>++;
                <[base.log]>->(
                    0,
                    "<< error during config parsing : ['$cmd'] \l$OS_ERROR >>"
                );
                undef $EVAL_ERROR;
            } else {
                $entries++;
            }
        }
    }
}

if ( defined $data{'system'}{'verbosity'}{'console'}
    and $data{'system'}{'verbosity'}{'console'} > 1 ) {
    foreach my $code (@init_code) { <[base.log]>->( 1, ": : $code" ) }
}

if (    my $cfg_type = <base.config_parser.cfg_type>
    and my $cfg_name = <base.config_parser.cfg_name> ) {
    <system.descr.config>->{$cfg_type}->{$cfg_name}
        = <base.config_parser.cfg_descr> // '';
}
delete <base.config_parser>;

return @init_code;

#,,.,,.,,,,,,,,.,,,,,,.,.,,,,,...,,.,,...,,.,,..,,...,.,.,,,.,...,,..,...,...,
#62FNCSF5HQN5DI2BJ4GG2H2FUQLYLG7MNGPZ4BYBZ2W53IXCS7ZVKYUOH23GGXEO3STQTL4MRN2GA
#\\\|H7DF4JCCUFVAUUXB6LHS45MHWWOYMHQWMFKQAL3ONDRKXGMNK6A \ / AMOS7 \ YOURUM ::
#\[7]X6D7S4KX2KLKXDLLBZPMBRQ7MJP6JXBVVPX6JZE2MHDRCQAU4YAY 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
