# >:]

# name  = base.handler.child_output.simple
# descr = reads output from child process, terminates zenka if it dies

<v7.patterns.zenka_output> //= {};

my $event     = shift->w;
my $read_fh   = $event->fd;
my $child     = $event->data;
my $bin       = $child->{'bin'};
my $pid       = $child->{'pid'};
my $whitelist = $child->{'log_whitelist'}     || [];
my $xpatterns = $child->{'callback_patterns'} || {};
<base.child_exit>->{$pid}->{'keep-zenka'} // 0;

<child.output_buffer> //= '';

my $read_bytes = <[base.s_read]>->(
    $read_fh, \$data{'child'}{'output_buffer'},
    4096,     length(<child.output_buffer>)
);
if ( not defined $read_bytes or $read_bytes == 0 )
{    # [ filehandle exception ]
    $event->cancel;
    close($read_fh);
    <[base.log]>->( 2, "$bin-child [PID:$pid] output filehandle closed." );
    kill( 9, $pid );    # making sure.,
    my $log_level    = 0;
    my $keep_running = 0;
    if ( <base.child_exit>->{$pid}->{'keep-zenka'} ) {
        $log_level    = 2;
        $keep_running = 1;
    }
    <[base.log]>->( $log_level, ": $bin-child shut down." );

    return 0 if $keep_running;    ##  <-- opc return value ##

    <[base.log]>->(
        2, ": : shutting down " . <system.zenka.name> . "-zenka."
    );
    $code{<base.child_exit.callback>}->($pid)
        if defined <base.child_exit.callback>
        and defined $code{<base.child_exit.callback>};
    exit(2);
}

while ( <child.output_buffer> =~ s|^([^\n]*)\n||s ) {
    my $output_line = $1;
    $output_line =~ s|\r||sg;
    next if !length($output_line);
    my $log_level = 0;
    for my $pattern ( @{$whitelist} ) {
        if ( $output_line =~ m|$pattern|i ) {
            $log_level = 2;
            last;
        }
    }

    ## [ translating registered error message strings ] ###
    map { $output_line = $ARG->($output_line) if ref($ARG) eq 'CODE' }
        @{<base.message_parsers.child_output>}
        if defined <base.message_parsers.child_output>
        and ref(<base.message_parsers.child_output>) eq 'ARRAY';
    ##

    <[base.log]>->( $log_level, "< $bin > " . lc($output_line) )
        if length $output_line;

    ### custom callbacks ##
    for my $pattern ( keys %{$xpatterns} ) {
        if ( $output_line =~ m|$pattern|i ) {
            my $c_name = $xpatterns->{$pattern};
            next if not defined $code{$c_name};
            <[base.log]>->( 2, "calling opc '$c_name'" );
            my $opc_return_code = $code{$c_name}->($MATCH);
            <base.child_exit>->{$pid}->{'keep-zenka'} = $opc_return_code;
            last;
        }
    }
}

#.............................................................................
#OUCYP24G7YJPFV3IHDP3P6WQJIDFUSOTAKAUVD3CVWGWIHZ6PHSC7LOT6265HVHZNTU4UYEYBOOIE
#::: RIKSEFYAYKYQ644KFJTT7VO663DO3QAZUYO72W5VVWYGVIOXRLN :::: NAILARA AMOS :::
# :: SXQWV4N3FWXEF2ZRP6BDBMHOO2IU6G67T4VBWH62PV4PJVOKH2CA :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
