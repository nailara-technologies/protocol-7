# >:]

# name  = chk-sum.elf.inline-c.compile

my $r_lvl = shift // 2;    ## <-- success report log level ## + < user > ?

my $base_path = qw| /var/tmp/.inline-elf |;

## create user registry \ configuration variable [ to decide with ].., [LLL]
my $compile_user = <system.X-11-user> // <system.amos-zenka-user>;
$compile_user = getpwuid($EUID) if $EUID > 0;    ## current user[id] ##

## actually compile as $compile_user [ fork() ] .., [LLL]

return warn '<compile_user> not defined [ required ] <{C1}>'
    if not length( $compile_user // '' );

our $inline_directory = join( qw| . |, $base_path, $compile_user );

if ( not -r $inline_directory and defined &inline_elf ) {
    my $l_lvl   = $r_lvl > 0 ? $r_lvl - 1 : 0;
    my $err_usr = getpwuid($UID);
    <[base.log]>->(
        $l_lvl, ":. aborting inline-elf reload [ directory not readable ]"
    );
    <[base.logs]>->(
        $l_lvl,   ": U : %s : D : %s",
        $err_usr, $inline_directory
    );
    return 1;    ## inline_elf() still loaded \ defined ##
}

eval {   #[ INIT \ C-CODE ]###################################################
    if ( not -d $inline_directory ) {    ## use file.make_path ## [LLL]
        mkdir($inline_directory)
            or die ":\n: \l$OS_ERROR : $inline_directory\n:\n";
        <[base.log]>->( 2, ': compiling inline_elf() ..,' );

    } else {
        <[base.log]>->( 2, ': loading inline_elf() library ..,' );
    }
};

my $elf_code = <[chk-sum.elf.inline.elf-code]>;

### [RE]COMPILING \ LOADING .., ###
eval {
    no warnings;     # <-- 'redefine' ?
    Inline->bind( 'C' => $elf_code, 'directory' => $inline_directory );
    use warnings;    # <-- 'redefine' ?
};

## removing ,./lib/ from @INC again ., ##
shift @INC if $INC[0] =~ m|^$inline_directory/lib|;

warn 'inline-c elf compilation not successful [ eval ] <{C1}>'
    . <[base.format_error]>->($EVAL_ERROR) and return 0
    if $EVAL_ERROR;    ## testing further below ##

my $chown_from_user = getpwuid($UID);
if ($UID == 0          ## only 'root' user can change file ownership ##
    and defined $chown_from_user
    and defined $compile_user
    and defined $inline_directory
    and -d $inline_directory
    and -w $inline_directory
) {
    <[base.logs]>->( 2, ': changing ownership to %s .,', $compile_user );
    <[base.logs]>->( 2, ':. %s',                         $inline_directory );
    <[file.chown_all]>->(
        $chown_from_user, $compile_user, $inline_directory, 3 ## <-- log-level
    );
} elsif ( $UID == 0 ) {
    <[base.logs]>->(
        0,
        "cannot chown inline directory ['%s'] < '%s' --> '%s' >",
        $inline_directory // '',
        $chown_from_user  // '',
        $compile_user
    );
}

warn 'inline-c elf compilation not successful [ inline_elf() ] <{C1}>'
    and return 0    ## cleaup_path
    if not defined &inline_elf;

my $test_string = <[base.ntime.b32]>;

<[base.logs]>->( 2, ': testing AMOS-13-ELF with elf-hash settings ..,' );
<[base.logs]>->( 2, ': : elf test string : %s', $test_string );

my $mod_elf_sum   = sprintf qw| %09d |, Digest::Elf::elf($test_string);
my $inline_elfsum = sprintf qw| %09d |,    ##  base elf-hash settings  ##
    <[chk-sum.elf.inline]>->( \$test_string, 0, 4, 24, 0XF0000000 ); ##[!AMOS]

##  add test with AMOS-13 settings  ##   [ LLL ]

warn sprintf( 'inline_elf test not successful [ %s != %s ] <{C1}>',
    $inline_elfsum, $mod_elf_sum )
    and return 0
    if $inline_elfsum ne $mod_elf_sum;

<[base.log]>->( $r_lvl, ': inline-elf available [ successful ] =)' );

return 1;    ## success ##

#.............................................................................
#MVKHOASUHKA367ARZB4UQDWHJTQHF6BI4B7ZL7QSWXOME7PPFM4ZOGDJ3BPFG6WZICTPSOI4PMW76
#::: BLJ6WLW24GLOGWNJWDY2SCD34PDPDUVGL6OSW4LKNXCU63KN765 :::: NAILARA AMOS :::
# :: D6OFUKJZF33H7Q3PNR7OUZ44GRSLIPFW3ZNGDYMBOI5TKB7RQWBY :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
