# >:]

# name  = nroot.zenka.cmd.report-temp-path
# param = <tmp-path>
# descr = register temporary path[s] for later cleanup

( my $zenka, my $zenka_sid, my $tmppath ) = split( m| |, $$call{'args'}, 3 );

my $valid_chars_re = qr|[0-9a-zA-Z\-_\./]+|;
$zenka =~ s|^.*\.||;    # <-- node portion

my $err_reason;
$err_reason = 'expected zenka sid from cube [ misconfigured ]'
    if not defined $zenka_sid or $zenka_sid !~ m|^\d+$|;
warn sprintf( "[%d] << $err_reason >>", $$call{'session_id'} )
    if defined $err_reason;
$err_reason = 'expected path parameter' if !length( $tmppath // '' );
$err_reason = 'absolute path expected'
    if not defined $err_reason and $tmppath !~ m|^/|;

( my $inv_chars = $tmppath ) =~ s|$valid_chars_re||g;
$err_reason = "temp dir path contains invalid characters ['$inv_chars']"
    if not defined $err_reason and $tmppath !~ m|^$valid_chars_re$|;

$tmppath    = abs_path($tmppath) if not defined $err_reason;
$err_reason = 'specified directory path does not exist'
    if not defined $err_reason
    and ( not defined $tmppath or !-d $tmppath );

my $zenka_instance;
if ( not defined $err_reason ) {
    foreach my $instance_id ( keys( %{<nroot.zenka.instance>} ) ) {
        my $instance = <nroot.zenka.instance>->{$instance_id};
        $zenka_instance = $instance_id
            and last
            if defined $instance->{'cube_sid'}
            and $instance->{'cube_sid'} == $zenka_sid;
    }
}
$err_reason = "no instance matches cube-sid $zenka_sid"
    if not defined $err_reason and not defined $zenka_instance;

my $instance;
my %has_uid;
my %has_gid;
if ( not defined $err_reason ) {
    $instance = <nroot.zenka.instance>->{$zenka_instance};
    my $p_pid = $instance->{'process'}{'id'};

    <nroot.process.instance_cache>->{$p_pid} = $zenka_instance;

    my @children = @{ <[nroot.sub-process.get_children]>->($p_pid) };
    my @i_pids   = @children ? ( $p_pid, @children ) : ($p_pid);
    map {
        ( my $p_uid, my $p_gid ) = <[nroot.sub-process.get_uid]>->($ARG);
        push( @{ $has_uid{$p_uid} }, $ARG );
        push( @{ $has_gid{$p_gid} }, $ARG ) if defined $p_gid
    } @i_pids;
    $err_reason = "could not map instance to user id" if !keys %has_uid;
}

my $uid_match = 0;    # LLL: also check gids.,
if ( not defined $err_reason ) {
    my @match_type;
    my $stat_ref = File::stat::stat($tmppath);
    my $stat_uid = $stat_ref->uid;
    my $stat_gid = $stat_ref->gid;
    my %match_pid;
    push( @match_type, 'user' )
        if exists $has_uid{$stat_uid}
        and $stat_ref->cando( S_IWUSR(), $stat_uid )
        ;    # <-- user write access.,
    push( @match_type, 'group' )
        if defined $stat_gid
        and exists $has_gid{$stat_gid}
        and $stat_ref->cando( S_IWGRP(), $stat_gid ); # <-- group write access
    if (@match_type) {
        $instance->{'stat_uid'} = $stat_uid;
        $instance->{'stat_gid'} = $stat_gid;
        <[base.log]>->(
            2,
            sprintf( "<report-temp-path> %s write access for '$zenka'",
                join( ' and ', @match_type ) )
        );
    } else {
        $err_reason = 'path ownsership does not match process owner[s]';
    }
}

<[base.log]>->( 0, "<<$zenka>> [$zenka_sid] <report-temp-path> $err_reason" )
    if defined $err_reason;
return { 'mode' => 'false', 'data' => $err_reason } if defined $err_reason;

push(
    @{ <nroot.zenka.instance>->{$zenka_instance}->{'temp-path'} },
    $tmppath
);

my $str_len = 52 - length(<system.node.name>);

my $tmppath_str = <[base.parser.ellipse_center]>->( $tmppath, $str_len );
<[base.log]>->( 1, "[$zenka_instance] <pth> $tmppath_str" );

return { 'mode' => 'true', 'data' => "registered '$tmppath'" };

#.............................................................................
#C3VB4GW7EEVAL4LWGG6MWM5UO2GKAPDPNNOAGD4G2YJS2U44QUEDYHWQO7ASPBPFDHFALD7MK32QS
#::: DGSGVY4RWZWMYNYFMAQLBA5XFNOTKQW2HNOSN3NTMB5I56AVDI6 :::: NAILARA AMOS :::
# :: BTHGAN6G4BPNLT6YGYOK2LMDJHQESTPCRD4FQ4O2SIOEP6CCFQDA :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
