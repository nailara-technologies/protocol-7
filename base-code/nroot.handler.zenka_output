# >:]

# name  = nroot.handler.zenka_output
# descr = reads zenka console output and triggers commands on matching patterns

<nroot.patterns.zenka_output> //= {};
<nroot.patterns.log_matches>  //= 0;

my $event       = shift->w;
my $read_fh     = $event->fd;
my $instance_id = $event->data;
if ( not exists <nroot.zenka.instance>->{$instance_id} ) {
    $event->cancel;
    close($read_fh);
    <[base.log]>->( 2, "instance $instance_id : output pipe closed." );
    return;
}
my $zenka_instance = <nroot.zenka.instance>->{$instance_id};
my $zenka_id       = $zenka_instance->{'zenka_id'};
my $zenka_name     = <nroot.zenka.setup>->{$zenka_id}->{'name'};

<[base.log]>->( 2, "instance $instance_id : zenka name not defined." )
    and return
    if not defined $zenka_name;

$zenka_instance->{'output_buffer'} //= '';

my $read_bytes = <[base.s_read]>->(
    $read_fh, \$zenka_instance->{'output_buffer'},
    4096,     length( $zenka_instance->{'output_buffer'} )
);
if ( not defined $read_bytes or $read_bytes == 0 )
{    # [ filehandle exception ]
    $event->cancel;
    my $process = $zenka_instance->{'process'};
    close($read_fh);
    my $pid = $process->{'id'};
    <[base.log]>->( 2, "[PID:$pid] output pipe closed." );

    my $was_ondemand = 0;
    if ( defined <nroot.ondemand_zenki> ) {
        map { $was_ondemand = 1 if $ARG eq $zenka_name }
            @{<nroot.ondemand_zenki>};
    }

    undef $zenka_instance->{'output_buffer'};

    #    if (
    #        (      not exists <zenka.instance.shutdown>
    #            or not exists <zenka.instance.shutdown>->{$instance_id}
    #        )
    #        and $zenka_instance->{'status'} ne 'restart'
    #        and $zenka_instance->{'status'} ne 'starting'
    #        ) {
    #        if ( $zenka_instance->{'status'} eq 'online' ) {
    #            if ($was_ondemand) {
    #                <[zenka.change_status]>->( $instance_id, 'offline' );
    #            }
    #        } else {
    #            <[zenka.change_status]>->( $instance_id, 'error' );
    #        }
    #    }
    return;
}

my @matched_names;
my $patterns_output = <nroot.patterns.zenka_output>;
foreach my $a_name ( keys %{$patterns_output} ) {

    if ( $a_name =~ m|\*| ) {    # wildcard match
        my $inverse_match = 0;
        my $name_pattern  = $a_name;
        $inverse_match = 1 if $name_pattern =~ s|^\!||;
        $name_pattern =~ s|[^a-zA-Z0-9\-_\*]||g;
        $name_pattern =~ s|\*\*|*|g;
        $name_pattern =~ s|\*|\.*|g;
        push( @matched_names, $a_name )
            if $zenka_name =~ m|^$name_pattern$|
            or $inverse_match and $zenka_name !~ m|^$name_pattern$|;
        next;
    }
    push( @matched_names, $a_name )
        if $a_name eq $zenka_name                         # zenka name matches
        or $a_name =~ m|^\!(.+)$| and $1 ne $zenka_name;  # inverse match
}

while ( $zenka_instance->{'output_buffer'} =~ s|^([^\n]*)\n||s ) {
    my $output_line = $1;
    utf8::decode($output_line);

    say $output_line    ##  display when verbose or log level 0  ##
        if <system.verbosity.console> or $output_line =~ m|\Q $ANSI{bold}\E|;

    ## remove colors before matching .., ##
    <[base.strip_ansi]>->( \$output_line );

    if (@matched_names) {    ## matching pattern name exists ##
        $output_line =~ s{^\.( +[^\.]+)?\.+($zenka_name|<zenka_name>) +\. }{};
        foreach my $pattern_name (@matched_names) {
            foreach my $pattern (
                keys %{ <nroot.patterns.zenka_output>->{$pattern_name} } ) {
                if ( my @matches = $output_line =~ $pattern ) {

                    <[base.log]>->( 0, '<<M>>' . $pattern )
                        if <nroot.patterns.log_matches>;

                    <nroot.patterns.zenka_output>->{$pattern_name}->{$pattern}
                        ->( $instance_id, $zenka_name, @matches );
                }
            }
        }
    } else {
        warn "no defined output patterns matching zenka '$zenka_name'"
            if not exists <nroot.status.warning>->{"pattern_$zenka_name"};
        <nroot.status.warning>->{"pattern_$zenka_name"} = 1;
    }
}

#.............................................................................
#AJ72AIOEB3LCL2S4FZCHGVNJSM6BU42I7HZQMTUH363NYGFOBY7TNETKIJSP5MBU3Q5DFSDGNFCJW
#::: 26PTTUXQD7RBTTF2NBP75MNFBKMVMV5OTSUPTG24FUXM2A3L5Z6 :::: NAILARA AMOS :::
# :: 6ADEATM3UM3QXJEPCMQ565V4ZYFRLBFTTYSUI5CMU4UT5WKFCEBA :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
