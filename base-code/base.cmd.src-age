# >:]

# name  = base.cmd.src-age
# param = ['date'] [VERSION]
# descr = return age of installed p7 source code

my $network_time;

my $param_str     = shift->{'args'} // '';
my $date_mode     = $param_str =~ s|^date *|| ? 1 : 0;
my $B32_re        = <regex.base.base_32>;
my $current_ntime = <[base.ntime]>;

if ( ( not exists <system.zenka.type> or <system.zenka.type> ne qw| cube | )
    and length($param_str) ) {  # <-- no second param for non-cube type zenki.
    return {
        'mode' => 'false',
        'data' => "ask a 'cube'-type zenka for custom values"
    };
} elsif ( $param_str =~ m|^($B32_re+)\-\d+\.\d+$| )
{    # <-- strict format [LLL]
    $network_time = $LAST_PAREN_MATCH;
} elsif ( length($param_str) ) {
    return {
        'mode' => 'false',
        'data' => "version syntax not valid [ check 'src-ver' ]"
    };
} elsif ( <protocol-7.src-ver> =~ m|^($B32_re+)\-\d+\.\d+$| ) {
    $network_time = $LAST_PAREN_MATCH;
}
return { 'mode' => 'false', 'data' => 'have no version time-stamp' }
    if not defined $network_time;

my $src_ntime = <[base.b32.ntime]>->($network_time);

return { 'mode' => 'false', 'data' => 'decoding not successful' }
    if not defined $src_ntime
    or $src_ntime < 2455747200000;    # <-- network-time begin

my $src_unix = <[base.n2u_time]>->($src_ntime);

( my $date_stamp   = <[base.parser.timestamp]>->($src_unix) ) =~ s|:\d\d$||;
( my $duration_str = <[base.parser.duration]>->($src_unix) )  =~ s|^0s$|0m|;

return { 'mode' => 'true', 'data' => $date_stamp } if $date_mode;

return { 'mode' => 'true', 'data' => $duration_str }

#.............................................................................
#6UNK55LS7GEZBJRUPSB5S7FQTV4HTWTMOM4XYXQ5SR53UFPTXBN2IAOUFNAHDUNAI6TVCLSHGO2M2
#::: YZUH2FPZRU4ESV62HENBM6VLUDSLTMV55KKBDQZFPAHPPUVYFCB :::: NAILARA AMOS :::
# :: I7GD6ZCCO2KDC2ITCQLES6SJXBCQCGB5RCNQUTCB5OAIJGECEECQ :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
