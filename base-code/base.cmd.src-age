# >:]

# name  = base.cmd.src-age
# param = ['date'] [VERSION]
# descr = return age of installed p7 source code

my $network_time;

my $param_str     = shift->{'args'} // '';
my $date_mode     = $param_str =~ s|^date *|| ? 1 : 0;
my $B32_re        = <regex.base.base_32>;
my $current_ntime = <[base.ntime]>;

if ( ( not exists <system.zenka.type> or <system.zenka.type> ne 'cube' )
    and length($param_str) ) {   # <-- no second param for non-cube type zenki.
    return {
        'mode' => 'nak',
        'data' => "ask a 'cube'-type zenka for custom values"
    };
} elsif ( $param_str =~ m|^($B32_re+)\-\d+\.\d+$| ) {  # <-- strict format [LLL]
    $network_time = $LAST_PAREN_MATCH;
} elsif ( length($param_str) ) {
    return {
        'mode' => 'nak',
        'data' => "version syntax not valid [ check 'src-ver' ]"
    };
} elsif ( <protocol-7.src-ver> =~ m|^($B32_re+)\-\d+\.\d+$| ) {
    $network_time = $LAST_PAREN_MATCH;
}
return { 'mode' => 'nak', 'data' => 'have no version time-stamp' }
    if not defined $network_time;

my $src_ntime = <[base.b32.ntime]>->($network_time);

return { 'mode' => 'nak', 'data' => 'decoding not successful' }
    if not defined $src_ntime
    or $src_ntime < 2455747200000;    # <-- network-time begin

my $src_unix = <[base.n2u_time]>->($src_ntime);

( my $date_stamp   = <[base.parser.timestamp]>->($src_unix) ) =~ s|:\d\d$||;
( my $duration_str = <[base.parser.duration]>->($src_unix) )  =~ s|^0s$|0m|;

return { 'mode' => 'ack', 'data' => $date_stamp } if $date_mode;

return { 'mode' => 'ack', 'data' => $duration_str }

#.............................................................................
#EZK3SEOD7QJPP3SRI7OBH5UNENUP63SLYVGTOWJTMSBPHG6GQMD56MA4ETZMY75QKV6W543CDVLX6
#::: S376GG6MR5VO75DHVRYYTYO5I6UXO2AOEBZSDUP7I4IPZ64DGX2 :::: NAILARA AMOS :::
# :: YJ3W4WCJO7YD6VEPAXAUX5ZG4T4H22GJ6PSBBBQMIKOEIVVGF4CQ :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
