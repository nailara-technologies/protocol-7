# >:]

# name  = base.resolve_key_parent
# descr = resolve hash key and return parent hashref or undef if hey not found

my $key_str  = shift // '';
my $hash_ref = shift // *data{HASH};
warn 'expected valid key string parameter <{C1}>' if not length $key_str;
warn 'second parameter not a hash reference <{C1}>'
    if ref $hash_ref ne qw| HASH |;

## note : syntax is allowing keys containing '.'s by single quoting them ##
my @dtree = <[base.parser.data_hkey_tree]>->($key_str);

while ( my $sub_key = shift @dtree ) {
    if ( not defined ${$hash_ref}{$sub_key} ) { return undef }
    if ( @dtree and ref( ${$hash_ref}{$sub_key} ) eq qw| HASH | ) {
        $hash_ref = \%{ $$hash_ref{$sub_key} };
    } elsif ( scalar @dtree == 0 ) {
        return $hash_ref    ##  <--  parent reference  ##
    } else {
        ## no such key ##
        return undef;
    }
}
return undef;

#.............................................................................
#XN6ODUW5LRY7CZCDRDQIX2XHQWO7YSVZFDPBJNQNPRPU2DSO7B2KOSVAYFI65ZHEYAYV7GRCX7KLS
#::: NRCJLXPHV6X72TYNILI6BYOO6BHYJJUHTENX6WUIPJA22XZMVPI :::: NAILARA AMOS :::
# :: EGBKHBUJTBGTDQBC5ZXTJVGMZEIOSKZH5GXGDV62MMOTMOKPLSDA :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
