## >:] ##

# name  = base.resolve_key_parent
# descr = resolve hash key and return parent hashref or undef if hey not found

my $key_str  = shift // '';
my $hash_ref = shift // *data{HASH};
warn 'expected valid key string parameter <{C1}>' if not length $key_str;
warn 'second parameter not a hash reference <{C1}>'
    if ref $hash_ref ne qw| HASH |;

## note : syntax is allowing keys containing '.'s by single quoting them ##
my @dtree = <[base.parser.data_hkey_tree]>->($key_str);

while ( my $sub_key = shift @dtree ) {
    if ( not defined ${$hash_ref}{$sub_key} ) { return undef }
    if ( @dtree and ref( ${$hash_ref}{$sub_key} ) eq qw| HASH | ) {
        $hash_ref = \%{ $$hash_ref{$sub_key} };
    } elsif ( scalar @dtree == 0 ) {
        return $hash_ref    ##  <--  parent reference  ##
    } else {
        ## no such key ##
        return undef;
    }
}
return undef;

#,,,.,.,.,...,.,.,.,.,.,.,...,.,,,..,,.,.,...,..,,...,...,...,...,,..,,.,,.,.,
#3BIBNGYU3XTV3YDQFBL55L4QTCDHEH74GHJUWMHIMXH7X5YSE66WK5TWDU4HNUZKSQ4ES4T5PIWRA
#\\\|XSCHGGNH43FYBJMLTNCH4IZWXOFBKQC4J3BYG3PLILV34JNIQLL \ / AMOS7 \ YOURUM ::
#\[7]4JO5TLRTD5IRA4JTI7BNNQCHMAR5UVAN4JP4LBWV6CRWDUCMRAAA 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
