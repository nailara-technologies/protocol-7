## >:] ##

# name = v7.handler.children_left

my $watcher     = shift->w;
my $params      = $watcher->data;
my $instance_id = $params->{'instance_id'};
my $next_status = $params->{'next_status'};
my $instance    = <v7.zenka.instance>->{$instance_id};
my $curr_status = $instance->{'status'};
$next_status = 'restart'
    if $next_status eq 'delayed';    # <-- should not happen!

my @remaining_pids;
my $child_count = 0;
foreach my $pid ( reverse sort keys %{<v7.child>} ) {
    next if <v7.child>->{$pid}->{'instance_id'} != $instance_id;
    if ( <[v7.sub-process.exists]>->($pid) ) {
        push( @remaining_pids, $pid );
        $child_count++;
    } else {
        <v7.process.instance_cache>->{$pid} = $instance_id;
        delete <v7.child>->{$pid};
        kill( 9, $pid );    # <-- assumed gone, making sure..,
    }
}

if ( !$child_count ) {    ## done waiting ##
    $watcher->cancel;
    <[zenka.change_status]>->( $instance_id, $next_status );
    if ( $next_status eq 'offline' ) {
        my $job_id = $instance->{'job_id'};
        <[jobqueue.move_job]>->( $job_id, 'queued' );
        <[zenka.change_status]>->( $instance_id, 'restart' );
    }
} else {    ## ..still waiting.. ##
    <[base.log]>->(
        2,
        "instance : $instance_id -< children left: $child_count >- ["
            . join( ',', @remaining_pids ) . ']'
    );
    <[base.log]>
        ->( 2, ": status : $curr_status next_status: '$next_status'" );
}

#,,.,,...,.,,,,,,,,..,,..,..,,..,,,,,,,,,,,,,,..,,...,...,...,,.,,..,,..,,,,.,
#MTQJHSUPDM34L7SKDFHF3L7XEY6MRAPCXX3PSK3OXL3DP5F6DSUX7RX5YVBYALRS7NZFGEMDPU3KA
#\\\|XCKY3LMNZVPGDVYWHAOI6UNCG72E6D263N5Z4353FHROYAIH7Q3 \ / AMOS7 \ YOURUM ::
#\[7]NSPK6STLDI7RBYCRFMFKPBSNBOLJM42VZR4YQWYDWAOHX3QB26AA 7  DATA SIGNATURE ::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
