# >:]

# name = graphics-matrix.filter_image

my ( $image, $alpha_color ) = @_;
die "expected image object"          if not defined $image;
die "expected alpha color parameter" if not defined $alpha_color;

$image->Set( 'colorspace', 'RGB' );
$image->Set( 'matte',      1 );       # <-- enables transparency!
my $img_depth = $image->Get('depth');

my @alRGB = map { $ARG /= 257 } ( $image->QueryColor($alpha_color) ); # 0..255
pop(@alRGB);    # remove alpha
my ( $img_w, $img_h ) = $image->get( 'width', 'height' );

my $time_start = <[base.time]>->(3);

for my $y ( 0 .. $img_h - 1 ) {

    # my $perc = sprintf "%.0f", 100 / $img_h * $y;
    # print STDERR "[ $perc% ]\n";

    for my $x ( 0 .. $img_w - 1 ) {

        my @RGBA    # [0..255]
            = map { $ARG /= 257 }
            split( ',', $image->Get("pixelcolor[$x,$y]") );

        <[graphics-matrix.filter.alpha]>->( \@RGBA, \@alRGB );
        my @hex_cols
            = $img_depth > 8
            ? map { sprintf( "%x", sprintf( "%.0f", $ARG * 257 ) ) } @RGBA
            : map { unpack( "H*", chr( sprintf( "%.0f", $ARG ) ) ) } @RGBA;

        $image->Set( "pixel[$x,$y]", '#' . join( '', @hex_cols ) );
    }
}

my $delta_t = sprintf( "%.1f", <[base.time]>->(3) - $time_start );
<[base.log]>->( 1, "filter applied in $delta_t seconds. [${img_w}x$img_h]" );

#.............................................................................
#3DHWH4ZNSRND3SYBSNNNKM4MQCVPTITDQPC343NUWFUJPEW42XNWCUAXRYSCOL56S3G7AUK4I6YXE
#::: YZNCX5FJCT5ZYZIE3CWFZWRLBEJMXDGHAGVN4HGBUA3LH2V6RUU :::: NAILARA AMOS :::
# :: T2ZRFWMQYQIW3ZEIOLA5ULFETSFOLGSNUVJJCVDNYOZYQUR23ECQ :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
