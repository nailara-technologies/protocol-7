# >:]

# name  = net.unix.authme
# descr = unix domain socket auth. [ client ]
# todo  = implement client side authentication timeout

my $answer;
my $banner_string;
my ( $backend_socket, $user ) = @_;

if (   not defined $backend_socket
    or !-S $backend_socket
    or !$backend_socket->connected ) {
    <[base.log]>->(
        0, '\<net.unix.authme> cannot authenticate [ expecting valid socket ]'
    );
    return undef;
}

if ( <[base.s_read]>->( $backend_socket, \$banner_string, 4 ) ) {
    if ( $banner_string eq ">:]\n" ) {
        <[base.log]>->( 2, '[*] protocol seven banner detected.,' );
    } else {
        <[base.log]>->(
            0, '[#] protocol mismatch [ no valid connection banner ]'
        ) and return undef;
    }
    <[net.out]>->( $backend_socket, "select unix\n" );
    <[base.sleep]>->(0.2);

    my $answer = readline($backend_socket);
    chomp($answer) if defined $answer;

    if ( not defined $answer ) {
        <[base.log]>->( 0, '[X] connection lost `:|' ) and return undef;
    } elsif ( $answer ne 'TRUE continue' ) {
        <[base.log]>->( 0, '[#] unix auth. not available >:|' )
            and return undef;
    } else {
        <[base.log]>->( 2, '[*] unix auth. selected' );
        $answer = '';
    }
    <[net.out]>->( $backend_socket, "auth $user\n" );

    return <[auth.zenka.process_auth_reply]>->($backend_socket);
}

#.............................................................................
#34FWZC4RJD74N2X4GYH5I5VOAY2SYF7Z2IBNR5D7VMGG2KKD53KV6L44I7XIK67F5ZL2EM4TODVH6
#::: H4VGMTS5BZB2SINNL2LVG2DAPJQIGQZA5NP5BIKH2QP6YYWQ6LW :::: NAILARA AMOS :::
# :: VFXEVJLMCMUQSGVZFJ5JTN3VGIBN4L2LXH42SQAIPZ5RFGPII2BY :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
