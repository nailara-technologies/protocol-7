# >:]

# name  = sourcecode.console.update-signatures
# descr = regenerate source code signature sections

my $source_version  = <protocol-7.src-ver>;
my $release_version = <protocol-7.rel-ver>;

my $exclude_files = { qw| bin/p7c | => 1 };    ## <-- expand as required., ###

my $paths = <sourcecode.path>;    # <-- prepared in 'sourcecode.init_code'

my $work_tree    = $paths->{'work_tree'};
my $source_root  = $paths->{'source_subdir'};
my $version_root = $paths->{'version_root'};

my @copy_sources = qw[
    bin
    bin/dev
    read-me
    base-code
    bin/admin
    read-me/md
    configuration
    bin/dev/scripts
    bin/dependencies
    bin/dev/git-hooks
    data/lib-path/pm
    data/lib-path/pm/*
    configuration/zenki/*
    read-me/documentation/*
    data/lib-path/pm/AMOS/*
    data/lib-path/pm/AMOS.pm
    data/lib-path/pm/AMOS/CHKSUM/*
];

my @all_files;

my $work_path_abs = abs_path($work_tree);

my @all_dirs = grep {defined} map {
    my $absolute_path = abs_path( catfile( $work_path_abs, $ARG ) );
    if ( -f $absolute_path ) {
        push( @all_files, $absolute_path );
        undef;
    } else {
        <[file.match_dirs]>->( $work_path_abs, 'recursive', $ARG );
    }
    }
    grep { !m|\*| } @copy_sources;

push(    ## enabling [non-recursive] wildcard matches ##
    @all_dirs,
    map {
        ( my $base_path = $ARG ) =~ s|/*\*.*$||;
        ( my $pattern   = $ARG ) =~ s|^[^\*]*||;
        my $absolute_path = abs_path( catfile( $work_tree, $base_path ) );
        <[file.match_dirs]>->( $absolute_path, $pattern );
        }
        grep {m|\*|} @copy_sources
);

map {
    my $source_path = $ARG;
    die "source path '$source_path' does not exist" if !-d $source_path;
    if ( !-w $source_path ) {
        <[base.log]>->(
            0, "<< missing write permissions for '$source_path' >>"
        );
        <[base.exit]>->(4);
    }
} @all_dirs;

<[base.log]>->( 1, '.:[ UPDATING SOURCE SIGNATURES ]:.' );

foreach my $absolute_path (@all_dirs) {
    <[file.all_files]>->( $absolute_path, \@all_files );
}

my @source_paths
    = grep { $ARG =~ s|^$work_tree/?||; not exists $exclude_files->{$ARG} }
    grep { !m{/\.|~$} } @all_files;

my $file_count = scalar @source_paths;

map {
    <[log.error]>->("source file ./$ARG is not writable")
        if not -w "$work_tree/$ARG"
} @source_paths;

<[base.log]>->( 1, "* updating $file_count source file signatures..," );
foreach my $path_rel (@source_paths) {
    my $path_abs = catfile( $work_tree, $path_rel );

    <[base.log]>->( 2, ':' );

    my $code_data_ref = <[source.cmd.get-code-signed]>
        ->( { 'args' => $path_rel, 'skip-valid' => 1 } );

    ## allow for SIGINT ##
    <[event.once]>;

    next
        if $code_data_ref->{'mode'} eq 'true'
        and $code_data_ref->{'data'} eq 'still valid. =)';

    die "failed to create signature for \"$path_rel\""
        if $code_data_ref->{'mode'} ne qw| size |
        or !length( $code_data_ref->{'data'} );

    <[base.log]>->( 1, ':.' );
    <[base.log]>->( 1, ":::[ $path_rel ]:.<+>.::" );
    <[base.log]>->( 1, ':' );

    $file_count--;
    <[file.put]>->( $path_abs, $code_data_ref->{'data'} );
}

<[base.log]>->( 1, ': : success =)' ) if !$file_count;

#.............................................................................
#5K5IEWVNEI7LMAUFY7NI2NKGDKOVAJJXTKMGSGF4KSWELC4E4CNIUYOOWLMPSJTUCEPCRE7GS72UU
#::: 3WGN7W6XF5K3VQ2EJ33CG4VMC3RNCHNH4OYWHZLJNYR2TVAN5CX :::: NAILARA AMOS :::
# :: RWD4OPJBPHT7OB6CLH2434ICTTMG74CW42KNQDWELYPEYBS5YWCI :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
