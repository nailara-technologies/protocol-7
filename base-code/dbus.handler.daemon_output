# >:]

# name  = dbus.handler.daemon_output
# descr = reads output from dbus process

<nroot.patterns.zenka_output> //= {};

my $event   = shift->w;
my $read_fh = $event->fd;
my $server  = $event->data;
my $bin     = $server->{'bin'};
my $pid     = $server->{'pid'};

<dbus.output_buffer> //= '';

my $read_bytes = <[base.s_read]>->(
    $read_fh, \$data{'dbus'}{'output_buffer'},
    4096,     length(<dbus.output_buffer>)
);
if ( not defined $read_bytes or $read_bytes == 0 )
{    # ( filehandle exception )
    $event->cancel;
    close($read_fh);
    <[base.log]>->( 1, "$bin [PID:$pid] output filehandle closed." );
    kill( 9, $pid );    # to make sure
    my $err_str
        = defined <dbus.first_error>
        ? ': "' . <dbus.first_error> . '"'
        : ' unexpectedly! (reason unknown)';
    <[base.log]>->( 0, "$bin died" . $err_str );
    <[base.log]>->( 1, "done." );
    exit(2);
}

while ( <dbus.output_buffer> =~ s|^([^\n]*)\n||s ) {
    my $output_line = $1;
    $output_line =~ s|\r||sg;
    if ( $output_line =~ m|^(unix:abstract=([^\n,]+),[^\n]+)$| ) {
        <dbus.socket_addr> = $1;
        <dbus.socket_path> = $2;
        my $privs_user = <dbus.privs_user>;
        <[base.log]>->( 1, ": socket path : $2 [owner:'$privs_user']" );
        <[base.async.get_session_id]>;
    } else {
        my $log_level = $output_line =~ m{ctivat(ing|ed) service} ? 2 : 0;
        <[base.log]>->( $log_level, "< $bin > " . $output_line );
    }
}

#.............................................................................
#W3PWIVCZEDXEWQLYHIUG6QQPFA65TBQMVJYGOWNO6A47G5VPJGU7AS5WVQPEQLR4NCW6FLCIROFM2
#::: I3TMLSLIGO6GBSAOR5ZVAAYBM6KXIWIE7GMU3EH7KKO4Q3A7NF6 :::: NAILARA AMOS :::
# :: CYA4CDFITUOA67GMFJO54RG74IT7F5UBMHNN7WAYEFTI5POIRCBQ :: CODE SIGNATURE ::
# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
